import React, { useRef, useEffect, useState, memo, useMemo, FC, useCallback, Component } from 'react'
import { v4 as uuidv4 } from 'uuid'
import useLocalStorage from '../../hooks/useStorage'
import { BlobSingle } from './BlobSingle'
import { BackgroundColor } from './blobInterfaces'
import { Draggable } from './blobInterfaces'


// const useSlider = ({ value, ...config }) => {
//     const [sliderVal, setSliderVal] = useState(value);

//     const [configuration, setConfiguration] = useState(config);

//     const onChange = useCallback(val => {
//         setSliderVal(val);
//     }, []);

//     useEffect(() => {
//         setConfiguration({
//             ...config,
//             onChange,
//             value: sliderVal
//         });
//     }, [sliderVal]);

//     // console.log(configuration)
//     return [sliderVal, configuration];
// };


// const RangeSlider = memo(
//     ({ onChange, value, ...sliderProps }) => {
//         const [sliderVal, setSliderVal] = useState(0);
//         const [mouseState, setMouseState] = useState(null);

//         useEffect(() => {
//             setSliderVal(value);
//         }, [value]);

//         const changeCallback = e => {
//             setSliderVal(e.target.value);
//         };

//         useEffect(() => {
//             if (mouseState === "up") {
//                 onChange(sliderVal);
//             }
//         }, [mouseState]);
//         return (
//             <div className="range-slider">
//                 <p>Value: {sliderVal}</p>
//                 <input
//                     type="range"
//                     value={sliderVal}
//                     {...sliderProps}
//                     onChange={changeCallback}
//                     onMouseDown={() => setMouseState("down")}
//                     onMouseUp={() => setMouseState("up")}
//                 />
//             </div>
//         );
//     }
// );


// const [slider1, setSlider1] = useSlider(
//     {
//         min: 0,
//         max: 100,
//         value: 30,
//         step: 1
//     }
// );

// const [slider2, setSlider2] = useSlider(
//     {
//         min: 0,
//         max: 100,
//         value: 80,
//         step: 1
//     }
// );


// const [slider3, setSlider3] = useSlider(
//     {
//         min: 0,
//         max: 359,
//         value: 214,
//         step: 1
//     }
// );








export default function BlobJS() {













    let number = 0






    // function increaseZ() {
    //     setDragItemState(prevState => {
    //         return {
    //             ...prevState, i: prevState.i + 1
    //         }
    //     })
    // }
    // function resetZ() {
    //     setDragItemState(prevState => {
    //         return {
    //             ...prevState, z: 0
    //         }
    //     })
    // }


    // const [state, setState] = useState({
    //     count: 0,
    //     color: 'blue'
    // })
    // const count = state.count
    // const color = state.color


    // function decrementCount() {
    //     setState(prevState => {
    //         return {
    //             ...prevState, count: prevState.count - 1
    //         }
    //     })
    // }
    // function incrementCount() {
    //     setState(prevState => {
    //         return {
    //             ...prevState, count: prevState.count + 1
    //         }
    //     })
    // }

    //example use: 
    //<button onClick={decrementCount}> - </button>
    //<span>{state}</span> //increases or decreases this
    //<button onClick={incrementCount}> + </button>










    let hasRun = false



    //const dragContainer = document.querySelectorAll(".drag-container")
    const dragContainer = document.querySelector(".drag-container")

    let isFirst = true

    const d = 0

    // dragContainer.forEach((dragContainer, d) => {


    //const dragWrapOuter = dragContainer?.querySelector<HTMLDivElement>(".drag-wrap-outer")
    //const dragWrap = dragContainer?.querySelector<HTMLDivElement>(".drag-wrap")
    //const dragUl = dragContainer?.querySelector<HTMLUListElement>(".drag-wrap ul")
    //const exitBlob = dragContainer?.querySelector<HTMLButtonElement>('.exitblob')

    const dragWrapOuter = useRef() as RefObject<HTMLDivElement>
    const dragWrap = useRef() as RefObject<HTMLDivElement>
    const dragUl0 = useRef() as RefObject<HTMLUListElement>

    const selectedvalue0 = useRef() as RefObject<HTMLDivElement>

    const exitBlob = useRef() as RefObject<HTMLDivElement>
    const backgroundColor: BackgroundColor[][] = []
    const draggables: Draggable[][] = []


    let angle = "90deg"
    let color1 = "cyan"
    let color2 = "yellow"


    function loadBackground(): BackgroundColor[] {
        const backgroundColorJSON = localStorage.getItem(`BackgroundColor${[d]}`)
        if (backgroundColorJSON == null) return []
        return JSON.parse(backgroundColorJSON)
    }
    function loadDraggables(): Draggable[] {
        const draggablesJSON = localStorage.getItem(`Draggables${[d]}`)
        if (draggablesJSON == null) return []
        return JSON.parse(draggablesJSON)
    }



    function saveBackground() {
        localStorage.setItem(`BackgroundColor${[d]}`, JSON.stringify(backgroundColor[d]))
    }
    function saveDraggables() {
        localStorage.setItem(`Draggables${[d]}`, JSON.stringify(draggables[d]))
    }



    const [dragItemState, setDragItemState] = useState<Draggable[]>([],)

    const [selectedBlobId, setSelectedBlobId] = useState()

    const selectedBlob = dragItemState.find(blob => blob.id === selectedBlobId)

    function selectBlob(id: React.SetStateAction<undefined>) {
        setSelectedBlobId(id)
        console.log("Selected blob: " + selectedBlob)
    }

    backgroundColor[d] = loadBackground()

    draggables[d] = loadDraggables()

    //console.log(draggables[d])

    let hasBeenMadeFromStorage: Boolean

    function makeFromStorage() {
        if (backgroundColor[d].length > 1) {
            dragWrapOuter.current?.style.setProperty('--lightness', `${backgroundColor[d][0]}`)
            dragWrapOuter.current?.style.setProperty('--saturation', `${backgroundColor[d][1]}`)
            dragWrapOuter.current?.style.setProperty('--hue', `${backgroundColor[d][2]}`)
        }
        if (!hasBeenMadeFromStorage && draggables[d].length > 1) {
            for (let i: number = 0; i < draggables[d].length; i++) {
                if (draggables[d][i]) {
                    setDragItemState(current =>
                        [...current, {
                            id: `${draggables[d][i].id}`,
                            number: draggables[d][i].number,
                            i: draggables[d][i].i,
                            x: `${draggables[d][i].x}`,
                            y: `${draggables[d][i].y}`,
                            z: `${draggables[d][i].z}`,
                            display: `${draggables[d][i].display}`,
                            ariaGrabbed: false,
                            draggable: true,
                            tabIndex: 0,
                            background: `${draggables[d][i].background}`,

                        }]
                    )
                }
            }

        } hasBeenMadeFromStorage = true
    }

    //const resetBlobs = document.querySelector(".reset-blobs")
    const resetBlobs = useRef() as RefObject<HTMLButtonElement>



    function resetBlobsFunction(e: React.MouseEvent) {
        e.preventDefault()

        //dragUl0.current?.replaceChildren();

        window.localStorage.removeItem(`Draggables${[d]}`)
        // hasRun = false to allow initialize to run again
        //initialize()
        //draggables[d] = []
        setDragItemState([
        ],)

        make(AmountOfBlobs)
        //setup()
    }


    interface RefObject<T> {
        readonly current: T | null
        // readonly current: T
    }

    const [selectedText, setSelectedText] = useState("none")


    const defaultLightness = "30"
    const defaultSaturation = "80"
    const defaultHue = "214"

    const [slider1Val, setSlider1Val] = useState(backgroundColor[d][0] ?? defaultLightness);
    const [slider2Val, setSlider2Val] = useState(backgroundColor[d][1] ?? defaultSaturation);
    const [slider3Val, setSlider3Val] = useState(backgroundColor[d][2] ?? defaultHue);

    // const sliderLightnessInput = useRef(backgroundColor[d][0] ?? defaultLightness)
    // const sliderSaturationInput = useRef(backgroundColor[d][1] ?? defaultSaturation)
    // const sliderHueInput = useRef(backgroundColor[d][2] ?? defaultHue)

    const sliderLightnessInput = useRef() as RefObject<HTMLInputElement>
    const sliderSaturationInput = useRef() as RefObject<HTMLInputElement>
    const sliderHueInput = useRef() as RefObject<HTMLInputElement>

    const [dragWrapOuterLightness, setDragWrapOuterLightness] = useState<React.CSSProperties>(
        sliderLightnessInput.current ? {
            ['--lightness' as any]: `${sliderLightnessInput.current.value}`
        } : {
            ['--lightness' as any]: `${slider1Val}`
        }
    );
    const [dragWrapOuterSaturation, setDragWrapOuterSaturation] = useState<React.CSSProperties>(
        sliderSaturationInput.current ? {
            ['--saturation' as any]: `${sliderSaturationInput.current.value}`
        } : {
            ['--saturation' as any]: `${slider2Val}`
        });
    const [dragWrapOuterHue, setDragWrapOuterHue] = useState<React.CSSProperties>(
        sliderHueInput.current ? {
            ['--hue' as any]: `${sliderHueInput.current.value}`
        } : {
            ['--hue' as any]: `${slider3Val}`
        });

    // const dragWrapOuterStyle: React.CSSProperties = {
    //     ['--lightness' as any]: `${slider1Val}`,
    //     ['--saturation' as any]: `${slider2Val}`,
    //     ['--hue' as any]: `${slider3Val}`
    // };

    let lightness = slider1Val
    let saturation = slider2Val
    let hue = slider3Val

    useEffect(() => {
        const lightness: BackgroundColor = backgroundColor[d][0] ? backgroundColor[d][0] : defaultLightness
        const saturation: BackgroundColor = backgroundColor[d][1] ? backgroundColor[d][1] : defaultSaturation
        const hue: BackgroundColor = backgroundColor[d][2] ? backgroundColor[d][2] : defaultHue

        setSlider1Val(lightness ?? defaultLightness)

        setSlider2Val(saturation ?? defaultSaturation)

        setSlider3Val(hue ?? defaultHue)

        setDragWrapOuterLightness({ ['--lightness' as any]: `${lightness}` })
        setDragWrapOuterSaturation({ ['--saturation' as any]: `${saturation}` })
        setDragWrapOuterHue({ ['--hue' as any]: `${hue}` })

        backgroundColor[d][0] = lightness
        backgroundColor[d][1] = saturation
        backgroundColor[d][2] = hue

        saveBackground()
    }, [])


    function sliderLightness() {
        lightness = slider1Val
        if (dragWrapOuter.current) {
            //dragWrapOuter.style.setProperty('--lightness', `${lightness}`)
            setDragWrapOuterLightness({ ['--lightness' as any]: `${lightness}` })

            const background: BackgroundColor = lightness
            backgroundColor[d][0] = background
            saveBackground()
        }
    }
    function sliderSaturation() {
        saturation = slider2Val
        if (dragWrapOuter.current) {
            //dragWrapOuter.style.setProperty('--saturation', `${saturation}`)
            setDragWrapOuterSaturation({ ['--saturation' as any]: `${saturation}` })
            const background: BackgroundColor = saturation
            backgroundColor[d][1] = background
            saveBackground()
        }
    }
    function sliderHue() {
        hue = slider3Val
        if (dragWrapOuter.current) {
            //dragWrapOuter.style.setProperty('--hue', `${hue}`)
            setDragWrapOuterHue({ ['--hue' as any]: `${hue}` })
            const background: BackgroundColor = hue
            backgroundColor[d][2] = background
            saveBackground()
        }
    }

    //To force the sliders to update
    useEffect(() => {
        if (sliderLightnessInput.current) setSlider1Val(sliderLightnessInput.current.value)
    }, [slider1Val, sliderLightnessInput?.current?.value]);

    useEffect(() => {
        if (sliderSaturationInput.current) setSlider2Val(sliderSaturationInput.current.value)
    }, [slider2Val, sliderLightnessInput?.current?.value]);

    useEffect(() => {
        if (sliderHueInput.current) setSlider3Val(sliderHueInput.current.value)
    }, [slider3Val, sliderLightnessInput?.current?.value]);


    function sliderLightnessReset() {
        //dragWrapOuter.current?.style.setProperty('--lightness', `${defaultLightness}`)
        setDragWrapOuterLightness({ ['--lightness' as any]: `${defaultLightness}` })
        if (sliderLightnessInput.current) sliderLightnessInput.current.value = defaultLightness
        setSlider1Val(defaultLightness)
    }
    function sliderSaturationReset() {
        //dragWrapOuter?.style.setProperty('--saturation', `${slider2Val}`)
        setDragWrapOuterSaturation({ ['--saturation' as any]: `${defaultSaturation}` })
        if (sliderSaturationInput.current) sliderSaturationInput.current.value = defaultSaturation
        setSlider2Val(defaultSaturation)
    }
    function sliderHueReset() {
        //dragWrapOuter.current?.style.setProperty('--hue', `${slider3Val}`)
        setDragWrapOuterHue({ ['--hue' as any]: `${defaultHue}` })
        if (sliderHueInput.current) sliderHueInput.current.value = defaultHue
        setSlider3Val(defaultHue)
    }



    // const makeDragLi = () => {

    //     const dragLi: HTMLElement = document.createElement("li")
    //     dragLi.classList.add("dragzone")
    //     dragLi.setAttribute("aria-grabbed", "false")
    //     dragLi.setAttribute("draggable", "true")
    //     dragLi.setAttribute("tabindex", "0")
    //     dragLi.setAttribute("role", "option")


    //     const number = Math.round(getRandomMinMax(0.1, 4))

    //     switch (number) {
    //         case 1:
    //             color1 = "lemonchiffon";
    //             color2 = "greenyellow";
    //             break;
    //         case 2:
    //             color1 = "cyan";
    //             color2 = "yellow";
    //             break;
    //         case 3:
    //             color1 = "cyan";
    //             color2 = "lightsalmon";
    //             break;
    //         case 4:
    //             color1 = "lightsalmon";
    //             color2 = "lemonchiffon";
    //             break;
    //     }
    //     dragLi.style.background = `linear-gradient(${angle}, ${color1},${color2})`
    //     dragLi.style.display = "block"
    //     return dragLi
    // }


    //const [employees, setEmployees] = useState<{ salary: number; name: string }[]>([],);
    //const [age, setAge, removeAge] = useLocalStorage("age", 26)


    let hasNotRunn = true

    const make = useCallback((amount: number) => {
        if (dragItemState.length == 0) {
            console.log("make(" + amount + ")")
            for (let i: number = 0; i < amount; i++) {

                const number = Math.round(getRandomMinMax(0.1, 4))
                switch (number) {
                    case 1:
                        color1 = "lemonchiffon";
                        color2 = "greenyellow";
                        break;
                    case 2:
                        color1 = "cyan";
                        color2 = "yellow";
                        break;
                    case 3:
                        color1 = "cyan";
                        color2 = "lightsalmon";
                        break;
                    case 4:
                        color1 = "lightsalmon";
                        color2 = "lemonchiffon";
                        break;
                }

                setDragItemState(current =>
                    [...current, {
                        id: `blob${i + 1}-${uuidv4()}`,
                        number: i + 1,
                        i: i + 1,
                        x: `${(window.innerWidth / 100) * getRandomMinMax(0, 50)}px`,
                        y: `${(window.innerHeight / 100) * getRandomMinMax(0, 50)}px`,
                        z: "1",
                        display: "block",
                        ariaGrabbed: false,
                        draggable: true,
                        tabIndex: 0,
                        background: `linear-gradient(${angle}, ${color1},${color2})`,

                    }]
                )
            }
            saveDraggables()
        }


    }, []);

    let hasBeenMade: Boolean
    console.log(dragItemState)
    const AmountOfBlobs = 10 // Initial amount of blobs

    useEffect(() => {
        if (hasBeenMade == undefined || hasBeenMade == null || hasBeenMade == false)
            draggables[d].length > 1 ? makeFromStorage() : make(AmountOfBlobs)
        hasBeenMade = true
    }, [])

    const cooldown = () => { hasBeenMade = true }
    setTimeout(cooldown, 100);



    let blobCount = draggables[d].length > AmountOfBlobs ? draggables[d].length : AmountOfBlobs









    const DragComponent = useCallback(({ items }: { items: Draggable[] }) => {
        return (
            <>{
                items.map((item: Draggable, i: number) => {

                    const blobStyle: React.CSSProperties = {
                        'background': `${item.background}`,
                        'display': `${item.display}`,
                        'left': `${item.x}`,
                        'top': `${item.y}`,
                        zIndex: `${item.z}`,
                        ['--i' as any]: `${item.i}`
                    };

                    const blobDraggable: Draggable = {
                        id: item.id,
                        number: item.number,
                        i: item.i,
                        x: item.x,
                        y: item.y,
                        z: item.z,
                        display: item.display,
                        ariaGrabbed: false,
                        draggable: true,
                        tabIndex: 0,
                        background: item.background
                    }
                    draggables[d][item.number - 1] = blobDraggable
                    saveDraggables()

                    return (
                        // <BlobSingle key={item.id} item={item} style={blobStyle} setup={setup} saveDraggables={saveDraggables} d={d} selectBlob={selectBlob} />

                        <li key={uuidv4()}
                            className="dragzone"
                            id={item.id}
                            aria-grabbed={false}
                            role={'option'}
                            tabIndex={item.tabIndex}
                            draggable={item.draggable}
                            style={blobStyle}
                            onMouseDown={e => {
                                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: ${(e.target as HTMLElement)?.querySelector("span")?.textContent}`
                                start(e)
                            }}
                            onMouseMove={e => {
                                movement(e)
                            }}
                            onMouseUp={e => {
                                stopMovement(e)
                                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: none`
                            }}
                            onTouchStart={e => {
                                start(e)
                                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: ${(e.target as HTMLElement)?.querySelector("span")?.textContent}`
                            }}
                            onTouchMove={e => {
                                movement(e)
                            }}
                            onTouchEnd={e => {
                                stopMovement(e)
                                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: none`
                            }}
                            onWheel={e => {
                                wheel(e.target as HTMLLIElement)
                            }}
                            onFocus={e => {
                                focused(e.target)
                                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: ${(e.target as HTMLElement)?.querySelector("span")?.textContent}`
                            }}
                            onBlurCapture={e => {
                                blurred(e.target)
                                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: none`
                            }}
                        // onDragStart={e => selectBlob(item.id)}
                        >
                            <span className="screen-reader-text">Blob {item.number}</span>
                        </li>
                    )

                })

            }</>

        )
    }, [])


    //console.log(positions[d])

    // if (positions[d].length == 0 || positions[d] == undefined || positions[d] == null) {
    //     console.log("(positions[d].length == 0 || positions[d] == undefined || positions[d] == null)")
    //     const dragLiArray = Array.from({ length: 5 }, makeDragLi)
    //     console.log(dragLiArray)
    //     for (let i: number = 0; i < dragLiArray.length; i++) {
    //         console.log("for (let i: number = 0; i < dragLiArray.length; i++)")
    //         dragLiArray[i].style.setProperty('--i', `${dragLiArray.length + 1 - i}`)
    //         dragLiArray[i].setAttribute("id", `blob${i + 1}-${[d]}`)

    //         const dragLiSpan = document.createElement("span")
    //         dragLiSpan.classList.add("screen-reader-text")
    //         dragLiSpan.innerText = `blob ${i + 1}`
    //         dragLiArray[i].append(dragLiSpan)

    //         dragUl?.append(dragLiArray[i])

    //     }
    //     const dragzonesList = document.querySelectorAll<HTMLElement>(".dragzone");
    //     const dragzones = Array.from(dragzonesList as NodeListOf<HTMLElement>)

    //     for (let i: number = 0; i < dragzones.length; i++) {
    //         const blob = document.querySelector<HTMLElement>(`blob${i + 1}-${[d]}`)
    //         place(`blob${i + 1}-${[d]}`, 60 - getRandomMinMax(0, 50), 60 - getRandomMinMax(0, 50))
    //         if (blob) getPosition(blob)

    //         savePosition()
    //     }
    //     setup
    // } else {
    //     makeFromStorage
    //     setup
    // }

    //let blobCount = positions[d].length ?? 5 //keep same as the length of the previous dragLiArray
    const dragzonesList = document.querySelectorAll<HTMLElement>(".dragzone");
    const dragzones = Array.from(dragzonesList as NodeListOf<HTMLElement>)


    // useEffect(() => {
    //     const dragzonesList = document.querySelectorAll<HTMLElement>(".dragzone");
    //     const dragzones = Array.from(dragzonesList as NodeListOf<HTMLElement>)
    //     if (dragzones) {
    //         dragzones.forEach(draggable => {
    //             //Add event listeners
    //             draggable.addEventListener(events[deviceType as keyof typeof events].down, start);
    //             draggable.addEventListener(events[deviceType as keyof typeof events].move, movement);
    //             draggable.addEventListener(events[deviceType as keyof typeof events].up, stopMovement);
    //             draggable.addEventListener("mouseleave", stopMovement);
    //             draggable.addEventListener('blur', blurblob);
    //             draggable.addEventListener('focus', focusedBlob(draggable));
    //             draggable.addEventListener('wheel', zoom, { passive: false });
    //             draggable.addEventListener('keydown', keyDown);

    //         })
    //     }

    //     return () => {
    //         if (dragzones) {
    //             dragzones.forEach(draggable => {
    //                 draggable.removeEventListener(events[deviceType as keyof typeof events].down, start);
    //                 draggable.removeEventListener(events[deviceType as keyof typeof events].move, movement);
    //                 draggable.removeEventListener(events[deviceType as keyof typeof events].up, stopMovement);
    //                 draggable.removeEventListener("mouseleave", stopMovement);
    //                 draggable.removeEventListener('blur', blurblob);
    //                 draggable.removeEventListener('focus', focusedBlob(draggable));
    //                 draggable.removeEventListener('wheel', zoom);
    //                 draggable.removeEventListener('keydown', keyDown);
    //             })
    //         }
    //     }
    // }, [dragzones])



    // const editDragLi = () => {

    //     const dragLiArray = Array.from({ length: 5 }, makeDragLi)

    //     for (let i: number = 0; i < dragLiArray.length; i++) {
    //         dragLiArray[i].style.setProperty('--i', `${dragLiArray.length + 1 - i}`)
    //         dragLiArray[i].setAttribute("id", `blob${i + 1}-${[d]}`)

    //         const dragLiSpan = document.createElement("span")
    //         dragLiSpan.classList.add("screen-reader-text")
    //         dragLiSpan.innerText = `blob ${i + 1}`
    //         dragLiArray[i].append(dragLiSpan)

    //         dragUl0.current?.append(dragLiArray[i])
    //     }


    //     const dragzonesList = document.querySelectorAll<HTMLElement>(".dragzone");
    //     const dragzones = Array.from(dragzonesList as NodeListOf<HTMLElement>)

    //     for (let i: number = 0; i < dragzones.length; i++) {
    //         const blob = document.querySelector<HTMLElement>(`blob${i + 1}-${[d]}`)
    //         place(`blob${i + 1}-${[d]}`, 60 - getRandomMinMax(0, 50), 60 - getRandomMinMax(0, 50))
    //         if (blob) getPosition(blob)
    //     }

    // }

    // if (positions[d].length == 0) { editDragLi }

    function getRandomMinMax(min: number, max: number) {
        return Math.random() * (max - min) + min;
    }



    function place(id: string, x_pos: number, y_pos: number) {
        let element = document.getElementById(id);
        if (element && dragWrap.current) {
            element.style.left = dragWrap.current.offsetWidth / 100 * x_pos + 'px';
            element.style.top = dragWrap.current.offsetHeight / 100 * y_pos + 'px';
        }
    }

    let initialX = 0
    let initialY = 0

    let zIndex = 1
    let zIndex0 = -1
    let moveElement = false;
    let reset = true



    // const colorBlockYellowLime = document.querySelector<HTMLDivElement>(`#color-yellowlime${[d]}`)
    // const colorBlockCyanYellow = document.querySelector<HTMLDivElement>(`#color-cyanyellow${[d]}`)
    // const colorBlockCyanPink = document.querySelector<HTMLDivElement>(`#color-cyanpink${[d]}`)
    // const colorBlockPinkYellow = document.querySelector<HTMLDivElement>(`#color-pinkyellow${[d]}`)

    // const makeLarger = document.querySelector<HTMLDivElement>(`#make-larger${[d]}`)
    // const makeSmaller = document.querySelector<HTMLDivElement>(`#make-smaller${[d]}`)
    // const makeMore = document.querySelector<HTMLDivElement>(`#make-more${[d]}`)
    // const deleteBlob = document.querySelector<HTMLDivElement>(`#delete-blob${[d]}`)

    const colorBlockYellowLime0 = useRef() as RefObject<HTMLDivElement>
    const colorBlockCyanYellow0 = useRef() as RefObject<HTMLDivElement>
    const colorBlockCyanPink0 = useRef() as RefObject<HTMLDivElement>
    const colorBlockPinkYellow0 = useRef() as RefObject<HTMLDivElement>

    const makeLarger0 = useRef() as RefObject<HTMLDivElement>
    const makeSmaller0 = useRef() as RefObject<HTMLDivElement>
    const makeMore0 = useRef() as RefObject<HTMLDivElement>
    const deleteBlob0 = useRef() as RefObject<HTMLDivElement>


    useEffect(() => {
        window.addEventListener('resize', widthResize)

        return () => {
            window.removeEventListener('resize', widthResize)
        }
    }, [])

    const widthResize = () => {

        //place these items every time the window is resized
        if (makeLarger0.current && dragWrap.current) place(`make-larger${[d]}`, 100 - ((makeLarger0.current.offsetWidth / dragWrap.current.offsetWidth) * 100), 0)

        if (colorBlockYellowLime0.current && dragWrap.current) place(`color-yellowlime${[d]}`, 100 - ((colorBlockYellowLime0.current.offsetWidth / dragWrap.current?.offsetWidth) * 100), 18)
        if (colorBlockCyanYellow0.current && dragWrap.current) place(`color-cyanyellow${[d]}`, 100 - ((colorBlockCyanYellow0.current.offsetWidth / dragWrap.current?.offsetWidth) * 100), 38)
        if (colorBlockCyanPink0.current && dragWrap.current) place(`color-cyanpink${[d]}`, 100 - ((colorBlockCyanPink0.current.offsetWidth / dragWrap.current?.offsetWidth) * 100), 58)
        if (colorBlockPinkYellow0.current && dragWrap.current) place(`color-pinkyellow${[d]}`, 100 - ((colorBlockPinkYellow0.current.offsetWidth / dragWrap.current?.offsetWidth) * 100), 78)

        if (makeSmaller0.current && dragWrap.current) place(`make-smaller${[d]}`, 100 - ((makeSmaller0.current.offsetWidth / dragWrap.current.offsetWidth) * 100), 95)
    }




    // Getting the width of the browser on load
    widthResize()

    // Getting the width of the browser whenever the screen resolution changes.
    window.addEventListener('resize', widthResize)


    const getPosition = (draggable: HTMLElement) => {
        const blobID = draggable.id
        const blobNumber = draggable.id.replace(/^\D+/g, '')//replace non-numbers with empty
        const blobI = window.getComputedStyle(draggable).getPropertyValue("--i");
        const blobX = window.getComputedStyle(draggable).getPropertyValue("left");
        const blobY = window.getComputedStyle(draggable).getPropertyValue("top");
        const blobZ = window.getComputedStyle(draggable).getPropertyValue("z-index");
        const blobColor1 = window.getComputedStyle(draggable).getPropertyValue("background");
        const blobDisplay = window.getComputedStyle(draggable).getPropertyValue("display");

        const blobDraggables: Draggable = {
            id: blobID,
            number: parseInt(blobNumber),
            i: parseFloat(blobI),
            x: blobX,
            y: blobY,
            z: blobZ,
            display: blobDisplay,
            ariaGrabbed: false,
            draggable: true,
            tabIndex: 0,
            background: blobColor1
        }

        draggables[d][blobDraggables.number - 1] = blobDraggables
        saveDraggables()
    }

    // useEffect(() => {
    //     setup()
    // }, [])


    // function setup(draggable: HTMLElement) {

    // const dragzonesList = document.querySelectorAll<HTMLElement>(".dragzone");
    // const dragzones = Array.from(dragzonesList as NodeListOf<HTMLElement>)

    // useEffect(() => {
    //     dragzones.forEach((draggable) => {
    //         getPosition(draggable)
    //     })
    // }, [])

    //localStorage.clear()

    //Events Object
    let events = {
        mouse: {
            down: "mousedown",
            move: "mousemove",
            up: "mouseup",
        },
        touch: {
            down: "touchstart",
            move: "touchmove",
            up: "touchend",
        },
    };
    let deviceType = "";

    //Detect possible touch device
    const isTouchDevice = () => {
        try {
            //Try to create TouchEvent (fails for desktops and throws error)
            document.createEvent("TouchEvent");
            deviceType = "touch";
            return true;
        } catch (e) {
            deviceType = "mouse";
            return false;
        }
    }

    isTouchDevice();

    function start(e: TouchEvent | MouseEvent | React.TouchEvent | React.MouseEvent) {
        console.log("start");
        e.stopPropagation();

        e.preventDefault();

        initialX = !isTouchDevice() ? (e as MouseEvent).clientX : (e as TouchEvent).touches[0].clientX;
        initialY = !isTouchDevice() ? (e as MouseEvent).clientY : (e as TouchEvent).touches[0].clientY;

        moveElement = true;
        (e.target as HTMLElement).classList.add("drag");
        zIndex += 1;
        (e.target as HTMLElement).style.setProperty("z-index", `${zIndex}`);
        (e.target as HTMLElement).setAttribute("aria-grabbed", "true");



    }

    interface EventTypes {
    }
    //Handle mousemove and touchmove
    function movement(e: TouchEvent | MouseEvent | React.TouchEvent | React.MouseEvent) {
        console.log("movement")
        e.stopPropagation()
        // setSelectedText(`${(e.target as HTMLElement)?.querySelector("span").innerText}`)

        if (moveElement) {
            e.preventDefault();
            let newX = !isTouchDevice() ? (e as MouseEvent).clientX : (e as TouchEvent).touches[0].clientX;
            let newY = !isTouchDevice() ? (e as MouseEvent).clientY : (e as TouchEvent).touches[0].clientY;
            (e.target as HTMLElement).style.top = (e.target as HTMLElement).offsetTop - (initialY - newY) + "px";
            (e.target as HTMLElement).style.left = (e.target as HTMLElement).offsetLeft - (initialX - newX) + "px";
            initialX = newX;
            initialY = newY;

        }
    }




    //Handle mouse up and touch end
    const stopMovement = (e: TouchEvent | MouseEvent | React.TouchEvent | React.MouseEvent) => {
        console.log("stop movement")

        e.stopPropagation()
        let value = (e.target as HTMLElement).style.getPropertyValue("--i");
        let scale = parseFloat(value)

        if (colorBlockYellowLime0.current && elementsOverlap((e.target as HTMLElement), colorBlockYellowLime0.current)) {
            color1 = "lemonchiffon";
            color2 = "greenyellow";
            (e.target as HTMLElement).style.background = `linear-gradient(${angle}, ${color1},${color2})`;
            (e.target as HTMLElement).removeAttribute('class');
            (e.target as HTMLElement).classList.add("dragzone", "color-yellowlime");
        }

        if (colorBlockCyanYellow0.current && elementsOverlap((e.target as HTMLElement), colorBlockCyanYellow0.current)) {
            color1 = "cyan";
            color2 = "yellow";
            (e.target as HTMLElement).style.background = `linear-gradient(${angle}, ${color1},${color2})`;
            (e.target as HTMLElement).removeAttribute('class');
            (e.target as HTMLElement).classList.add("dragzone", "color-cyanyellow");
        }

        if (colorBlockCyanPink0.current && elementsOverlap((e.target as HTMLElement), colorBlockCyanPink0.current)) {
            color1 = "cyan";
            color2 = "lightsalmon";
            (e.target as HTMLElement).style.background = `linear-gradient(${angle}, ${color1},${color2})`;
            (e.target as HTMLElement).removeAttribute('class');
            (e.target as HTMLElement).classList.add("dragzone", "color-cyanpink");
        }

        if (colorBlockPinkYellow0.current && elementsOverlap((e.target as HTMLElement), colorBlockPinkYellow0.current)) {
            color1 = "lightsalmon";
            color2 = "lemonchiffon";
            (e.target as HTMLElement).style.background = `linear-gradient(${angle}, ${color1},${color2})`;
            (e.target as HTMLElement).removeAttribute('class');
            (e.target as HTMLElement).classList.add("dragzone", "color-pinkyellow");
        }

        if (makeLarger0.current && elementsOverlap((e.target as HTMLElement), makeLarger0.current)) {
            scale += 1;
            scale = Math.min(Math.max(2, scale), 14);
            (e.target as HTMLElement).style.setProperty('--i', `${scale}`)
        }
        if (makeSmaller0.current && elementsOverlap((e.target as HTMLElement), makeSmaller0.current)) {
            scale -= 1;
            scale = Math.min(Math.max(2, scale), 14);
            (e.target as HTMLElement).style.setProperty('--i', `${scale}`)
        }
        if (makeMore0.current && elementsOverlap((e.target as HTMLElement), makeMore0.current)) {
            makeBlob((e.target as HTMLElement))
        }
        if (deleteBlob0.current && elementsOverlap((e.target as HTMLElement), deleteBlob0.current)) {
            hideBlob((e.target as HTMLElement))
        }

        getPosition(e.target as HTMLElement)

        moveElement = false;
        (e.target as HTMLElement).classList.remove("drag");
        (e.target as HTMLElement).setAttribute("aria-grabbed", "false");
        (e.target as HTMLElement).blur()

    }


    //on blur
    function blurred(draggable: HTMLLIElement) {
        draggable.classList.remove("drag");
        draggable.setAttribute("aria-grabbed", "false")
        dragWrap.current?.setAttribute("aria-activedescendant", "")
        //setSelectedText(" none")

        getPosition(draggable)

        saveDraggables()
    }
    function focused(draggable: HTMLLIElement) {
        console.log("focus2")
        draggable.classList.add("drag");
        draggable.setAttribute("aria-grabbed", "true");
        dragUl0.current?.setAttribute("aria-activedescendant", `${draggable.id}`)
        draggable.addEventListener('keydown', keyDown);
        return () => {
            draggable.removeEventListener('keydown', keyDown);
            draggable.classList.remove("drag");
            draggable.setAttribute("aria-grabbed", "false")
            dragWrap.current?.setAttribute("aria-activedescendant", "")
            //setSelectedText(" none")

            getPosition(draggable)

            saveDraggables()
        }
    }

    //on blur
    // function blurblob(e: Event) {
    //     (e.target as HTMLElement).classList.remove("drag");
    //     (e.target as HTMLElement).setAttribute("aria-grabbed", "false")
    //     dragWrap.current?.setAttribute("aria-activedescendant", "")
    //     //setSelectedText(" none")

    //     getPosition((e.target as HTMLElement))

    //     saveDraggables()
    // }


    //During focus
    // function focusedBlob(draggable) {

    //     console.log("focused")

    //     console.log(draggable.id);


    //     let value = draggable.style.getPropertyValue("--i");
    //     let scale = parseFloat(value);

    //     draggable.addEventListener('wheel', zoom, { passive: false });
    //     draggable.addEventListener('keydown', keyDown);

    //     draggable.classList.add("drag");
    //     draggable.setAttribute("aria-grabbed", "true");
    //     //dragWrap.current.setAttribute("aria-expanded", "true");
    //     dragUl0.current?.setAttribute("aria-activedescendant", `${draggable.id}`)
    //     //setSelectedText(`${draggable.innerText}`)

    //     zIndex += 1;
    //     draggable.style.setProperty("z-index", `${zIndex}`)
    //     return () => {
    //         draggable.removeEventListener('wheel', zoom);
    //         draggable.removeEventListener('keydown', keyDown);
    //     }


    // }

    function zoom(e: WheelEvent) {
        e.preventDefault();
        let value = (e.target as HTMLElement).style.getPropertyValue("--i");
        let scale = parseFloat(value)

        scale += e.deltaY * -0.005;
        // Restrict scale
        scale = Math.min(Math.max(2, scale), 14);
        // Apply
        (e.target as HTMLElement).style.setProperty('--i', `${scale}`)

        zIndex += 1;
    }
    function wheel(draggable: HTMLLIElement) {
        draggable.addEventListener('wheel', zoom, { passive: false });
        return () => {
            draggable.removeEventListener('wheel', zoom);
        }
    }

    // let blobColor = (e.target as HTMLElement).style.background;

    const movePx = 8;

    function keyDown(e: KeyboardEvent) {

        console.log("Keydown")

        let value = (e.target as HTMLElement).style.getPropertyValue("--i");
        let scale = parseFloat(value)

        let attrLeft = window.getComputedStyle(e.target as HTMLElement).getPropertyValue("left");
        let attrTop = window.getComputedStyle(e.target as HTMLElement).getPropertyValue("top");

        switch (e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                (e.target as HTMLElement).style.left = parseFloat(attrLeft) - Number(movePx) + "px";
                attrLeft = window.getComputedStyle(e.target as HTMLElement).getPropertyValue("left");
                break;
            case 'ArrowRight':
                e.preventDefault();
                (e.target as HTMLElement).style.left = parseFloat(attrLeft) + Number(movePx) + "px";
                attrLeft = window.getComputedStyle(e.target as HTMLElement).getPropertyValue("left");
                break;
            case 'ArrowUp':
                e.preventDefault();
                (e.target as HTMLElement).style.top = parseFloat(attrTop) - Number(movePx) + "px";
                attrTop = window.getComputedStyle(e.target as HTMLElement).getPropertyValue("top");
                break;
            case 'ArrowDown':
                e.preventDefault();
                (e.target as HTMLElement).style.top = parseFloat(attrTop) + Number(movePx) + "px";
                attrTop = window.getComputedStyle(e.target as HTMLElement).getPropertyValue("top");
                break;
            case 'Escape':
                e.stopImmediatePropagation()
                e.preventDefault();
                if (exitBlob.current) exitBlob.current.setAttribute("tabindex", "0");
                (e.target as HTMLElement).blur()
                dragWrap.current?.blur()
                //Go to exit notice in order to remove focus from the app
                if (exitBlob.current) exitBlob.current.innerText = "Thank you for playing"
                exitBlob.current?.focus()
                break;
            case 'Enter': //Cycle through colors
                e.stopImmediatePropagation()
                if ((e.target as HTMLElement).closest(".drag-container0")) {
                    if (color1 == "lightsalmon" && color2 == "lemonchiffon") {
                        color1 = "lemonchiffon";
                        color2 = "greenyellow";
                        (e.target as HTMLElement).style.backgroundImage = `linear-gradient(${angle}, ${color1},${color2})`;
                        (e.target as HTMLElement).removeAttribute('class');
                        (e.target as HTMLElement).classList.add("dragzone", "color-yellowlime");
                    } else if (color1 == "lemonchiffon" && color2 == "greenyellow") {
                        color1 = "cyan";
                        color2 = "yellow";
                        (e.target as HTMLElement).style.backgroundImage = `linear-gradient(${angle}, ${color1},${color2})`;
                        (e.target as HTMLElement).removeAttribute('class'); (e.target as HTMLElement).classList.add("dragzone", "color-cyanyellow");
                    } else if (color1 == "cyan" && color2 == "yellow") {
                        color1 = "cyan";
                        color2 = "lightsalmon";
                        (e.target as HTMLElement).style.background = `linear-gradient(${angle}, ${color1},${color2})`;
                        (e.target as HTMLElement).removeAttribute('class'); (e.target as HTMLElement).classList.add("dragzone", "color-cyanpink");
                    } else if (color1 == "cyan" && color2 == "lightsalmon") {
                        color1 = "lightsalmon";
                        color2 = "lemonchiffon";
                        (e.target as HTMLElement).style.background = `linear-gradient(${angle}, ${color1},${color2})`;
                        (e.target as HTMLElement).removeAttribute('class'); (e.target as HTMLElement).classList.add("dragzone", "color-pinkyellow");
                    } else {
                        color1 = "lemonchiffon";
                        color2 = "greenyellow";
                        (e.target as HTMLElement).style.backgroundImage = `linear-gradient(${angle}, ${color1},${color2})`;
                        (e.target as HTMLElement).removeAttribute('class'); (e.target as HTMLElement).classList.add("dragzone", "color-yellowlime");
                    }
                }
                e.preventDefault();
                break;
            case '0': //Move blob to the bottom of the z-index pile
                e.stopImmediatePropagation()
                e.preventDefault();
                if (reset) {
                    reset = false;
                    (e.target as HTMLElement).style.setProperty("z-index", `${zIndex0}`)
                    zIndex0 -= 1;
                    const cooldown = () => { reset = true }
                    setTimeout(cooldown, 100);
                }
                break;
            case '1': //make blob smaller
                e.stopImmediatePropagation()
                e.preventDefault();
                if (reset) {
                    reset = false;
                    scale -= 1;
                    scale = Math.min(Math.max(2, scale), 14);
                    (e.target as HTMLElement).style.setProperty('--i', `${scale}`)

                    const cooldown = () => { reset = true }
                    setTimeout(cooldown, 100);
                }
                break;
            case '2': //make blob larger
                e.stopImmediatePropagation()
                e.preventDefault();
                if (reset) {
                    reset = false;
                    scale += 1;
                    scale = Math.min(Math.max(2, scale), 14);
                    (e.target as HTMLElement).style.setProperty('--i', `${scale}`)

                    const cooldown = () => { reset = true }
                    setTimeout(cooldown, 100);
                }
                break
            case '3': //make a new clone
            case '+':
                e.stopImmediatePropagation()
                e.preventDefault();
                makeBlob((e.target as HTMLElement))
                break
            case 'Delete': //remove blob
            case '-':
                e.stopImmediatePropagation()
                e.preventDefault();
                hideBlob((e.target as HTMLElement))
                break;
        }
    }

    //Clone blob
    function makeBlob(target: HTMLElement) { //TODO 
        if (reset) {

            blobCount++
            reset = false

            const clone = target.cloneNode(false);

            console.log(blobCount);
            (clone as HTMLElement).removeAttribute("id");
            (clone as HTMLElement).setAttribute("id", `blob${blobCount}-${d}`);
            (clone as HTMLElement).setAttribute("role", "option");
            let cloneSpan = document.createElement("span");
            cloneSpan.innerText = `blob ${blobCount}`;
            clone.appendChild(cloneSpan);

            zIndex += 1;
            (clone as HTMLElement).style.setProperty("z-index", `${zIndex}`);

            target.blur();

            dragUl0.current?.append(clone);

            // (clone as HTMLElement).onmouseenter = e => {
            //     setup(e.target)
            // }

            (clone as HTMLElement).onmousedown = e => {
                start(e);
                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: ${(e.target as HTMLElement)?.querySelector("span")?.textContent}`;
            }
            (clone as HTMLElement).onmousemove = e => {
                movement(e)
            }
            (clone as HTMLElement).onmouseup = e => {
                stopMovement(e);
                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: none`;
            }
            (clone as HTMLElement).ontouchstart = e => {
                start(e);
                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: ${(e.target as HTMLElement)?.querySelector("span")?.textContent}`;
            }
            (clone as HTMLElement).ontouchmove = e => {
                movement(e)
            }
            (clone as HTMLElement).ontouchend = e => {
                stopMovement(e);
                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: none`;
            }
            (clone as HTMLElement).onwheel = e => {
                wheel(e.target as HTMLLIElement)
            }
            (clone as HTMLElement).onfocus = e => {
                focused(e.target as HTMLLIElement);
                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: ${(e.target as HTMLElement)?.querySelector("span")?.textContent}`;
            }
            (clone as HTMLElement).onblur = e => {
                blurred(e.target as HTMLLIElement);
                if (selectedvalue0.current) selectedvalue0.current.textContent = `Selected blob: none`;
            }

            (clone as HTMLElement).focus();
            const cooldown = () => { reset = true }
            setTimeout(cooldown, 100);
        }
    }


    // function setup(draggable: HTMLElement) {

    //     //Add event listeners
    //     draggable.addEventListener(events[deviceType as keyof typeof events].down, start);
    //     draggable.addEventListener(events[deviceType as keyof typeof events].move, movement);
    //     draggable.addEventListener(events[deviceType as keyof typeof events].up, stopMovement);
    //     draggable.addEventListener("mouseleave", stopMovement);
    //     draggable.addEventListener('blur', blurblob)
    //     draggable.addEventListener('focus', focusedBlob(draggable))

    //     return () => {
    //         draggable.removeEventListener(events[deviceType as keyof typeof events].down, start);
    //         draggable.removeEventListener(events[deviceType as keyof typeof events].move, movement);
    //         draggable.removeEventListener(events[deviceType as keyof typeof events].up, stopMovement);
    //         draggable.removeEventListener("mouseleave", stopMovement);
    //         draggable.removeEventListener('blur', blurblob)
    //         draggable.removeEventListener('focus', focusedBlob)
    //     }
    // }
    // function setuppppppp(e: Event) {

    //     //Add event listeners
    //     (e.target as HTMLElement).addEventListener(events[deviceType as keyof typeof events].down, start);
    //     (e.target as HTMLElement).addEventListener(events[deviceType as keyof typeof events].move, movement);
    //     (e.target as HTMLElement).addEventListener(events[deviceType as keyof typeof events].up, stopMovement);
    //     (e.target as HTMLElement).addEventListener("mouseleave", stopMovement);
    //     (e.target as HTMLElement).addEventListener('blur', blurblob);
    //     //(e.target as HTMLElement).addEventListener('focus', focusedBlob)
    //     (e.target as HTMLElement).addEventListener('focus', focusedBlob((e.target as HTMLElement)));

    //     return () => {
    //         (e.target as HTMLElement).removeEventListener(events[deviceType as keyof typeof events].down, start);
    //         (e.target as HTMLElement).removeEventListener(events[deviceType as keyof typeof events].move, movement);
    //         (e.target as HTMLElement).removeEventListener(events[deviceType as keyof typeof events].up, stopMovement);
    //         (e.target as HTMLElement).removeEventListener("mouseleave", stopMovement);
    //         (e.target as HTMLElement).removeEventListener('blur', blurblob);
    //         (e.target as HTMLElement).removeEventListener('focus', focusedBlob);
    //     }
    // }






    //Remove blob
    function hideBlob(target: HTMLElement) {
        if (reset) {
            reset = false;
            //(e.target as HTMLElement).remove()//caused placement errors in other blobs
            target.style.display = "none"
            const cooldown = () => { reset = true }
            setTimeout(cooldown, 100);
        }
    }



    //console.dir(dragItemState)

    //Remove exit notice's tabindex as unnecessary after leaving it
    // exitBlob.current.addEventListener('blur', () => {
    //     exitBlob.current.removeAttribute("tabindex")
    // });

    //Check to see if elements overlap
    function elementsOverlap(element1: HTMLElement, element2: HTMLElement) {
        const domRect1 = element1.getBoundingClientRect();
        const domRect2 = element2.getBoundingClientRect();

        return !(
            (domRect1.top + 5) > (domRect2.bottom - 5) ||
            domRect1.right < domRect2.left ||
            (domRect1.bottom - 5) < (domRect2.top + 5) ||
            domRect1.left > domRect2.right
        );
    }



    return (
        <>

            <section id="drag-container0" className="drag-container drag-container0">
                <label htmlFor="listbox0" id="blobdescription0">Try dragging the blobs</label>
                <button ref={resetBlobs}
                    id="reset-blobs0"
                    className="reset-blobs"
                    onClick={(e => { resetBlobsFunction(e) })}
                >Reset Blobs</button>
                <div ref={selectedvalue0}
                    id="selectedvalue0" className="selectedvalue">
                    Selected blob: {selectedText}
                </div>
                <div
                    ref={dragWrapOuter}
                    className="drag-wrap-outer"
                    style={{ ...dragWrapOuterLightness, ...dragWrapOuterSaturation, ...dragWrapOuterHue }}>
                    <div
                        ref={dragWrap}
                        className="drag-wrap"
                    >
                        <ul ref={dragUl0}
                            role="listbox"
                            id="listbox0"
                            aria-labelledby="blobdescription0"
                            aria-activedescendant=""
                        >

                            <DragComponent items={dragItemState} />
                        </ul>
                    </div>
                    <div ref={colorBlockYellowLime0}
                        className="colorblock color-yellowlime"
                        id="color-yellowlime0"
                    ></div>
                    <div ref={colorBlockCyanYellow0}
                        className="colorblock color-cyanyellow"
                        id="color-cyanyellow0"
                    ></div>
                    <div ref={colorBlockCyanPink0}
                        className="colorblock color-cyanpink"
                        id="color-cyanpink0"
                    ></div>
                    <div ref={colorBlockPinkYellow0}
                        className="colorblock color-pinkyellow"
                        id="color-pinkyellow0"
                    ></div>
                    <div ref={makeLarger0}
                        className="make-larger" id="make-larger0"
                    >L
                    </div>
                    <div ref={makeSmaller0}
                        className="make-smaller"
                        id="make-smaller0"
                    >S
                    </div>
                    <div ref={makeMore0}
                        className="make-more" id="make-more0">+</div>
                    <div ref={deleteBlob0}
                        className="delete-blob" id="delete-blob0">-</div>
                </div>
                <div className="drag-slider-wrap">
                    <label htmlFor={"drag-slider-lightness0"} id="lightnessdescription0"
                    >Adjust background lightness</label>
                    {/* <RangeSlider {...setSlider1}
                        className="drag-slider drag-slider-lightness"
                        id="drag-slider-lightness0" /> */}
                    <input ref={sliderLightnessInput}
                        onChange={e => {
                            setSlider1Val(e.target.value)
                            sliderLightness()
                        }}
                        onMouseUp={e => {
                            setSlider1Val((e.target as HTMLInputElement).value)
                            sliderLightness()
                        }}
                        type="range"
                        min={0}
                        max={100}
                        defaultValue={slider1Val}
                        className="drag-slider drag-slider-lightness"
                        id="drag-slider-lightness0"
                    />
                    <button onClick={() => {
                        setSlider1Val(defaultLightness)
                        sliderLightnessReset()
                    }}>Reset Lightness</button>
                </div>
                <div className="drag-slider-wrap">
                    <label htmlFor="drag-slider-saturation0" id="saturationdescription0"
                    >Adjust background saturation</label >
                    {/* <RangeSlider {...setSlider2}
                        className="drag-slider drag-slider-saturation"
                        id="drag-slider-saturation0" /> */}
                    <input ref={sliderSaturationInput}
                        onChange={e => {
                            setSlider2Val(e.target.value)
                            sliderSaturation()
                        }}
                        onMouseUp={e => {
                            setSlider2Val((e.target as HTMLInputElement).value)
                            sliderSaturation()
                        }}
                        type="range"
                        min={0}
                        max="100"
                        defaultValue={slider2Val}
                        className="drag-slider drag-slider-saturation"
                        id="drag-slider-saturation0"
                    />
                    <button onClick={() => {
                        setSlider2Val(defaultSaturation)
                        sliderSaturationReset()
                    }}>Reset Saturation</button>
                </div>
                <div className="drag-slider-wrap">
                    <label htmlFor="drag-slider-hue0" id="huedescription0"
                    >Adjust background hue</label >
                    {/* <RangeSlider {...setSlider3}
                        className="drag-slider drag-slider-hue"
                        id="drag-slider-hue0" /> */}
                    <input ref={sliderHueInput}
                        onChange={e => {
                            setSlider3Val(e.target.value)
                            sliderHue()
                        }}
                        onMouseUp={e => {
                            setSlider3Val((e.target as HTMLInputElement).value)
                            sliderHue()
                        }}
                        type="range"
                        min={0}
                        max="359"
                        defaultValue={slider3Val}
                        className="drag-slider drag-slider-hue"
                        id="drag-slider-hue0"
                    />
                    <button onClick={() => {
                        setSlider3Val(defaultHue)
                        sliderHueReset()
                    }}>Reset Hue</button>
                </div>
                <div ref={exitBlob}
                    id="exitblob0" className="exitblob" role="dialog"></div>
            </section>


            <svg className="filter">
                <filter id="svgfilter">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="10"></feGaussianBlur>
                    <feColorMatrix values="
1 0 0 0 0 
0 1 0 0 0 
0 0 1 0 0
0 0 0 20 -10 
">

                    </feColorMatrix>
                </filter>
            </svg>

        </>
    )
}
