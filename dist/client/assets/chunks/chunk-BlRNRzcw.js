var e=Object.defineProperty,t=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable,r=(t,n,o)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[n]=o,c=(e,c)=>{for(var l in c||(c={}))n.call(c,l)&&r(e,l,c[l]);if(t)for(var l of t(c))o.call(c,l)&&r(e,l,c[l]);return e};var l=e=>Array.isArray(e)?e:[e];function u(e){const t=Array.isArray(e[0])?e[0]:e;return function(e,t="expected all items to be functions, instead received the following types: "){if(!e.every(e=>"function"==typeof e)){const n=e.map(e=>"function"==typeof e?`function ${e.name||"unnamed"}()`:typeof e).join(", ");throw new TypeError(`${t}[${n}]`)}}(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}var i="undefined"!=typeof WeakRef?WeakRef:class{constructor(e){this.value=e}deref(){return this.value}};function s(){return{s:0,v:void 0,o:null,p:null}}function p(e,t={}){let n={s:0,v:void 0,o:null,p:null};const{resultEqualityCheck:o}=t;let r,c=0;function l(){var t,l;let u=n;const{length:p}=arguments;for(let e=0,n=p;e<n;e++){const t=arguments[e];if("function"==typeof t||"object"==typeof t&&null!==t){let e=u.o;null===e&&(u.o=e=new WeakMap);const n=e.get(t);void 0===n?(u=s(),e.set(t,u)):u=n}else{let e=u.p;null===e&&(u.p=e=new Map);const n=e.get(t);void 0===n?(u=s(),e.set(t,u)):u=n}}const a=u;let f;if(1===u.s)f=u.v;else if(f=e.apply(null,arguments),c++,o){const e=null!=(l=null==(t=null==r?void 0:r.deref)?void 0:t.call(r))?l:r;null!=e&&o(e,f)&&(f=e,0!==c&&c--);r="object"==typeof f&&null!==f||"function"==typeof f?new i(f):f}return a.s=1,a.v=f,f}return l.clearCache=()=>{n={s:0,v:void 0,o:null,p:null},l.resetResultsCount()},l.resultsCount=()=>c,l.resetResultsCount=()=>{c=0},l}function a(e,...t){const n="function"==typeof e?{memoize:e,memoizeOptions:t}:e,o=(...e)=>{let t,o=0,r=0,i={},s=e.pop();"object"==typeof s&&(i=s,s=e.pop()),function(e,t="expected a function, instead received "+typeof e){if("function"!=typeof e)throw new TypeError(t)}(s,`createSelector expects an output function after the inputs, but received: [${typeof s}]`);const a=c(c({},n),i),{memoize:f,memoizeOptions:y=[],argsMemoize:d=p,argsMemoizeOptions:v=[]}=a,m=l(y),b=l(v),h=u(e),w=f(function(){return o++,s.apply(null,arguments)},...m),g=d(function(){r++;const e=function(e,t){const n=[],{length:o}=e;for(let r=0;r<o;r++)n.push(e[r].apply(null,t));return n}(h,arguments);return t=w.apply(null,e),t},...b);return Object.assign(g,{resultFunc:s,memoizedResultFunc:w,dependencies:h,dependencyRecomputations:()=>r,resetDependencyRecomputations:()=>{r=0},lastResult:()=>t,recomputations:()=>o,resetRecomputations:()=>{o=0},memoize:f,argsMemoize:d})};return Object.assign(o,{withTypes:()=>o}),o}var f=a(p),y=Object.assign((e,t=f)=>{!function(e,t="expected an object, instead received "+typeof e){if("object"!=typeof e)throw new TypeError(t)}(e,"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a "+typeof e);const n=Object.keys(e);return t(n.map(t=>e[t]),(...e)=>e.reduce((e,t,o)=>(e[n[o]]=t,e),{}))},{withTypes:()=>y});
//# sourceMappingURL=chunk-BlRNRzcw.js.map
