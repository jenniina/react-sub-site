{"version":3,"file":"chunk-VF2LHfxc.js","sources":["../../../../node_modules/@brillout/picocolors/dist/esm/picocolors.browser.js","../../../../node_modules/@brillout/json-serializer/dist/types.js","../../../../node_modules/@brillout/json-serializer/dist/parse.js"],"sourcesContent":["export default new Proxy({}, {\n    get: (_, p) => (s) => {\n        if (p === 'code')\n            return `\\`${s}\\``;\n        if (p === 'string')\n            return `'${s}'`;\n        return s;\n    }\n});\n","export { types };\nconst types = [\n    ts({\n        is: (val) => val === undefined,\n        match: (str) => str === '!undefined',\n        serialize: () => '!undefined',\n        deserialize: () => undefined,\n    }),\n    ts({\n        is: (val) => val === Infinity,\n        match: (str) => str === '!Infinity',\n        serialize: () => '!Infinity',\n        deserialize: () => Infinity,\n    }),\n    ts({\n        is: (val) => val === -Infinity,\n        match: (str) => str === '!-Infinity',\n        serialize: () => '!-Infinity',\n        deserialize: () => -Infinity,\n    }),\n    ts({\n        is: (val) => typeof val === 'number' && isNaN(val),\n        match: (str) => str === '!NaN',\n        serialize: () => '!NaN',\n        deserialize: () => NaN,\n    }),\n    ts({\n        is: (val) => val instanceof Date,\n        match: (str) => str.startsWith('!Date:'),\n        serialize: (val) => '!Date:' + val.toISOString(),\n        deserialize: (str) => new Date(str.slice('!Date:'.length)),\n    }),\n    ts({\n        is: (val) => typeof val === 'bigint',\n        match: (str) => str.startsWith('!BigInt:'),\n        serialize: (val) => '!BigInt:' + val.toString(),\n        deserialize: (str) => {\n            if (typeof BigInt === 'undefined') {\n                throw new Error('Your JavaScript environement does not support BigInt. Consider adding a polyfill.');\n            }\n            return BigInt(str.slice('!BigInt:'.length));\n        },\n    }),\n    ts({\n        is: (val) => val instanceof RegExp,\n        match: (str) => str.startsWith('!RegExp:'),\n        serialize: (val) => '!RegExp:' + val.toString(),\n        deserialize: (str) => {\n            str = str.slice('!RegExp:'.length);\n            // const args: string[] = str.match(/\\/(.*?)\\/([gimy])?$/)!\n            const args = str.match(/\\/(.*)\\/(.*)?/);\n            const pattern = args[1];\n            const flags = args[2];\n            return new RegExp(pattern, flags);\n        },\n    }),\n    ts({\n        is: (val) => val instanceof Map,\n        match: (str) => str.startsWith('!Map:'),\n        serialize: (val, serializer) => '!Map:' + serializer(Array.from(val.entries())),\n        deserialize: (str, parser) => new Map(parser(str.slice('!Map:'.length))),\n    }),\n    ts({\n        is: (val) => val instanceof Set,\n        match: (str) => str.startsWith('!Set:'),\n        serialize: (val, serializer) => '!Set:' + serializer(Array.from(val.values())),\n        deserialize: (str, parser) => new Set(parser(str.slice('!Set:'.length))),\n    }),\n    // Avoid collisions with the special strings defined above\n    ts({\n        is: (val) => typeof val === 'string' && val.startsWith('!'),\n        match: (str) => str.startsWith('!'),\n        serialize: (val) => '!' + val,\n        deserialize: (str) => str.slice(1),\n    }),\n];\n// Type check\nfunction ts(t) {\n    return t;\n}\n","export { parse };\n// Used by Vike: https://github.com/vikejs/vike/blob/b4ba6b70e6bdc2e1f460c0d2e4c3faae5d0a733c/vike/shared/page-configs/serialize/parseConfigValuesSerialized.ts#L13\nexport { parseTransform };\nimport { types } from './types.js';\nfunction parse(str, options = {}) {\n    // We don't use the reviver option in `JSON.parse(str, reviver)` because it doesn't support `undefined` values\n    const value = JSON.parse(str);\n    return parseTransform(value, options);\n}\nfunction parseTransform(value, options = {}) {\n    if (typeof value === 'string') {\n        return reviver(value, options);\n    }\n    if (\n    // Also matches arrays\n    typeof value === 'object' &&\n        value !== null) {\n        Object.entries(value).forEach(([key, val]) => {\n            ;\n            value[key] = parseTransform(val, options);\n        });\n    }\n    return value;\n}\nfunction reviver(value, options) {\n    const parser = (str) => parse(str, options);\n    {\n        const res = options.reviver?.(\n        // TO-DO/eventually: provide key if some user needs it\n        undefined, value, parser);\n        if (res) {\n            if (typeof res.replacement !== 'string') {\n                return res.replacement;\n            }\n            else {\n                value = res.replacement;\n                if (res.resolved)\n                    return value;\n            }\n        }\n    }\n    for (const { match, deserialize } of types) {\n        if (match(value)) {\n            return deserialize(value, parser);\n        }\n    }\n    return value;\n}\n"],"names":["pc","Proxy","get","_","p","s","types","is","val","match","str","serialize","deserialize","Infinity","isNaN","NaN","Date","startsWith","toISOString","slice","toString","BigInt","Error","RegExp","args","pattern","flags","Map","serializer","Array","from","entries","parser","Set","values","parse","options","parseTransform","JSON","value","_a","res","reviver","call","replacement","resolved","Object","forEach","key"],"mappings":"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","x_google_ignoreList":[0,1,2]}