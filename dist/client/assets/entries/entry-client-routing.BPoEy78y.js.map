{"version":3,"mappings":";o0BAAO,SAASA,EAAOC,GACnB,OAAOC,MAAMC,KAAK,IAAIC,IAAIH,GAC9B,CCIA,SAASI,EAAgBC,EAAUC,SAC/B,MAAMC,EAIV,eACQC,EAGJ,OAFA,MAAAC,WAAWC,QAAUD,WAAWC,MAAQ,IACvC,SAAKD,WAAWC,OAAOH,UAAYC,EAAGD,QAAU,IAC1CE,WAAWC,MAAMH,OAC5B,CAToBI,GAEhB,OADsB,OAAAH,EAAAD,EAAQF,IAARG,EAAsBD,EAAQF,GAAYC,CAEpE,CCTO,MAAMM,EAAkB,UCY/B,IAAIC,EAGJ,SAASC,IACL,SAAuB,gCAAiC,CACpDC,UAAW,GACXC,kBAAmBb,KAE3B,CAEA,SAASc,IAEL,OADAJ,UAAiBA,EAAeC,KACzBD,CACX,CAXAA,UAAiBA,EAAeC,KAYhC,MACMI,EAA0B,yEAChC,SAASC,IACL,MAAMN,EAAeI,IACrB,CACI,MAAMG,EAAWrB,EAAOc,EAAaE,WACrCM,EAAcD,EAASE,QAAU,EAGjC,QAAQC,EAAGC,KAAKJ,EAAS,gBAAgBG,EAAGC,KAAKJ,EAAS,+CAA+CG,EAAGE,UAAU,+CAAgD,CAAEC,UAAU,EAAMC,gBAAgB,GAC5M,CACId,EAAae,qBAAuBf,EAAaE,UAAUO,OAAS,GAIpED,GAAc,EAAOH,EAAyB,CAAEQ,UAAU,EAAMC,gBAAgB,GAGxF,CAqCA,SAASN,EAAcQ,EAAWC,GAAcJ,SAAEA,EAAAC,eAAUA,IACxD,MAAMd,EAAeI,IACrB,GAAIY,EACA,OAEJ,MAAME,EAAM,mBAAmBD,IACjB,CACV,MAAMd,cAAEA,GAAkBH,EACpBmB,EAA0BD,EAChC,GAAIf,EAAciB,IAAID,GAClB,OAGAhB,EAAckB,IAAIF,EAE1B,CACIL,EACAQ,QAAQC,KAAK,IAAIC,MAAMN,IAGvBI,QAAQC,KAAKL,EAErB,CCtGA,SAASO,EAA+BR,EAAcS,GAClD,MAAMC,EAAM,IAAIH,MAAMP,GAItB,MCNuB,oBAAZW,SAENA,QAAQC,KAGRD,QAAQrB,eAA6C,IAA1BqB,QAAQrB,SAASuB,OAG5CF,QAAQG,SAAoC,SAAzBH,QAAQG,QAAQC,QDJpCL,EAAIM,MAIZ,SAAeC,EAAUR,GACrB,IAAKQ,EACD,OAAOA,EAEX,MAAMC,GAoBWC,EApBcF,EAsBxBE,EAAIC,MAAM,UAFrB,IAAqBD,EAnBjB,IAAIE,EAAe,EACnB,MAAMC,EAAqBJ,EACtBK,OAAQC,IAELA,EAAKC,SAAS,iBAAkBD,EAAKC,SAAS,uBAG9CJ,EAAeZ,GAS3B,SAA0Be,GACtB,OAAOA,EAAKE,WAAW,UAC3B,CAX8DC,CAAiBH,MACnEH,KACO,KAIVO,KAAK,MACV,OAAON,CACX,CAxBoBO,CAAMnB,EAAIM,MAAOP,IAE1BC,CACX,CERO,SAASoB,EAASC,GACrB,MAAwB,iBAAVA,GAAgC,OAAVA,CACxC,CCcA,MAAMhD,IAA+B,kBAAmB,CACpDG,kBAAmBb,IAEnB,MAAA2D,CAAO/B,EAAKgC,GACQ,SAAZA,EACA5B,QAAQ6B,IAAIjC,GAGZI,QAAQC,KAAKL,EAErB,EACAkC,uBAAwBC,UJmDHjD,IACRF,UAAUoD,KAAKvD,GAC5BO,IIlDJ,MACMiD,EAAwB,SAASxD,KA4BvC,SAASyD,EAAYxC,EAAWyC,GAAQ3C,eAAEA,cAAgB4C,GAAgB,UACtE,GAAI1C,EACA,OACJF,EAAiBA,GAAkBd,EAAa2D,qBAIhD,MAAMC,EAAanC,EADnBgC,EAASI,EADTJ,EAASK,EADTL,EAASM,EAAcN,GACc,gBA/BD,GAsCpC,GAJI3C,GACAd,EAAaoD,mBAAmB/B,IAAIuC,GAExC5D,WAAagE,cAAbhE,WACK0D,EACD,MAAME,EAGNtC,QAAQ2C,MAAMnD,EAAiB8C,EAAaH,GAC5C7B,QAAQsC,KAAK,EAErB,CACA,SAASC,EAAgBV,GAKrB,OADqBhC,EADrBgC,EAASI,EADTJ,EAASK,EADTL,EAASM,EAAcN,GACc,UAhDD,EAoDxC,CACA,SAASjD,EAAcQ,EAAWE,GAAKL,SAAEA,EAAAC,eAAUA,UAC/C,IAAIE,EAAJ,CAMA,GAJAF,EAAiBA,GAAkBd,EAAa2D,qBAGhDzC,EAAM2C,EADN3C,EAAM4C,EADN5C,EAAM6C,EAAc7C,GACW,YAE3BL,EAAU,CACV,MAAMV,cAAEA,GAAkBH,EACpBmB,GAAmB,IAAbN,EAAoBK,EAAML,EACtC,GAAIV,EAAciB,IAAID,GAClB,OACJhB,EAAckB,IAAIF,EACtB,CAEA,GADAnB,WAAagE,cAAbhE,UACIc,EAAgB,CAChB,MAAMa,EAAMF,EAA+BP,EArEX,GAsEhClB,EAAaoD,mBAAmB/B,IAAIM,GACpC3B,EAAaiD,OAAOtB,EAAK,OAC7B,MAEI3B,EAAaiD,OAAO/B,EAAK,OAnBzB,CAqBR,CAuBA,SAAS4C,EAAoB5C,EAAKkD,GAC9B,IAAIC,EAAS,IAAID,KACjB,MAAME,EAAgB,YAARF,EAAoB,SAAW,MAE7C,OADAC,EAAS3D,EAAGC,KAAKD,EAAG4D,GAAOD,IACpB,GAAGA,IAASnD,GACvB,CACA,SAAS6C,EAAc7C,GACnB,OAAIA,EAAIyB,WAAW,KACRzB,EAGA,IAAIA,GAEnB,CACA,SAAS2C,EAAqB3C,EAAKqD,GAAqB,GAEpD,MAAO,GADQA,EAAqBhB,EArHrB,WAsHIrC,GACvB,CCrJO,SAASsD,IAEZ,MAAyB,oBAAXC,QAAoD,iBAAnBA,OAAOC,OAE1D,CCGA,MAAMC,EAAQpF,EAAgB,4BAA6B,IAC3D,SAASqF,IAWT,IAA+BC,KANM,IAA1BF,EAAMG,gBAQbtB,EAAYgB,IAAa,GAAG9D,EAAGqE,KAAK,oFAAqF,CAAEjE,gBAAgB,IAC3IN,EAAcqE,EAAiB,8RAA+R,CAAE/D,gBAAgB,EAAMD,UAAU,IAZhW8D,EAAMG,iBAAkB,CAC5B,CCXO,SAASE,EAAWC,GACvB,OAAOA,aAAiBC,UAA6B,mBAAVD,CAC/C,CCDO,SAASE,EAAQnC,GACpB,OAAO5D,MAAM+F,QAAQnC,EACzB,CCGA,SAASoC,EAAQC,EAAKC,EAAMC,GACxB,IAAKxC,EAASsC,GACV,OAAO,EACX,KAAMC,KAAQD,GACV,MAAgB,cAATE,EAEX,QAAa,IAATA,EACA,OAAO,EAEX,MAAMC,EAAYH,EAAIC,GACtB,MAAa,cAATC,OACqB,IAAdC,EAEE,UAATD,EACOJ,EAAQK,GAEN,WAATD,EACOxC,EAASyC,GAEP,aAATD,ECtBGJ,EADeM,EDwBMD,ICvBLC,EAAIC,MAAOC,GAAmB,iBAANA,GDyBlC,aAATJ,EE1BR,SAA2BE,GACvB,OAAO1C,EAAS0C,IAAQG,OAAOC,OAAOJ,GAAKC,MAAOC,GAAmB,iBAANA,EACnE,CFyBeG,CAAkBN,GAEhB,aAATD,EACOP,EAAWQ,GAElBL,EAAQI,GACoB,iBAAdC,GAA0BD,EAAK7C,SAAS8C,GAE7C,SAATD,EACqB,OAAdC,EAEE,SAATD,GACqB,IAAdC,EAEE,UAATD,GACqB,IAAdC,SAEGA,IAAcD,EC5ChC,IAA0BE,CD6C1B,CG/CO,SAASM,EAAc/C,GAE1B,MAAqB,iBAAVA,GAAgC,OAAVA,IAII,OAAjC4C,OAAOI,eAAehD,IAQC,WAA3BA,EAAMiD,YAAYjE,KACtB,CCVA,SAASkE,EAAab,EAAKc,EAAaC,GAC/BD,IAEAC,GACOD,EAAYE,kBACxBT,OAAOU,iBAAiBjB,EAAKO,OAAOW,0BAA0BJ,IAClE,CCTA,SAASK,EAAMvB,EAAO5F,EAAMoH,GACxB,MAAqB,iBAAVxB,EACAyB,EAAWzB,EAAM5C,MAAM,IAAKhD,EAAMoH,GAAI5D,KAAK,IAG3C6D,EAAWzB,EAAO5F,EAAMoH,EAEvC,CACA,SAASC,EAAWC,EAAMtH,EAAMoH,GAC5B,MAAMG,EAAY,GAClB,IAAIC,EAAQxH,GAAQ,EAAIA,EAAOsH,EAAKlG,OAASpB,EACtCwH,GAAS,GAAcF,EAAKlG,OACnC,IAAIqG,EAAML,GAAM,EAAIA,EAAKE,EAAKlG,OAASgG,EAEvC,IADOK,GAAO,GAAYH,EAAKlG,OAEvBoG,IAAUC,IAGVD,IAAUF,EAAKlG,SACfoG,EAAQ,GAERA,IAAUC,IAPL,CAUT,MAAMC,EAAKJ,EAAKE,GAEhBD,EAAUtD,KAAKyD,GACfF,GACJ,CACA,OAAOD,CACX,CCbA,SAASI,EAASC,EAAKC,GACZC,EAAMF,GACNC,EAAWvE,WAAW,KAE7B,MAAQyE,WAAYC,EAAcC,YAAaC,GAsDnD,SAAqBN,GACjB,MAAOK,KAAgBE,GAASP,EAAI5E,MAAM,KAE1C,MAAO,CAAE+E,WADU,CAAC,MAAOI,GAAO3E,KAAK,MAAQ,KAC1ByE,cACzB,CA1DsEG,CAAYR,GACtD,OAAjBI,GAAyBA,EAAa1E,WAAW,KACxD,MAAM+E,EAAwB,OAAjBL,EAAwB,GAAKM,EAAWN,EAAab,MAAM,KAEhEoB,aAAcC,EAAgBC,cAAeC,GAA4BC,EAAcT,GACrE,OAAnBM,GAA2BA,EAAelF,WAAW,KAC5D,IAAIiF,EAAe,GACnB,GAAuB,OAAnBC,EACAD,EAAeC,OACnB,GACSZ,EAAItE,WAAW,KAAM,CAC1B,MAAMsF,EAAUC,IAChBN,EAAgBK,GAAWD,EAAcC,GAASL,cAAiB,EACvE,CACA,MAAMO,EAAS,GACTC,EAAY,GAClBhJ,MAAMC,KAAK,IAAIgJ,gBAAgBT,IAAeU,QAAQ,EAAEnH,EAAKsE,MACzD0C,EAAOhH,GAAOsE,EACd2C,EAAUjH,GAAO,IAAKiH,EAAUG,eAAepH,GAAOiH,EAAUjH,GAAO,GAAKsE,KAGhF,IAAI+C,SAAEA,EAAAC,OAAUA,EAAAC,yBAAQA,GA8D5B,SAAqCzB,EAAKC,IAE9BD,EAAIvE,SAAS,MAASuE,EAAIvE,SAAS,KAE3C,CACI,MAAM8F,SAAEA,EAAAC,OAAUA,EAAAE,SAAQA,GAAaC,EAAY3B,GACnD,GAAIwB,EACA,MAAO,CAAED,WAAUC,SAAQC,yBAA0BC,EAG7D,CAEA,GAAI1B,EAAItE,WAAW,KACf,MAAO,CAAE6F,SAAU,KAAMC,OAAQ,KAAMC,yBAA0BzB,GAEhE,CAED,MAAMgB,EAAUC,IAChB,IAAIW,EAEAA,EADAZ,EACOW,EAAYX,EAAQ5F,MAAM,KAAK,GAAGA,MAAM,KAAK,IAAIsG,SAGjDzB,EAEX,MAAMwB,EAsEd,SAAoCI,EAAkBD,GAClD,MAAM5G,EAAQ4G,EAAKxG,MAAM,KACnBmF,EAAQsB,EAAiBzG,MAAM,KACrC,IAAI0G,EAA2BF,EAAKG,SAAS,KACzCF,EAAiBnG,WAAW,MAE5BV,EAAMgH,MAEV,UAAWC,KAAK1B,EAAO,CACnB,MAAM2B,EAAI3B,EAAM0B,GACP,IAALC,GAAiB,MAAND,GAEN,KAALC,IAEK,MAALA,EACAlH,EAAMgH,OAENF,GAA2B,EAC3B9G,EAAMqB,KAAK6F,IAEnB,CACA,IAAIC,EAAmBnH,EAAMY,KAAK,KAC9BkG,IAA6BK,EAAiBJ,SAAS,OACvDI,GAAoB,KACnBA,EAAiBzG,WAAW,OAC7ByG,EAAmB,IAAMA,GAC7B,OAAOA,CACX,CAjGyCC,CAA2BpC,EAAK4B,GACjE,MAAO,CAAEL,SAAU,KAAMC,OAAQ,KAAMC,2BAC3C,CACJ,CA1FyDY,CAA4BvB,EAAyBb,GAC1G,MAAMqC,EAAmBxB,EAAwBvB,OAAOiC,GAAU,IAAIhI,QAGtE,IAAIkI,SAAEA,EAAAa,cAAUA,GAqLpB,SAA0Bd,EAA0BxB,GACzCwB,EAAyB/F,WAAW,KACpC8G,EAAavC,GAEpB,IAAIwC,EAAchB,EAGlB,GAFOgB,EAAY/G,WAAW,KACvBuE,EAAWvE,WAAW,KACV,MAAfuE,EAAoB,CAEpB,MAAO,CAAEyB,SADQD,EACEc,eAAe,EACtC,CAEA,IAAIG,EAAuBzC,EACvBA,EAAW8B,SAAS,MAAQU,IAAgBlD,EAAMU,EAAY,GAAG,KACjEyC,EAAuBnD,EAAMU,EAAY,GAAG,IAGhD,IAAKwC,EAAY/G,WAAWgH,GAAuB,CAE/C,MAAO,CAAEhB,SADQD,EACEc,eAAe,EACtC,CACOE,EAAY/G,WAAW,MAAQ+G,EAAY/G,WAAW,QACtD+G,EAAY/G,WAAWgH,GAC9BD,EAAcA,EAAYlD,MAAMmD,EAAqBlJ,QAChDiJ,EAAY/G,WAAW,OACxB+G,EAAc,IAAMA,GAExB,OADOA,EAAY/G,WAAW,KACvB,CAAEgG,SAAUe,EAAaF,eAAe,EACnD,CAjNsCI,CAAiBlB,EAA0BxB,GAE7E,MAAM2C,EAuNV,SAAiCpB,EAAQE,EAAUR,EAAQT,GACvD,MAAMoC,EAAe,GAAGrB,GAAU,KAAKE,IAAWR,GAAU,KAAKT,GAAQ,KACzE,OAAOoC,CACX,CA1NiBC,CAAwBtB,EAAQE,EAAUd,EAAgBR,GAEjE2C,EAAQvB,EAAgBA,EAAOjC,MAAMgC,EAAS/H,QAA7B,MACjBwJ,SAAEA,EAAAC,KAAUA,GAqGtB,SAAmBF,GACf,MAAMG,EAAM,CAAEF,SAAU,KAAMC,KAAM,MACpC,IAAKF,EACD,OAAOG,EAEX,MAAM3C,EAAQwC,EAAK3H,MAAM,KACzB,GAAImF,EAAM/G,OAAS,EAAG,CAClB,MAAMyJ,EAAOE,SAAS5C,EAAMyB,MAAO,IAEnCkB,EAAID,KAAOA,CACf,CAGA,OADAC,EAAIF,SAAWzC,EAAM3E,KAAK,KACnBsH,CACX,CAnH+BE,CAAUL,GAQrC,OANArB,EAA0BA,EA4CA2B,QAAQ,OAAQ,IAErCjI,MAAM,KACNkI,IAAKC,GAAQ7C,EAAW6C,GAAKnI,MAAM,KAAKQ,KAAK,QAC7CA,KAAK,KA3CH8F,EAAShG,WAAW,KACpB,CACHkH,OACArB,WACAyB,WACAC,OACAzB,SACAE,WACAY,mBACAC,gBACArB,SACAC,YACAP,iBACAH,OACAL,eAER,CAMA,SAASW,EAAcf,GACnB,MAAOa,KAAkBN,GAASP,EAAI5E,MAAM,KAE5C,MAAO,CAAEuF,aADY,CAAC,MAAOJ,GAAO3E,KAAK,MAAQ,KAC1BiF,gBAC3B,CACA,SAASH,EAAW8C,GAChB,IACI,OAAOC,mBAAmBD,EAC9B,OACME,GAAE,CACR,IACI,OAAOC,UAAUH,EACrB,OACME,GAAE,CACR,OAAOF,CACX,CAsCA,SAASvC,UAIL,MADkC,oBAAXzD,OAAyB,OAAA9E,EAAA,MAAA8E,YAAA,EAAAA,OAAQoG,mBAAU5C,aAAU,CAEhF,CACA,SAASW,EAAY3B,GACjB,GAAK6D,GAAqB7D,GAGrB,CACD,MAAMuB,SAAEA,EAAAuC,mBAAUA,GAAuBC,EAAc/D,IAEhD+C,KAASiB,GAAQF,EAAmB1I,MAAM,KAC3CoG,EAASD,EAAWwB,EAE1B,MAAO,CAAErB,SADQ,IAAMsC,EAAKpI,KAAK,KACd4F,SAAQD,WAC/B,CATI,MAAO,CAAEG,SAAU1B,EAAKwB,OAAQ,KAAMD,SAAU,KAUxD,CAgBA,SAASwC,EAAcE,GACnB,MACOC,KAAWC,GAASF,EAAI7I,MADnB,KAEZ,GAAqB,IAAjB+I,EAAM3K,SAIL,wBAAwB4K,KAAKF,GAC9B,MAAO,CAAE3C,SAAU,KAAMuC,mBAAoBG,GAEjD,IAAI1C,EAAW2C,EATH,IAURJ,EAAqBK,EAAMvI,KAVnB,KAWZ,MAAMyI,EAAO,KAKb,OAJIP,EAAmBpI,WAAW2I,KAC9B9C,GAAsB8C,EACtBP,EAAqBA,EAAmBvE,MAAM8E,IAE3C,CAAE9C,WAAUuC,qBACvB,CAuEA,SAAStB,EAAavC,GAClB,OAAOA,EAAWvE,WAAW,IACjC,CASA,SAASwE,EAAMF,GAEX,OAAOsE,EAActE,IAAQuE,EAAcvE,EAC/C,CAIA,SAASsE,EAActE,GACnB,OAEJ,SAA2BA,GACvB,OAAOA,EAAItE,WAAW,IAC1B,CAJW8I,CAAkBxE,IAAQ6D,GAAqB7D,EAC1D,CAIA,SAASuE,EAAcvE,GACnB,MAAO,CAAC,IAAK,IAAK,KAAKyE,KAAMC,GAAM1E,EAAItE,WAAWgJ,KAAe,KAAR1E,CAC7D,CAiBA,SAAS6D,GAAqB7D,GAC1B,MAAMuB,SAAEA,GAAawC,EAAc/D,GACnC,QAASuB,GAnHb,SAA0BA,GAQtB,OALkB,CAEd,UACA,WAEU9F,SAAS8F,IAEhBA,EAASQ,SAAS,MAC7B,CAwGyB4C,CAAiBpD,EAC1C,CAmBA,SAASqD,GAAuB5E,EAAK6E,GACjCtI,EAAY+H,EAActE,GAS9B,SAAmBA,EAAK6E,GACpB,IAAIrI,EAAS,GAAGqI,QAAgBpL,EAAGqL,OAAO9E,+BAAiCvG,EAAGqL,OAAO,OAKrF,OAHItI,GAAU,wBAAwB/C,EAAGqL,OAAO,cAGzCtI,CACX,CAhBoCuI,CAAU/E,EAAK6E,GACnD,CCrUO,SAASG,GAAahF,GACzBxC,OAAOyH,SAASrC,KAAO5C,CAC3B,CCFO,SAASkF,GAAMC,GAClB,OAAO,IAAIC,QAASC,GAAMC,WAAWD,EAAGF,GAC5C,CCAA,SAASI,GAAWC,GAChBhI,OAAOiI,iBAAiB,mBAAoB,KACP,WAA7B7B,SAAS8B,iBACTF,KAGZ,CCJA,SAASG,IAAaC,QAASC,EADD,IAC6C,IACvE,IAAIC,EACAC,EACAC,GAAW,EACf,MAAMC,EAAmB,IAAIb,QAAQ,CAACc,EAAUC,KAC5CL,EAAU,IAAIM,KACVJ,GAAW,EACXK,IACOH,KAAYE,IAEvBL,EAAS,IAAIK,KACTJ,GAAW,EACXK,IACOF,KAAWC,MAGpBC,EAAe,IAAMC,EAASjF,QAASkF,GAAMC,aAAaD,IAC1DD,EAAW,GACjB,IAAIG,EAmBJ,OAdIA,EAJCZ,EAIS,IAAIa,MAAMT,EAAkB,CAClC,GAAAU,CAAIC,EAAQvI,GACR,GAAa,SAATA,IAAoB2H,EAAU,CAC9B,MAAMtL,EAAM,IAAIH,MAAM,iCAAiCsL,aACvDS,EAASjK,KAAKiJ,WAAW,KACd5K,EAAIM,MACXzB,GAAc,EAUtC,SAAgC0B,GAC5B,MAAM4L,EAAc,UAChB5L,EAASS,WAAWmL,KACpB5L,EAAWA,EAASsE,MAAMsH,EAAYrN,SAC1C,OAAOyB,CACX,CAf6C6L,CAAuBpM,EAAIM,OAAQ,CAAEpB,UAAU,KACpD,IAAjBiM,GACP,CACA,MAAM9J,EAAQgL,QAAQJ,IAAIC,EAAQvI,GAClC,MAAwB,mBAAVtC,EAAuBA,EAAMiL,KAAKJ,GAAU7K,CAC9D,IAdMkK,EAiBP,CAAEQ,UAASX,UAASC,SAC/B,CCxCA,MAAMkB,GAAW,GACjB,SAASC,GAAkBC,EAAcC,EAAmB,IAAKC,EAAgB,SAE7E,MAAMC,MAAUC,KAChB,IAAIC,EAAW,OAAA9O,KAASyO,MAAkBF,GAASE,GAAgBM,GAAcH,GAE7DA,EAAII,UAAYF,EAAQ5H,MAAM8H,UAChB,IAAhBL,IACdG,EAAUP,GAASE,GAAgBM,GAAcH,IAErDE,EAAQG,QAER,MAAM1N,EAAM,6BAA6BuN,EAAQG,sBAAsBN,cAA0BF,KAC7FK,EAAQG,MAAQP,GAChB7K,GAAY,EAAOtC,IAGlBuN,EAAQI,QAAUJ,EAAQG,MAA2B,GAAnBP,IAEnC7N,GAAc,EAAOU,EAAK,CAAEL,UAAU,EAAOC,gBAAgB,IAC7D2N,EAAQI,QAAS,EAEzB,CACA,SAASH,GAAcH,GAKnB,MAJgB,CACZK,MAAO,EACP/H,MAAO0H,EAGf,CC9BO,SAASO,GAAiBzJ,EAAKC,EAAMyJ,GACxC,MAAMC,EAAapJ,OAAOqJ,yBAAyB5J,EAAKC,GACxDM,OAAOsJ,eAAe7J,EAAKC,EAAM6J,OAAKH,GAAL,CAAiBD,eACtD,CCHO,SAASK,GAAUC,EAAGC,GACzB,MAAMC,EAAK3J,OAAO4J,KAAMC,SAAYJ,EACpC,OAAOA,GAAKC,GAAY,WAAPG,GAAmBA,WADeH,EAE7CC,EAAGF,GAAG5O,SAAW8O,EAAGD,GAAG7O,QAAU8O,EAAGF,GAAG3J,MAAOvE,GAAQiO,GAAUC,EAAElO,GAAMmO,EAAEnO,KAC1EkO,IAAMC,CAChB,CCAI1K,ICaJ,SAAS8K,GAAiBC,GACtB,MAAMC,EAAO/E,SAASgF,eAAeF,GACrCnM,EAAYoM,EAEZ,kBAAkBD,wIAClB,MAAMG,EAAUF,EAAKG,YAYrB,OAVaC,EAAMF,EAAS,CAIxB,OAAAG,CAAQC,EAAMlN,GACV,GAAqB,iBAAVA,EACP,MAAO,CAAEmN,YAAanN,EAAMoN,WAAW,MAAO,KAAMC,UAAU,EAEtE,GAGR,CChBA,SAASC,GAAYC,GACjB,MAAO,CAACC,EAAUC,KACd,MAAMC,EAAOH,EAASC,GAChBG,EAAOJ,EAASE,GACtB,OAAIC,IAASC,EACF,EAEJD,EAAOC,GAAO,EAAK,EAElC,CAuCA,SAASC,GAAUL,GACf,MAAO,CAACC,EAAUC,KACd,MAAMC,EAAOH,EAASC,GAChBG,EAAOJ,EAASE,GAGtB,OAAIC,IAASC,EACF,GAEE,IAATD,IAA0B,IAATC,GACV,GAEE,IAATA,IAA0B,IAATD,EACV,OADX,EAKR,CClFO,SAASG,GAAa1H,GACzB,QAJO1D,MAIW0D,EACtB,CCLA,SAAS2H,GAAqBC,GAC1B,MAAO,IAAMA,EAAWxG,IAAKnI,GAAQ,IAAMA,EAAM,KAAKS,KAAK,MAAQ,GACvE,CCFO,SAASmO,GAAqB3L,EAAKC,EAAM3F,GAAA,IAAAsR,EAAAtR,GAAEiO,OAAFqD,EAAU5D,EAAA6D,EAAVD,EAAU,CAAR,QAC9CrL,OAAOsJ,eAAe7J,EAAKC,EAAM6J,OAAK9B,GAAL,CAAWO,QAChD,CCaA,MA8BMuD,GAAe,CACjB,MACA,SACA,QACA,KACA,OAEEC,GAA0B,IAzBd,CAXd,KACA,MACA,MAKA,KACA,MACA,UAiBgB,CAXhB,MACA,OACA,OAKA,MACA,OACA,WAY8DD,IAElE,SAASE,GAAaC,GAClB,OAAOF,GAAwB1F,KAAM6F,GAAQD,EAAStI,SAAS,IAAMuI,GACzE,CCrDA,SAASC,GAAuBC,EAAcC,GAC1C,OAAOC,GAAUF,EAAcC,GAAQ,EAC3C,CACA,SAASE,GAAuBH,EAAcC,GAC1C,OAAOC,GAAUF,EAAcC,GAAQ,EAC3C,CACA,SAASC,GAAUF,EAAcC,EAAQG,GACrC,MAAMC,EAAMD,EAAc,cAAgB,cACpCE,EAAoBN,EACrBjP,OAAQ2G,GAAMA,EAAE6I,WAAWN,IAA0B,gBAAfvI,EAAE8I,UACxCC,KAuBT,SAA4BL,EAAaH,GACrC,MAAMI,EAAMD,EAAc,cAAgB,cACpCM,GAAU,EACVC,EAAU,EACVC,EAAU,EAChB,MAAO,CAACC,EAAIC,KAER,IAAKD,EAAGE,mBAAqBD,EAAGC,kBAC5B,OAAOL,EAEX,IAAKI,EAAGC,mBAAqBF,EAAGE,kBAC5B,OAAOJ,EAGX,CACI,MAAMK,EAAgBH,EAAGI,mBACnBC,EAAgBJ,EAAGG,mBACzB,IAAKD,GAAiBE,EAClB,OAAOR,EAEX,IAAKQ,GAAiBF,EAClB,OAAOL,CAGf,CAEA,CACI,MAAMQ,EAAcC,GAAgBnB,EAAQY,EAAGhB,UACzCwB,EAAcD,GAAgBnB,EAAQa,EAAGjB,UAC/C,GAAIsB,EAAcE,EACd,OAAOX,EAEX,GAAIW,EAAcF,EACd,OAAOR,CAGf,CAGI,OAAIE,EAAGS,MAAMjB,IAAQS,EAAGQ,MAAM,qBACnBZ,EAEPI,EAAGQ,MAAMjB,IAAQQ,EAAGS,MAAM,qBACnBX,EAGRC,EAEf,CAvEcW,CAAmBnB,EAAaH,IAEpCuB,EAAiBC,IACnB,MAAMC,EAAQpB,EAAkBvP,OAAQ2G,GAAMA,EAAEuI,SAAWA,GAAUvI,EAAE4J,MAAMG,EAAM,oBAAsBpB,IACzGtO,EAAY2P,EAAM1S,QAAU,EAAG,iDAAiD0S,EAAM5I,IAAKpB,GAAMA,EAAEmI,UAAUzO,KAAK,QAClH,MAAMuQ,EAAaD,EAAM,GAEzB,YADsB,IAAfC,GAA6BA,EAAWZ,kBACxCY,GAELC,EAAgBJ,GAAc,GAC9BK,EAAgBL,GAAc,GAG9BM,EAAmBL,GAAQnB,EAAkBvP,OAAQ2G,GAAMA,EAAEuJ,oBAAsBvJ,EAAE4J,MAAMG,EAAM,oBAAsBpB,IAAM,GAC7H0B,EAAkBD,GAAgB,GAClCE,EAAkBF,GAAgB,GAMxC,MADkB,CAACF,EAAeC,KAFFvB,EAAkBvP,OAAQ2G,GAAMA,EAAEqJ,oBAAsBrJ,EAAEuJ,qBAAuBvJ,EAAE4J,MAAMjB,IAAQ3I,EAAE4J,MAAM,uBAE5DS,EAAiBC,GAAiBjR,OAAOqO,GAE1H,CAkDA,SAASgC,GAAgBa,EAAOC,GAE5B,IAAIC,EAAM,EACV,KAAOA,EAAMF,EAAMjT,QAAUmT,EAAMD,EAAMlT,QACjCiT,EAAME,KAASD,EAAMC,GADoBA,KAIjD,MAAMC,EAAqBH,EAAMlN,MAAMoN,GACjCE,EAAqBH,EAAMnN,MAAMoN,GAIvC,OAHkBC,EAAmBxR,MAAM,KAAK5B,OAC9BqT,EAAmBzR,MAAM,KAAK5B,MAGpD,CCjGA,MAAMsT,GAAyB,CAAC,cAAe,aACzCC,GAAkB,CAAC,OAAQ,cAAe,WCMhD,SAASC,GAAyBhN,GAC9B,MAAMiN,ECFV,SAAmBjN,EAAKkN,GACpB,MAAM5K,iBAAEA,EAAA1B,eAAkBA,EAAAR,aAAgBA,GAAiBL,EAASC,EAFrD,KAGXA,EAAItE,WAAW,KAGnB,MAAMyR,EAAmB7K,EAAiBP,SAAS,KACnD,IAAIqL,EAiBJ,OALIA,EAAmB9K,GAAoB6K,EAAmB,GAAK,KAAO,QAG1EC,GAAsCF,EACtB,GAAGE,IAAmBxM,GAAkB,KAAKR,GAAgB,IAEjF,CDtBkCiN,CAAUrN,EALP,qBAMjC,OAAOiN,CACX,CERA,SAASK,GAAc7C,EAAQ8C,GAC3B,MAAMC,EAAaD,EAAYE,KAAMvL,GAAMA,EAAEuI,SAAWA,GAGxD,OAFO8C,EAAY/T,OAEZgU,CACX,CACA,SAASE,GAAmCC,GAIxC,IAAKA,GAAiBzP,EAAQyP,IAAkBA,EAAcC,UAC1D,OAAO,KACX,MAAMC,qBAAEA,GAAyBF,EAEjC,OAAOE,CACX,CACA,SAASC,GAA4BH,GAGjC,OAF6BD,GAAmCC,EAGpE,CCdA,SAASI,GAA2BC,EAAeC,EAAYN,GAC3D,OAAKA,EAIM,GAAGO,GAAMF,EAAeC,SAAkBE,GAAmBR,EAAeM,KAH5E,GAAGC,GAAMF,EAAeC,eAKvC,CACA,SAASC,GAAMF,EAAeC,GAC1B,MAAO,GAAGD,KAAiBvU,EAAGqE,KAAKmQ,YACvC,CACA,SAASE,GAAmBR,EAAeM,GACvC,IAAI/B,EAEAA,EADAhO,EAAQyP,GACAA,EAGA,CAACA,GAENzB,EAAM1S,OACb,MAAM4U,EAAkBlC,EACnB5I,IAAK+K,IACN,GAAIA,EAAUT,UACV,OAaZ,SAA4BS,EAAWJ,GACnC,GAA4B,QAAxBI,EAAUT,UACV,MAAO,YAAYnU,EAAGqE,KAAK,GAAGuQ,EAAUC,6BAA6BL,YAEzE,MAAML,UAAEA,GAAcS,EACtB,GAAkB,QAAdT,EACA,MAAO,cAAcnU,EAAGqE,KAAK,KAAKmQ,OAEtC,GAAkB,QAAdL,EACA,MAAO,wBAAwBnU,EAAGqE,KAAK,iBAAiBmQ,QAIhE,CA1BmBM,CAAmBF,EAAWJ,GACzC,MAAMJ,qBAAEA,EAAAW,2BAAsBA,GAA+BH,EACvDI,ECjCd,SAAuBD,EAA4BP,GAC/C,IAAKO,EACD,OAAO,KACX,IAAKE,KAAeC,GAAoBH,EACxC,IAAKE,EACD,OAAO,KACX,GAAgC,IAA5BC,EAAiBnV,QAAgB,CAAC,IAAK,UAAWyU,GAAYxS,SAASiT,GACvE,OAAO,KAEX,IAAItR,EAAS,GACTwR,EAAS,GAab,MAZmB,YAAfF,EACAtR,EAAS,kBAGTA,EAAS,SACTuR,EAAmB,CAACD,KAAeC,IAEvCA,EAAiBtN,QAAShD,IACtBjB,EAAS,GAAGA,OAAYiB,IACxBuQ,EAAS,KAAKA,MAECxR,EAASwR,CAEhC,CDS2BC,CAAcL,EAA4BP,GAC7D,OAAIQ,EACO,GAAGZ,OAA0BpU,EAAGqE,KAAK2Q,KAGrCZ,IAGVjS,KAAK,OACV,OAAOwS,CACX,CEzCA,SAASU,GAAoBC,EAAad,EAAY3P,GAKlD,MAAMvC,MAAEA,EAAA4R,cAAOA,GAAkBoB,EAGjC,OAFIzQ,GAIR,SAA+BvC,EAAOuC,EAAM2P,EAAYN,GAEpD,MAAMqB,SAAoBjT,EAC1B,GAAIiT,IAAe1Q,EACf,OACJ,MAAM2Q,ECnBH,SAA2BlT,GAC9B,MAAI,CAAC,UAAM,GAAWN,SAASM,GACpBmT,OAAOnT,GACd,CAAC,UAAW,SAAU,UAAUN,gBAAgBM,GACzCoT,KAAKC,UAAUrT,GACnB,IACX,CDa2BsT,CAAkBtT,GACnCuT,EAA6B,OAAnBL,EACV,SAASxV,EAAGqE,KAAKmR,KACjB,QAAQxV,EAAGqE,KAAKkR,KAChBO,EAAkBxB,GAA2B,SAAUE,EAAYN,GACnEnR,EAAS,GAAG+S,oBAAkCD,qBAA2B7V,EAAGqE,KAAKQ,aACvF/B,GAAY,EAAOC,EACvB,CAfQgT,CAAsBzT,EAAOuC,EAAM2P,EAAYN,GAC5CoB,CACX,CEXA,SAASU,GAAsBjC,EAAYS,EAAY3P,GACnD,MAAMyQ,EAAcvB,EAAWkC,aAAazB,GAC5C,OAAKc,EAEED,GAAoBC,EAAad,EAAY3P,GADzC,IAEf,CCJA,SAASqR,GAAgCC,GAA2BC,SAAEA,EAAAC,aAAUA,IAC5E,GAAIF,QACA,OACIC,EAAS9N,SAAS,KAC1B,MAAM8C,EAAY,OAAOpL,EAAGqE,KAAK,yCAAyC+R,uBAA8BC,IACxGvT,EAAYT,EAAS8T,GAA4B,GAAG/K,mCAA2CpL,EAAGqE,KAAK,0BAA0BqR,KAAKC,iBAAiBQ,kBACvJrT,IAAc,kBAAmBqT,GAA4B,GAAG/K,4BAAoCpL,EAAGqE,KAAK,yGAG5GvE,IAAgB,WAAYqW,GAA4B,GAAG/K,UAAkBpL,EAAGqE,KAAK,kKAAmK,CAAElE,UAAU,IACpQ2C,IAAc,UAAWqT,GAA4B,GAAG/K,UAAkBpL,EAAGqE,KAAK,gDAAgDrE,EAAGqE,KAAK,yDAC9I,CCTA,SAASiS,GAA+BC,EAAiBF,GACrD,GAAIE,QACA,OAEJ,MAAMnL,EAAY,wCAAwCiL,IAC1DvT,EAAYuC,EAAckR,GAAkB,GAAGnL,8CAAsDpL,EAAGqE,KAAK,oBAAoBrE,EAAGqE,KAAK,WCR7I,SAAkCM,EAAK6R,EAAcpL,GAEjD,MAAMqL,EAAc,GACd3H,EAAO5J,OAAO4J,KAAKnK,GACzB,UAAWlE,KAAOqO,EACT0H,EAAaxU,SAASvB,IACvBgW,EAAY7T,KAAKnC,GAGzBqC,EAAmC,IAAvB2T,EAAY1W,OAAc,CAClCqL,EACA,kDACAgF,GAAqBqG,GAAe,IACpC,mCACArG,GAAqBoG,GAAgB,KACvCrU,KAAK,KACX,CDPIuU,CAAyBH,EAAiB,CAAC,eAAgBnL,GACvDmL,EAAgBI,aAChBT,GAAgCK,EAA6B,YAAG,CAAEH,SAAU,iBAAkBC,gBAEtG,CEDA,MAAM/W,GAAeT,EAAgB,mBAAoB,IACzD,SAAS+X,GAAuBD,EAAaP,GACzC,KAAMA,KAAYO,EAAYE,SAC1B,OAAO,KAEX,MAAMC,aAAEA,GAAiBH,EAAYI,OAC/BC,EAAcC,GAAeH,EAAcV,GAC3Cc,EAASP,EAAYE,QAAQT,GACnC,GAAe,OAAXc,EACA,OAAO,KAEX,MAAMC,EAAOR,EAAYS,WAAWhB,GAAU,GACvCe,EAAKE,YAGZ,OAAOC,GAAQJ,EAAQd,EAFFe,EAAKvG,SAEqBoG,EACnD,CAEA,SAASO,GAA0BnB,EAAUO,SACzC,MAAMG,aAAEA,GAAiBH,EAAYI,OAC/BC,EAAcC,GAAeH,EAAcV,GAC3CoB,EAAQ,GAed,OARA,OAAAvY,EAAA0X,EAAYS,WAAWhB,KAAvBnX,EAAkC2I,QAAS7C,IACvC,MAAMmS,EAASnS,EAAIsS,YACnB,GAAe,OAAXH,EACA,OACJ,MAAMb,EAAetR,EAAI6L,SAEzB4G,EAAM5U,KAAK0U,GAAQJ,EAAQd,EAAUC,EAAcW,MAEhDQ,CACX,CAUA,SAASC,GAA4BC,EAAkBtB,GACnD,MAAMd,EAAcoC,EAAiBzB,aAAaG,GAClD,KAAK,MAAAd,OAAA,EAAAA,EAAahT,OACd,OAAO,KACX,MAAM4U,OAAEA,EAAAb,aAAQA,GA6BpB,SAAgCf,GAC5B,MAAM4B,EAAS5B,EAAYhT,MAErB+T,EAAehC,GAA4BiB,EAAYpB,eAC7D,MAAO,CAAEgD,SAAQb,eACrB,CAlCqCsB,CAAuBrC,GAExD,OAAOgC,GAAQJ,EAAQd,EAAUC,EADbuB,GAAqBxB,GAE7C,CACA,SAASyB,GAAsCH,EAAkBtB,GAC7D,MAAMd,EAAcoC,EAAiBzB,aAAaG,GAClD,KAAK,MAAAd,OAAA,EAAAA,EAAahT,OACd,MAAO,GAGX,OAFYgT,EAAYhT,MAEbuH,IAAI,CAAC5E,EAAGuD,KACf,MAAM0O,EAASjS,EACT+R,EAAcY,GAAqBxB,GAClC3R,EAAQ6Q,EAAYpB,eAC3B,MAAMmC,EAAehC,GAA4BiB,EAAYpB,cAAc1L,IAC3E,OAAO8O,GAAQJ,EAAQd,EAAUC,EAAcW,IAEvD,CACA,SAASY,GAAqBxB,GAG1B,OADoB0B,GAAsB1B,EAE9C,CACA,SAASkB,GAAQJ,EAAQd,EAAUC,EAAcW,IAYjD,SAAsBE,GAAQd,SAAEA,EAAAC,aAAUA,IAE9BD,EAAS9N,SAAS,KAClB+N,EAAa/N,SAAS,KAC9BxF,EAAYwB,EAAW4S,GAAS,QAAQd,kBAAyBC,yBAErE,CAhBI0B,CAAab,EAAQ,CAAEd,WAAUC,iBAEjC,MADa,CAAEa,SAAQd,WAAUC,eAAcW,cAEnD,CAcA,SAASC,GAAee,EAA4B5B,GAChD,MAAM6B,EAYV,SAAiDD,GAC7C,QAAmC,IAA/BA,EACA,MAAO,GACX,IAAmC,IAA/BA,EACA,OAAO,EACXlV,EAAYT,EAAS2V,GAA6B,WAAWhY,EAAGqE,KAAK,6BAA6BrE,EAAGqE,KAAK,yBAC1G,MAAM6T,EAAuC,GAkB7C,OAjBAhT,OAAOiT,QAAQH,GAA4BpQ,QAAQ,EAAEwO,EAAUgC,MAC3D,IAAkC,IAA9BA,EAEA,YADAF,EAAqC9B,GAAY,CAAE7S,OAAO,EAAO8U,SAAS,IAG9EvV,EAAYT,EAAS+V,GAA4B,WAAWpY,EAAGqE,KAAK,gBAAgB+R,kBAAyBpW,EAAGqE,KAAK,yBACrH,MAAOd,EAAO8U,GAAW,CAAC,QAAS,WAAWxO,IAAKyO,IAC/C,MAAMC,EAAaH,EAA0BE,GAC7C,QAAmB,IAAfC,IAA2C,IAAfA,EAC5B,OAAOA,EACX,MAAMnN,EAAY,WAAWpL,EAAGqE,KAAK,gBAAgB+R,KAAYkC,iBAGjE,OAFAxV,EAAkC,iBAAfyV,EAAyB,GAAGnN,KAAapL,EAAGqE,KAAK,wBACpEvB,EAAYyV,EAAa,EAAG,GAAGnN,uBACxBmN,IAEXL,EAAqC9B,GAAY,CAAE7S,QAAO8U,aAEvDH,CACX,CArCiDM,CAAwCR,GACrF,IAA6C,IAAzCC,EACA,MAAO,CAAE1U,OAAO,EAAO8U,SAAS,GACpC,MAAMI,EAAiBR,EAAqC7B,GACtDY,EAAcc,GAAsB1B,GAK1C,YAJ8B,WAA1BqC,WAAgBlV,SAChByT,EAAYzT,MAAQkV,EAAelV,YACP,WAA5BkV,WAAgBJ,WAChBrB,EAAYqB,QAAUI,EAAeJ,SAClCrB,CACX,CA4BA,SAASc,GAAsB1B,GAC3B,MAAiB,kBAAbA,EACO,CACH7S,MAAO,IACP8U,QAAS,KAGb/Y,GAAaoZ,eACN,CACHnV,MAAO,KACP8U,QAAS,MAILjC,EAASuC,cAAc3W,SAAS,aAErC,CACHuB,MAAO,IACP8U,QAAS,KAEjB,WCtJA,MAAMO,GAAQ,CACV,OACA,aACA,aACA,uBACA,2BACA,gCACA,YACA,qBACA,WACA,oBACA,cACA,iBACA,uBACA,sBACA,eACA,aACA,cACA,oBACA,iBAIEC,GAAQ,OAAAC,EAgId,WACI,IAAID,EAaJ,IACIA,EAAQE,GAAYF,KACxB,OACM5O,GAAE,CACR,OAAO4O,CACX,CAnJcG,IAAAF,EAAc,GAsH5B,SAASG,WAIL,MAAO,CAAEC,eAHc,OAAAja,EAAA4Z,GAAMM,MAAM,yBAAyB,GAGnCC,MAFXP,GAAM7W,SAAS,UAEGqX,SADf,mBAAmB1O,KAAKkO,IAE7C,CCjKA,SAASS,GAAa5N,GAClB,MAAM6N,EAAU7N,EAAe,IAC/B,GAAI6N,EAAU,IAAK,CACf,MAAMC,EAAIC,GAAMF,GAChB,MAAO,GAAGC,WAAWE,GAAOF,IAChC,CACA,CACI,MACMA,EAAIC,GADMF,EAAU,IAE1B,MAAO,GAAGC,WAAWE,GAAOF,IAChC,CACJ,CACA,SAASC,GAAMD,GACX,IAAIG,EAAUH,EAAEI,QAAQ,GAGxB,OAFID,EAAQrR,SAAS,QACjBqR,EAAUA,EAAQ7T,MAAM,GAAG,IACxB6T,CACX,CACA,SAASD,GAAOF,GACZ,MAAa,MAANA,EAAY,GAAK,GAC5B,CCnBA,SAASK,GAAoBlD,IAG7B,SAAkBA,GACd,QAA0B,IAAtBA,EAAYmD,OAA6C,OAAtBnD,EAAYmD,MAC/C,OACJ,MAAMC,EAAYpD,EAAYoD,WAAa,GAC3C,IAAK1X,EAAS0X,GAEV,YADAja,GAAc,EAAO,4CAA6C,CAAEM,gBAAgB,EAAMD,UAAU,IAGxG4Z,EAAUD,MAAQC,EAAUD,OAASnD,EAAYmD,MACjDnD,EAAYoD,UAAYA,CAC5B,CAZIC,CAASrD,EACb,EF+JA,WACI,MAAMuC,eAAEA,EAAAE,MAAgBA,EAAAC,SAAOA,GAAaJ,KAC5C,OAAOG,GAASF,EAAenZ,OAAS,GAAKsZ,CACjD,EA9HIY,KACAnZ,MAAMoZ,gBAAkBC,KA8G5B,WACI,MAAMjB,eAAEA,GAAmBD,KAC3BC,EAAetR,QAASwS,IACpBtX,EAAY8V,GAAM5W,SAASoY,GAAO,sBAAsBpa,EAAGqE,KAAK+V,qBAAwBxB,GAAM/O,IAAKwQ,GAAM,KAAKra,EAAGqE,KAAKgW,MAAMlY,KAAK,UAEzI,CAlHAmY,GGpCIxW,KACAI,ICPG,MAAMqW,GAAmB,6BCUhC,SAASC,GAAuB7V,EAAK8V,EAASC,EAAoBC,GAC9D,OAAO,IAAI1N,MAAMtI,EAAK,CAClBuI,IAAK,CAAC0N,EAAGhW,IAGjB,SAAiBA,EAAMD,EAAK8V,EAASC,EAAoBC,GACrD,MAAME,EAAUpF,OAAO7Q,GACvB,GAAa,mBAATA,EACA,OAAO,EACX,GAAa,4BAATA,EACA,OAAOD,EAKX,GAAIgW,KAAc/V,KAAQD,GAGtB,OAAOgW,EAAS/V,GAEpB,MAAMG,EAAMJ,EAAIC,GAEhB,OAEJ,SAA2BiW,EAAS9V,EAAK0V,GACrC,GAAI1V,IAAQwV,GACR,OACJ,MAAMO,GCrC4Bra,EDqCKoa,ECpCjB,iBAARpa,GAElB,SAAoCA,GAChC,MAAO,kBAAkBkK,KAAKlK,EAClC,CAJsCsa,CAA2Bta,GAAO,IAAIA,IAAQ,IAAIiV,KAAKC,UAAUlV,OADhG,IAA+BA,EDuClCqC,GAAY,EAAO,gBAAgB2X,IAAUK,yEACjD,CATIE,CAAkBH,EAAS9V,EAAK0V,GACzB1V,CACX,CArB0BkW,CAAQrW,EAAMD,EAAK8V,EAASC,EAAoBC,IAE1E,CEXA,SAASO,GAAmCC,GACjCA,EAAcxV,kBAErB,OAD4B6U,GAAuBW,EAAe,gBAEtE,CCDA,SAASC,GAAiCzE,GAC9BA,EAAY0E,eACZ1E,EAAYwE,cACbxE,EAAYhR,kBACnBkU,GAAoBlD,GAEd,YAAaA,GACfzR,OAAOsJ,eAAemI,EAAa,UAAW,CAC1CzJ,IAAA,KACIpN,GAAc,EAAO,6DAA8D,CAC/EM,gBAAgB,EAChBD,UAAU,IAEPwW,EAAY3F,QAEvB3C,YAAY,IAoBxB,SAAyBsI,GACrB,IAAI2E,EAAcpW,OAAOW,0BAA0B8Q,GACnD,UAAWlW,KAAOyE,OAAO4J,KAAK6H,UACnBA,EAAYlW,GACvB6a,EAAcpW,OAAOqW,YAAYrW,OAAOiT,QAAQmD,GAAa9J,KAAK,EAAEgK,IAAQC,MAAUC,OC5C7DC,ED4CiFF,GC5CvFG,ED4CiFJ,GC3C3F7C,cAAgBgD,EAAKhD,eACnB,EACPiD,EAAKjD,cAAgBgD,EAAKhD,cACnB,EACJ,EALX,IAAuBiD,EAAMD,KD6CzBzW,OAAOU,iBAAiB+Q,EAAa2E,EACzC,CAtBIO,CAAgBlF,GAChB,MAAMmF,EAAsBZ,GAAmCvE,EAAYoF,gBAY3E,OAX0BvB,GAAuB7D,EAAa,cAG9D,EAAO/R,GACU,kBAATA,EACOkX,EAEPlX,KAAQkX,EACDA,EAAoBlX,QAD/B,EAKR,CASA,SAASoX,GAAsBrF,GAiB3B,CACI,cAEA,YAEA,MAEA,eACF/O,QAAShD,IACH+R,EAAY/R,ME1EjB,SAA0BD,EAAKC,GAClC,MAAM0J,EAAapJ,OAAOqJ,yBAAyB5J,EAAKC,KAC/C0J,KAAgB,UAAWA,IAAiBA,EAAWpB,GACpE,CFwEmB+O,CAAiBtF,EAAa/R,IAEjD,CG7DA,MAAMtF,KAA+B,oBAAqB,CACtD4c,mBAAoBC,QACpBxF,YAAa,OAEjB,SAAeyF,GAAShG,EAAUO,EAAayE,GAAkC,OAAAiB,EAAAC,KAAA,iBAC7E,MAAM9E,EAAQD,GAA0BnB,EAAUO,GAClD,aAAa4F,GAAe/E,EAAOb,EAAayE,EACpD,GAQA,SAAemB,GAAe/E,EAAOb,EAAayE,GAAkC,OAAAiB,EAAAC,KAAA,iBAChF,IAAK9E,EAAMzX,OACP,MAAO,GACX,MAAMyc,EAA4BpB,EAAiCzE,GAKnE,aAJ8BhL,QAAQ8Q,IAAIjF,EAAM3N,IAAW6S,GAASL,EAAAC,KAAA,iBAChE,MAAMK,QAAmBC,GAAoB,IAAMF,EAAKxF,OAAOsF,GAA4BE,EAAMF,GACjG,OAAO/N,EAAAoO,EAAA,GAAKH,GAAL,CAAWC,cACtB,IAEJ,GACA,SAAeG,GAAqBJ,EAAM/F,EAAayE,GAAkC,OAAAiB,EAAAC,KAAA,iBACrF,MAAMS,QAAwBR,GAAe,CAACG,GAAO/F,EAAayE,IAC5DuB,WAAEA,GAAeI,EAAgB,GACvCja,OAA2B,IAAf6Z,EAA0B,OAAOD,EAAKtG,8BAA8BsG,EAAKrG,+CACzF,GAgBA,SAASuG,GAAoBI,EAAcN,EAAMF,GAC7C,MAAMpG,SAAEA,EAAAC,aAAUA,EAAcW,aAAezT,MAAO0Z,EAAY5E,QAAS6E,IAAmBR,EAC9F,IAAIrQ,EACAC,EACJ,MAAMU,EAAU,IAAIrB,QAAQ,CAACc,EAAUC,KACnCL,EAAW5C,IACP0T,IACA1Q,EAAShD,IAEb6C,EAAUrL,IACNkc,IACAzQ,EAAQzL,MAGVkc,EAAgB,KACdC,GACArQ,aAAaqQ,GACbC,GACAtQ,aAAasQ,IAEfD,EAAqBE,GAAcJ,IACrCrR,WAAW,KACP/L,GAAc,EAAO,OAAOsW,uBAA8BC,oCAA+CiD,GAAa4D,qCAAgD,CAAE/c,UAAU,KACnL+c,GACDG,EAAoBC,GAAcL,IACpCpR,WAAW,KACP,MAAM5K,EAAMwC,EAAgB,OAAO2S,uBAA8BC,uCAAkDiD,GAAa2D,sCAChI3Q,EAAOrL,IACRgc,GAcP,MAbA,MAAaZ,EAAAC,KAAA,iBACT,IACIiB,GAA2Bf,GAC3B,MAAM/S,QAAYuT,IAClB3Q,EAAQ5C,EACZ,OACOxI,GACCoB,EAASpB,IACT3B,GAAa4c,eAAesB,IAAIvc,EAAK,CAAEmV,WAAUC,iBAErD/J,EAAOrL,EACX,CACJ,IAZA,GAaO+L,CACX,CACA,SAASyQ,GAAmBf,EAAM/F,EAAayE,GAC3C,MAAMoB,EAA4BpB,EAAiCzE,GACnE4G,GAA2Bf,GAE3B,MAAO,CAAEG,WADUD,EAAKxF,OAAOsF,GAEnC,CACA,SAASc,GAAcnR,GACnB,QAASA,GAAWA,IAAYgO,GACpC,CAwBA,SAASoD,GAA2B5G,GAChCrX,GAAaqX,YAAcA,EAG3BhL,QAAQU,UAAUqR,KAAK,KACnBpe,GAAaqX,YAAc,MAEnC,CC5IA,MAAMgH,GAAW,8BACjB,SAAeC,GAAcjH,EAAakH,GAAuB,OAAAxB,EAAAC,KAAA,iBAC7D,IAAII,EACA/F,EAAYoF,eAAe+B,cAAc/d,OAAS,GAG3C4W,EAAYoF,eAAegC,aAAahe,OAC/C2c,EAUR,SAAuB1L,EAAQD,GAC3B,MAAMiN,EAAgBjN,EAAaiD,KAAMvL,GAAMA,EAAEuI,SAAWA,GAAyB,gBAAfvI,EAAE8I,UACxE,IAAKyM,EACD,OAAO,KACX,MAAMpN,SAAEA,EAAAqN,YAAUA,GAAgBD,EAE5B9G,EAAS+G,EAAYC,MAC3B,IAAKhH,EACD,OAAO,KACX,MAAMb,EAAezF,EACfoG,EAAcc,GAAsB,SAE1C,OADAhV,EAAYwB,EAAW4S,GAAS,GAAGyG,MAAYtH,0BACxC,CAAEa,SAAQd,SAAU,QAASC,eAAcW,cACtD,CAvBemH,CAAcxH,EAAY3F,OAAQ2F,EAAYoF,eAAe+B,gBAIpEpB,EAAO9F,GAAuBD,EAAa,SAE1C+F,UAECI,GAAqBJ,EAAM/F,EAAakH,GAClD,GC2FA,MAAMO,GAAQ,gBACd,SAASC,GAAa9Z,GAClB,MAAwB,iBAAVA,GAAgC,OAAVA,GAAkB6Z,MAAS7Z,CACnE,CA+DA,SAAS+Z,GAA8BC,IAQvC,SAA8BA,GAC1B,MAAMC,EAAc,GACpBD,EAAwB3W,QAAS+O,IAC7B,MAAM8H,EAAa9H,EAAY+H,YAC/B,CACI,MAAMxL,EAAMsL,EAAYG,QAAQF,GAChC,IAAY,IAARvL,EAAY,CAEZpQ,GAAY,EAAO,oCADN,IAAI0b,EAAY1Y,MAAMoN,GAAMuL,GAAY5U,IAAKtD,GAAQ,WAAWA,OAASpE,KAAK,UAE/F,CACJ,CACAqc,EAAY5b,KAAK6b,IAEzB,CApBIG,CAAqBL,GACrB,MAAMM,EAA6B,CAAEH,YAAa,MAIlD,OAHAH,EAAwB3W,QAASkX,IAC7B5Z,OAAO6Z,OAAOF,EAA4BC,KAEvCD,CACX,CCxLO,MCAMG,GAAoB,qBCIjC,SAASC,GAA6CtI,WAYlD,OAPAnR,EAAamR,EAAa,CAAEuI,MAHf,OAAAjgB,EAAA0X,EAAYI,aAAZ,EAAA9X,EAAoBigB,QAE7B,OAAA3O,EAAAoG,EAAYE,cAAZ,EAAAtG,EAAqB2O,QAGzBlD,GAAsBrF,GAiB1B,SAA6BA,IAK7B,SAAwBA,GACpBzR,OAAOiT,QAAQxB,GAAa/O,QAAQ,EAAEnH,EAAKsE,aAChC4R,EAAYlW,GACnBkW,EAAYlW,GAAOsE,GAE3B,CATIoa,CAAexI,EACnB,CAfIyI,CAAoBzI,GACb0I,GAA8C1I,EACzD,CACA,SAAS0I,GAA8C1I,GAEnD,OAD0ByE,GAAiCzE,EAE/D,CCnBA,SAAS2I,GAAuC3I,GAC5C,OAAOsI,GAA6CtI,EACxD,CCiBA,MAAMrX,GAAeT,EAAgB,oDAAqD,IAE1F,SAAS0gB,KACL,MAAMC,EtCfV,WACI,MAAMC,EAA8BzQ,GuCVC,oBvCarC,OAFOtK,EAAQ+a,EAA6B,SAAU,UAC/C/a,EAAQ+a,EAA6B,cAAe,YACpDA,CACX,CsCUkCC,GAK9B,OAJAC,GAA6BH,GAC7Bha,EAAaga,EAAuB,CAChCI,2BAA2B,IAExBJ,CACX,CAaA,SAAeK,GAA8BlJ,EAAamJ,GAAa,OAAAzD,EAAAC,KAAA,iBACnE,MAAMyD,EAA6B,CAC/BH,2BAA2B,GAK/B,IAECE,UA0GL,SAAoCnJ,GAAa,OAAA0F,EAAAC,KAAA,iBAC7C,GAAI0D,GAAYrJ,GAAc,CAC1B,MAAMsJ,oCAAEA,SE7JhB,SAAqClP,EAAcC,GAAQ,OAAAqL,EAAAC,KAAA,iBACvD,MACM4D,EADsBhP,GAAuBH,EAAcC,GACblP,OAAQ2G,GAAqB,iBAAfA,EAAE8I,UAapE,aAZM5F,QAAQ8Q,IAAIyD,EAAwBrW,IAAWpB,GAAM4T,EAAAC,KAAA,iBAEnD7T,EAAE0X,cAGC1X,EAAE2X,sBACH3X,EAAE2X,kBACZ,KAKO,CAAEH,oCAJmCC,EAAwBlV,KAAK,EAAGmV,iBAEjEA,EAAYne,SAAS,mBAGpC,GF6I8Dqe,CAAsB1J,EAAYmH,cAAenH,EAAY3F,QAEnH,OAAOiP,CACX,CACA,QAAS3gB,GAAaghB,iCAE1B,SAA2B3J,SACvB,GAAIqJ,GAAYrJ,GACZ,OAAO,EACX,MAAM5C,EAAaF,GAAc8C,EAAY3F,OAAQ2F,EAAYoF,eAAegC,cAGhF,OAFY,OAAA9e,EAAA+W,GAAsBjC,EAAY,2BAAlC,EAAA9U,EAAwDqD,KAGxE,CAT6Die,CAAkB5J,EAC/E,GA/Ge6J,CAAqB7J,IAAe,CAC3C,MAAM8J,QAqId,SAA0C9J,GAAa,OAAA0F,EAAAC,KAAA,uBACnD,IAAIoE,EAAiBnN,GAAyB,OAAAtU,EAAA0X,EAAY+H,aAAZzf,EAA2B0X,EAAYgK,aAIrF,MAAMC,QAAiBC,MAAMH,GAC7B,CACI,MAAMI,EAAcF,EAASG,QAAQ7T,IAAI,gBACnC8T,EAAqB,mBACrBC,EAAYH,GAAeA,EAAY9e,SAASgf,GAEtD,IAAKC,GAAiC,MAApBL,EAASM,OAEvB,OADA3V,GAAaoL,EAAYgK,aAClB,CAAEQ,uBAAuB,GAEpCre,EAAYme,EAAW,0BAA0BP,mBAAgCM,cAA+BF,yGACpH,CACA,MAAMM,QAAqBR,EAASS,OAC9BC,EAAwBhS,EAAM8R,GAEpC,GL7FJ,SAA4BzK,GACxB,SAAMA,EAAY+H,aAAe/H,EAAY4K,cAAgB5K,EAAY6K,mBAGlE9c,EAAQiS,EAAa,aAAc,WAKnC,EACX,CKmFQ8K,CAAmBH,GACnB,MLvHR,SAAqBI,GACjB,MAAMzgB,EAAM,IAAIH,MAAM,eAGtB,OAFA0E,EAAavE,EAAK,CAAE0gB,kBAAmBD,EAAkBtD,CAACA,KAAQ,IAE3Dnd,CACX,CKkHc2gB,CAAYN,GAGtB,GAAI,oBAAqBA,GAAyBtC,MAAqBsC,EACnE,MAAM7d,EAAgB,gFAG1B,OADAkc,GAA6B2B,GACtB,CAAEA,wBACb,GAlK0BO,CAA2BlL,GAC7C,GAAI,0BAA2B8J,EAC3B,MAAO,CAAEU,uBAAuB,GACpC,MAAMG,sBAAEA,GAA0Bb,EAClCV,EAA2BH,2BAA4B,EAIvDpa,EAAaua,EAA4BuB,EAC7C,CAEA,MAAO,CAAEvB,6BACb,GACA,SAAe+B,GAA8BnL,EAAamJ,GAAa,OAAAzD,EAAAC,KAAA,iBACnE,IAAIyF,GAAmB,EAMvB,UAAW3L,IAAY,CAAC,QAAS,OAAQ,kBACpB,UAAbA,EACK0J,GAEAnJ,EAAYiJ,kCAGPhC,GAAcjH,EAAcA,GAAgB2I,GAAuC3I,MAKzFqL,GAAqB5L,EAAUO,IAAiBA,EAAYiJ,4BAC3C,SAAbxJ,IACA2L,GAAmB,SAEjBE,GAAiB7L,EAAUO,IAK7C,MAAMuL,EAAcC,GAAW,OAAQxL,IAClCoL,GAAoBG,EAAYE,QAAYzL,EAAYiJ,2BAA6BsC,EAAYG,gBAC5FC,GAAe,SAAU3L,IAGnC,OADmCA,CAEvC,GACA,SAAe2L,GAAelM,EAAUO,GAAa,OAAA0F,EAAAC,KAAA,iBACjD,aAAaF,GAAShG,EAAUO,EAAclO,GAAM6W,GAAuC7W,GAC/F,GACA,SAAewZ,GAAiB7L,EAAUO,GAAa,OAAA0F,EAAAC,KAAA,iBACnD,IAAIiG,EAEAA,EADa,SAAbnM,QAQR,SAA4BO,GAAa,OAAA0F,EAAAC,KAAA,iBACrC,MACMI,SADY4F,GAAe,OAAQ3L,IACxB,GACjB,IAAK+F,EACD,OACJ,MAAMC,WAAEA,GAAeD,EAEvB,MAD4B,CAAE8F,KAAM7F,EAExC,GAfoC8F,CAAa9L,SAgBjD,SAAsCA,GAAa,OAAA0F,EAAAC,KAAA,iBAC/C,MACMI,SADY4F,GAAe,iBAAkB3L,IAClC,GACjB,IAAK+F,EACD,OACJ,MAAMC,WAAEA,EAAAtG,aAAYA,GAAiBqG,EAC/B6F,EAAsB,GAC5BjM,GAA+BqG,EAAYtG,GAE3C,MAAMqM,EAAgC,MAAA/F,OAAA,EAAAA,EAAYhG,YAIlD,OAHI+L,GACAld,EAAa+c,EAAqBG,GAE/BH,CACX,GA3BoCI,CAAuBhM,GAEvDzR,OAAO6Z,OAAOpI,EAAa4L,EAC/B,GA2DA,SAASP,GAAqB5L,EAAUO,GACpC,MAAMiM,EAAUT,GAAW/L,EAAUO,GACrC,QAASiM,EAAQR,SAAWQ,EAAQP,MACxC,CACA,SAASF,GAAW/L,EAAUO,WAC1B,GAAIqJ,GAAYrJ,GAEZ,MAAO,CAAEyL,QAAQ,EAAOC,QAAQ,GAKpC,OADiB,OAAA9R,EAAA,OAAAtR,EAAA+W,GAFEnC,GAAc8C,EAAY3F,OAAQ2F,EAAYoF,eAAegC,cAE7B,GAAG3H,cAArC,EAAAnX,EAAqDqD,OAArDiO,EAA8D,EAEnF,CA+BA,SAASoP,GAA6BhJ,GAClC7T,IAAc,gBAAiB6T,GAAc,qDACtCjS,EAAQiS,EAAa,SAAU,U/BxN1C,SAAgCA,GACT,IAAIrD,MAAoBD,IAChCzL,QAAShD,IACZA,KAAQ+R,IAIJtD,GAAuBrR,SAAS4C,IACzBA,EAAK3C,WAAW,OACvBnC,GAAc,EAAO,eAAe8E,4EAA+EA,mCAAuC,CAAEzE,UAAU,KAGtKL,GAAc,EAAO,eAAe8E,sDAAyDA,mCAAuC,CAAEzE,UAAU,WAE7IwW,EAAY/R,KAG/B,C+BwMIie,CAAuBlM,EAC3B,CAEA,SAASqJ,GAAYrJ,GACjB,OAA0D,IAAnDA,EAAYoF,eAAegC,aAAahe,MACnD,CGrMA,SAAS+iB,GAAanM,GAelB,IAAIoM,EACAC,EACArM,EAAYsM,YAEZF,EAAcpM,EAAYsM,WAC1BD,GAAoB,GAGfrM,EAAY+H,aAEjBqE,EAAcpM,EAAY+H,YAC1BsE,GAAoB,IAKpBD,EAAcpM,EAAYgK,YAC1BqC,GAAoB,GAKxB,IAAIE,EAAavM,EAAYwM,YACxBD,IACDA,EAAc3c,GAAQA,GAC1Bwc,EAAcG,EAAWH,GAOzB,OAAOzc,EAASyc,EAFIC,EAA0BrM,EAAYyM,YAAlB,IAG5C,CACA,SAASC,KACL,MAAMpb,SAAEA,GAAa6a,GAAaxG,MAC5BtT,EAAcf,EAEpB,OADOe,EAAY/G,WAAW,KACvB+G,CACX,CACA,SAASsa,KAGL,OADAxjB,GAAc,EAAO,6LAA8L,CAAEK,UAAU,EAAMC,gBAAgB,IAC9OijB,GAAkBE,KAAKjH,KAClC,CACA,SAASkH,KACL,MAEmCvkB,EAAA6jB,GAAaxG,OAAhDxT,cAAe8R,GAAoB3b,EAAdwkB,EAAAjT,EAAcvR,EAAd,CAArB,kBACMykB,EAAkB5f,IAClB6f,EAAwB/e,IAC1B9E,EAAc4jB,EAAiB,yBAAyB9e,kFAAsF,CAAEzE,UAAU,EAAMC,gBAAgB,KAE9KwjB,EAAoBnV,OACnBgV,GADmB,CAEtB,QAAIzc,GAEA,OADA2c,EAAqB,QACdF,EAAUzc,IACrB,EACA,gBAAIL,GAEA,OADAgd,EAAqB,gBACdF,EAAU9c,YACrB,EAEA,cAAID,GAMA,OALA5G,GAAc,EAAO,0FAA2F,CAC5GK,UAAU,EACVC,gBAAgB,IAEpBujB,EAAqB,cACdF,EAAU9c,YACrB,EAEA,gBAAIO,GAEA,OADApH,GAAc,EAAO,8FAA+F,CAAEK,UAAU,EAAMC,gBAAgB,IAC/IqjB,EAAUtc,cACrB,IAQJ,OANAiH,GAAiBwV,EAAmB,cAAc,GAClDxV,GAAiBwV,EAAmB,gBAAgB,GAC/CF,IACDtV,GAAiBwV,EAAmB,QAAQ,GAC5CxV,GAAiBwV,EAAmB,gBAAgB,IAEjDA,CACX,CC5HA,MAAMC,GAAc,CAAC,iBAYrB,MAAMC,GAA0B,CAAC,SAAU,gBAAiB,YAAa,kBCdzE,SAASC,GAAmBnT,GACxB,MAAMoT,EAAa,SACbhT,EAASlL,EAAM8K,EAASjP,MAAMqiB,GAAa,GAAG,GAAI7hB,KAAK6hB,GAE7D,OADQhT,EAAOhP,SAAS,MACjBgP,CACX,CCgBA,SAASiT,GAAcjT,EAAQkT,GAE3B,OADQlT,EAAOhP,SAAS,MACjBgP,EAAOhP,SAAS,UAC3B,CCrBA,SAASmiB,GAAkBvT,GACvB,MAGMW,ECSV,SAA2BX,GAGnB,GADcA,EAAStI,SAAS,QAK5B,MAAO,OAGRqI,GAAaC,GACpB,MACM9J,EADW8J,EAASjP,MAAM,KAAKmE,OAAM,GAAI,GACxBnE,MAAM,KACbmF,EAAMhB,OAAM,GAAI,GAChC,MAAMse,EAAUtd,EAAMhB,OAAM,GAAI,GAChC,MAAgB,SAAZse,EACO,QAGK,WAAZA,EACO,eAEK,WAAZA,EACO,eAEK,UAAZA,EACO,mBADX,CAIJ,CDtCqBC,CAAkBzT,GAc7B0T,EAAW,CACb1T,WACAW,WACAc,MAhBWjB,GAEC,gBAARA,EACoB,iBAAbG,GAA4C,SAAbA,EAE9B,gBAARH,EACoB,iBAAbG,EAEC,sBAARH,EACoB,UAAbG,OADX,EASAD,WArBgBN,GAAWsT,EAAStT,SAAWA,GAC9CsT,EAASxS,oBACLyS,GAAmBD,EAAS1T,WAoCzC,SAA+BI,EAAQwT,GAC3BxT,EAAO1I,SAAS,KAChBkc,EAAoBlc,SAAS,KAC9Bmc,GAAkBD,GACzB,MAAME,EAAiB5e,EAAM0e,EAAoB7iB,MAAM,KAAM,GAAG,GAC3DG,OAAQ6iB,GAAwC,aAApBA,GAC5BxiB,KAAK,KACV,OAAO6O,EAAO/O,WAAWyiB,EAC7B,CA5CsDE,CAAsB5T,EAAQsT,EAAS1T,WAoBrFkB,kBAAmB2S,GAAkB7T,GACrCoB,mBAAiC,SAAbT,GAAuBkT,GAAkB7T,IAAa2T,GAAmB3T,GAC7FiU,gBAAiBZ,GAAcrT,GAC/BI,OAAQ+S,GAAmBnT,IAE/B,OAAO0T,CACX,CACA,SAASG,GAAkB7T,GACvB,OAAIqT,GAAcrT,IAGXA,EAAS5O,SAAS,YAC7B,CACA,SAASuiB,GAAmB3T,GACxB,OAAOA,EAAS5O,SAAS,aAC7B,CEzCA,MAAM8iB,GAAwB,CAE1B,kBAEA,kBAGEC,GAA4B,CAAC,MAAO,QCJ1C,SAASC,GAA2BC,EAAuBC,GAEvD,MAAMpR,EAAcmR,EAAsBpb,IAAKsb,IAC3C,MAAMlP,EAAemP,GAA4BD,EAAqBE,yBAa9E,SAAgCpP,GAC5B,MAAMzB,EAAa,QACbc,EAAcW,EAAazB,GACjC,IAAKc,EACD,OACJ,MAAMhT,MAAEA,EAAA4R,cAAOA,GAAkBoB,EAC3BgQ,SAAyBhjB,EAEzBwT,ErCvBV,SAA4BvB,EAAeC,EAAYN,GACnD,MAAO,GAAGO,GAAMF,EAAeC,SAAkBE,GAAmBR,EAAeM,IACvF,CqCqB4B+Q,CAAmB,SAAU/Q,EAAYN,GACjEpR,EAAgC,WAApBwiB,GAAgChhB,EAAWhC,GAAQ,GAAGwT,0BAAwCwP,8EAS9G,CA9BQE,CAAuBvP,GAEvB,OADmBxH,EAAAoO,EAAA,GAAKsI,GAAL,CAA2BlP,mBAI5CyB,EAAmB,CAAEzB,aAAc,IACzC,CACI,MAAMA,EAAemP,GAA4BF,EAA2BG,wBAC5EngB,OAAO6Z,OAAOrH,EAAiBzB,aAAcA,EACjD,CACA,MAAO,CAAEnC,cAAa4D,mBAC1B,CAoBA,SAAS0N,GAA4BC,GACjC,MAAMpP,EAAe,GA6BrB,OA5BA/Q,OAAOiT,QAAQkN,GAAwBzd,QAAQ,EAAE4M,EAAYiR,MACzD,IAAInQ,EACJ,GAAmC,eAA/BmQ,EAAsB5gB,KAAuB,CAC7C,MAAuC5F,KAA/BymB,mBAA+BzmB,EAAX0mB,EAAAnV,EAAWvR,EAAX,CAApB,oBACFqD,EAAQojB,EAAgB7b,IAAI,CAAC+b,EAAwBpd,KACvD,MAAQlG,oBAAOujB,GAAgBC,GAAqBF,EAAwBpR,EAAY,IAC9DiR,EAAsBvR,cAAc1L,IAK9D,OADAud,EAAeF,GACRvjB,IAEXgT,EAAcuH,GAAEva,SAAUqjB,EAC9B,KACK,CACD,MAAuCpV,KAA/BmV,mBAA+BnV,EAAXoV,EAAAnV,EAAWD,EAAX,CAApB,qBACFjO,MAAEA,EAAAujB,YAAOA,GAAgBC,GAAqBJ,EAAiBlR,EAAY,KACtEiR,EAAsB5gB,KAC7B,MAAMqP,cAAEA,GAAkBuR,EAE1B,OADsB/mB,MAAM+F,QAAQyP,GAAiBA,EAAc,GAAKA,IAG5E6R,EAAeF,GACfvQ,EAAcuH,GAAEva,SAAUqjB,EAC9B,CACA1P,EAAazB,GAAcc,IAExBW,EACP,SAAS8P,EAAeF,GACpBA,EAAYje,QAASoe,IACjB,MAAMxR,WAAEA,EAAAc,YAAYA,GAAgB0Q,EAC/B/P,EAAazB,KACdyB,EAAazB,GAAcc,IAOvC,CACJ,CACA,SAASwQ,GAAqBJ,EAAiBlR,EAAYyR,GACvD,GAA6B,kBAAzBP,EAAgB7gB,KAA0B,CAC1C,IAAIvC,MAAEA,GAAUojB,EAEhB,OADApjB,EAAQ4jB,EAAe5jB,GAChB,CAAEA,QAAOujB,YAAa,GACjC,CACA,GAA6B,mBAAzBH,EAAgB7gB,KAA2B,CAC3C,MAAMvC,MAAEA,GAAUojB,EAClB,MAAO,CAAEpjB,QAAOujB,YAAa,GACjC,CACA,GAA6B,cAAzBH,EAAgB7gB,KAAsB,CACtC,MAAMshB,EAAgBF,KAChBG,aAAEA,GAAiBV,EAGzB,IAAIpjB,EAFI6jB,EAAchS,UDvF9B,SAA8B8J,EAAa7J,EAAsBI,GAC7D,MAAM2L,EAAcjb,OAAO4J,KAAKmP,GAC1BoI,EAAWpR,GAA8B,YAAfA,GAA4BA,IAAeT,EAErE8R,EAAmBnG,EAAYre,OAAOukB,GACtCE,EAAgBvmB,EAAGwmB,KAAK,kBACxBC,EAAczmB,EAAGwmB,KAAK,YAAYhS,OACR,IAA5B8R,EAAiBvmB,QACjB+C,GAAY,EAAO,GAAGsR,mBAAsCqS,QAAkBF,KAElD,IAA5BD,EAAiBvmB,QACjB+C,GAAY,EAAO,GAAGsR,0BAA6CmS,QAAoBE,KAEpFH,EAAiBvmB,OAExB,MAAM2mB,EAAqBvG,EACtBre,OAAQmI,IAAOoc,EAAQpc,IACvBnI,OAAQmT,IAAgB6P,GAAsB9iB,SAASiT,IACvD8P,GAA0B/Z,KAAM6F,GAAQuD,EAAqB9L,SAASuI,KACvE6V,EAAmB9e,QAAS+e,IACxB7mB,GAAc,EAAO,GAAGsU,gBAAmCpU,EAAGqE,KAAK,YAAYsiB,+CAA4D,CACvIxmB,UAAU,KAI1B,CC+DQymB,CAAqBR,EAAcD,EAAc/R,qBAAsBI,GAGvE,MAAMqR,EAAc,GAyBpB,OAxBA3gB,OAAOiT,QAAQiO,GAAcxe,QAAQ,EAAEqN,EAAYoC,MACX,YAAfpC,GAA4BA,IAAeT,EAQ5DqR,EAAYjjB,KAAK,CACb4R,WAAYS,EACZK,YAAa,CACTzQ,KAAM,WACNvC,MAAO+U,EACPnD,cAAe,CACXE,qBAAsB+R,EAAc/R,qBACpCW,2BAA4B,CAACE,OAbzC3S,EAAQ+U,IAqBT,CAAE/U,QAAOujB,cACpB,CAEJ,CC3HA,SAASgB,GAAmCC,GACjCpiB,EAAQoiB,EAA+B,gBAAiB,UACxDpiB,EAAQoiB,EAA+B,iBAAkB,UACzDpiB,EAAQoiB,EAA+B,2BAA4B,UACnEpiB,EAAQoiB,EAA+B,4BAA6B,UACpEpiB,EAAQoiB,EAA8BC,cAAe,SACrDriB,EAAQoiB,EAA8BC,cAAe,iBACxDriB,EAAQoiB,EAA8BC,cAAe,gBAClDriB,EAAQoiB,EAA+B,gBAAiB,YACxDpiB,EAAQoiB,EAA+B,yBACvCpiB,EAAQoiB,EAA+B,8BAC9C,MAAQ7B,wBAAuBC,8BAA+B4B,GAoElE,SAAqC7B,GAEjCA,EAAsBrd,QAASud,IAEpBzgB,EAAQygB,EAAsB,SAAU,UACxCzgB,EAAQygB,EAAsB,mBAC9BzgB,EAAQygB,EAAsB,2BAE7C,CA3EI6B,CAA4B/B,GA4EhC,SAA0CC,GAC/BxgB,EAAQwgB,EAA4B,yBAC/C,CA7EI+B,CAAiC/B,GACjC,MAAMpR,YAAEA,EAAA4D,iBAAaA,GAAqBsN,GAA2BC,EAAuBC,GACtFgC,EAAe,GACrBC,GAAgBL,EAA8BC,eAAenf,QAAQ,EAAGgJ,WAAU0T,WAAU8C,sBACxF9C,EAAW4C,EAAatW,GAAY,OAAA3R,EAAAioB,EAAatW,IAAb3R,EAA0BqlB,EAC9D,MAAM+C,EAAaD,EAEnB9C,EAASgD,SAAW,IAAYjL,EAAAC,KAAA,iBACtB,gBAAiBgI,IACnBA,EAASrG,kBAAoBoJ,IPvB7C,SAA4B/C,GACxBT,GAAYjc,QAASqN,IAEjB,GADOqP,EAASrG,cACVhJ,KAAcqP,EAASrG,aACzB,OACJ,MAAMsJ,EAAY,kBAAkBtS,sCACpCnS,GAAiD,IAArCwhB,EAASrG,YAAYhJ,GAAuB,GAAGqP,EAAS1T,2BAA2BqE,yEAAkFA,mBAA4BsS,MAC7MzkB,GAAiD,IAArCwhB,EAASrG,YAAYhJ,GAAsB,GAAGqP,EAAS1T,2BAA2BqE,iCAA0CsS,MAEhJ,COegBC,CAAmBlD,GAE3B,KAEJ6C,GAAgBL,EAA8BW,0BAA0B7f,QAAQ,EAAGgJ,WAAU0T,WAAU8C,sBACnG9C,EAAW4C,EAAatW,GAAY,OAAA3R,EAAAioB,EAAatW,IAAb3R,EAA0BqlB,EAC9D,MAAM+C,EAAaD,EAEnB9C,EAASlE,gBAAkB,IAAY/D,EAAAC,KAAA,iBACnC,KAAM,gBAAiBgI,GAAW,CAC9B,MAAMoD,QAAsBL,IACrB3iB,EAAQgjB,EAAe,cAAe,YAAapD,EAAS1T,SACnE0T,EAASnE,YAAcuH,EAAcvH,WACzC,CACJ,KAGJgH,GAAgBL,EAA8Ba,gBAAgB/f,QAAQ,EAAGgJ,WAAU0T,WAAU8C,sBAEzF,MAAMM,EAAgBN,GADtB9C,EAAW4C,EAAatW,GAAY,OAAA3R,EAAAioB,EAAatW,IAAb3R,EAA0BqlB,GAGrDrG,YAAcyJ,IAE3BP,GAAgBL,EAA8Bc,2BAA2BhgB,QAAQ,EAAGgJ,WAAU0T,WAAU8C,sBACpG9C,EAAW4C,EAAatW,GAAY,OAAA3R,EAAAioB,EAAatW,IAAb3R,EAA0BqlB,EAC9D,MAAMoD,EAAgBN,EAEf1iB,EAAQgjB,EAAe,cAAe,YAAapD,EAAS1T,SACnE0T,EAASnE,YAAcuH,EAAcvH,cAEzC2G,EAA8Be,cAAcjgB,QAASgJ,UACjDsW,EAAatW,GAAY,OAAA3R,EAAAioB,EAAatW,IAAb3R,EAA0BklB,GAAkBvT,KAEzE,MAAMG,EAAe7L,OAAOC,OAAO+hB,GAInC,OAHAnW,EAAanJ,QAAQ,EAAGgJ,eACZA,EAAS5O,SAAS,QAEvB,CAAE+O,eAAc+C,cAAa4D,mBACxC,CACA,SAASyP,GAAgBW,GACrB,MAAMre,EAAM,GAWZ,OAVAvE,OAAOiT,QAAQ2P,GAAYlgB,QAAQ,EAAE2J,EAAUwW,MAI3C7iB,OAAOiT,QAAQ4P,GAAWngB,QAAQ,EAAEgJ,EAAUwW,MAC1C,MAAM9C,EAAWH,GAAkBvT,GAC5B0T,EAAS/S,SAChB9H,EAAI7G,KAAK,CAAEgO,WAAU0T,WAAU8C,kBAGhC3d,CACX,CCpDA,SAASue,GAAcC,GAQnB,MAPqB,CACjBlR,OAAQkR,EAAelR,OAEvBmR,QAASD,EAAeE,OACxBC,SAAUH,EAAeI,QACzBC,MAAOL,EAAetpB,KAG9B,CACA,SAAS4pB,IAAwBC,uBAAEA,EAAAC,iBAAwBA,IAEvD,OAAOC,GAA6B,CAAEzS,aADjB4G,OAAK2L,GAA2BC,IAEzD,CACA,SAASE,GAAyBC,EAClC7U,EACA2D,GACI,MAAMX,EAAS,GACT8R,EAAgB,GAChBzR,EAAa,GAkBnB,IAAI+Q,EACAE,EACA1pB,EACJ,GAlBAiqB,EAAUhhB,QAAS0c,IACf,MAAM8B,EAkMd,SAAyB9B,GACrB,MAAM1T,SAAEA,EAAAqN,YAAUA,GAAgBqG,EAE3B3T,GAAaC,GACpB,MAAMwV,EAAe,GA+BrB,OA9BAlhB,OAAOiT,QAAQ8F,GACVzM,KjDzJT,SAAkB3B,GACd,OAAOK,GAAW4Y,IACd,MAAM/jB,EAAM8K,EAASiZ,GACrB,OAAY,OAAR/jB,EACO,MAGCA,GAGpB,CiD+IcgkB,CAAS,EAAE9T,KAA+B,YAAfA,IAChCrN,QAAQ,EAAEqN,EAAYoC,MACvB,IAAI2R,EAAqC,YAAf/T,EAC1B,GAAI+T,EAAqB,CACrB,I7CpMZ,SAAwBpY,GACpB,OAAOH,GAAazF,KAAM6F,GAAQD,EAAStI,SAAS,IAAMuI,GAC9D,C6CkMgBoY,CAAerY,GAaf,OATA9N,EAAYT,EAASgV,GAAc,OAAOrX,EAAGqE,KAAK,wBAAwBuM,+BAC1E1L,OAAOiT,QAAQd,GAAazP,QAAQ,EAAEshB,EAAmBC,ORpPzE,SAA8BD,EAAmBtY,GAC7C9N,GAAaghB,GAAwB9hB,SAASknB,GAAoB,GAAGtY,4BAAmCsY,6CAA6DA,iBACzK,CQmPoBE,CAAqBF,EAAmBtY,GACxCwV,EAAaxjB,KAAK,CACdqS,WAAYiU,EACZ7R,YAAa8R,EACbH,0BATR/T,EAAa,MAcrB,CACAmR,EAAaxjB,KAAK,CACdqS,aACAoC,cACA2R,0BAGR5C,EAAaxe,QAAQ,EAAGqN,aAAY+T,6BAG7B5C,CACX,CAtO6BiD,CAAgB/E,GACrC8B,EAAaxe,QAAQ,EAAGqN,aAAYoC,cAAa2R,gCAE7C5R,EAAWnC,GAAc,OAAAhW,EAAAmY,EAAWnC,MAAe,GACnDmC,EAAWnC,GAAYrS,KAAK,CACxByU,cACAiS,aAAc,GAAGhF,EAAS1T,cAAcoY,EAAsB,sBAAsB/T,QAAmB,cAAcA,UACrHrE,SAAU0T,EAAS1T,SACnB2Y,UAAWjF,EAAS1T,SACpB4Y,UAAWlF,EAAS/S,SACpBkY,qBAAsBT,QAO9BjV,EAAY,CACZ,MAAM0M,EAAM8H,GAAwB,CAChCC,uBAAwB9Q,EAAiBzB,aACzCwS,iBAAkB1U,EAAWkC,eAEjCkS,EAAS1H,EAAI0H,OACbE,EAAU5H,EAAI4H,QACd1pB,EAAO8hB,EAAI9hB,KACXuG,OAAO6Z,OAAOhI,EAAQ0J,EAAI1J,QAC1B7R,OAAO6Z,OAAO8J,EAAepI,EAAIoI,eACjC3jB,OAAO6Z,OAAO3H,EAAYqJ,EAAIrJ,WAClC,MAEI+Q,EAAS,GACTE,EAAU,GACV1pB,EAAO,CACH+qB,gBAAiB,GACjBC,kBAAmB,GACnBC,gBAAiB,IAGzB,MAAMC,EAAc,GACdhT,EAAU,GAChB3R,OAAOiT,QAAQf,GAAYxP,QAAQ,EAAEqN,EAAY9P,MAC7CA,EAAOyC,QAAQ,EAAGyP,cAAamS,YAAWC,iCACtC5S,EAAQ5B,GAAc,OAAAhW,EAAA4X,EAAQ5B,IAARhW,EAAuBoY,EAE3B,UAAdmS,GAA0BC,GACpBxU,KAAc4U,IAChBA,EAAY5U,GAAcoC,OAO1C,MAAMyS,EAAsB,CACxB/S,SACApY,OACAwpB,SACAE,UAEAQ,gBACAhS,UACAO,cAiBJ,OAdA9G,GAAqBwZ,EAAqB,cAAe,CACrD5c,IAAK,KAEIpJ,KACDhE,GAAc,EAAO,uEAAwE,CACzFK,UAAU,EACVC,gBAAgB,IAGjBypB,GAEXxb,YAAY,EACZ0b,cAAc,IAEXD,CACX,CACA,SAASE,GAA2BlW,EAAa4D,GAC7C,MAAMuS,EAGV,SAAmCnW,EAAa4D,EAAkBwS,GAE9D,MAAM1B,EAAyB0B,EAAgBxS,GAAkB,GAE3DyS,EAAyBnC,GADCU,GAA6B,CAAEzS,aAAcuS,KAGvE4B,EAAQllB,OAAOqW,YAAYzH,EAAYjK,IAAKkK,IAC9C,MAAM0U,EAAmByB,EAAgBnW,GACzC,OAvIR,SAAuCyU,EAAwBzU,EAAY0U,GACvE,MACM4B,EAAmBrC,GADCO,GAAwB,CAAEC,yBAAwBC,sBAEtE6B,cACF,GAAKvW,EAAW+L,YAQZ,OAAOrR,OACA4b,GADA,CAEHvK,aAAa,IAVQ,CACzB,MAAMyK,EAAQ,OAAAtrB,EAAAorB,EAAiBtT,OAAOwT,OAAxBtrB,EAAiC8U,EAAWyW,gBAAgBC,YAC1E,OAAOhc,OACA4b,GADA,CAEHE,SAER,CAOJ,KACA,MAAO,CAACxW,EAAW/C,OAAQsZ,EAC/B,CAoHeI,CAA8BlC,EAAwBzU,EAAY0U,MAEvEkC,EAAqBlc,OACpB0b,GADoB,CAEvBC,UAEJ,OAAO3b,OACAkc,GADA,CAEHC,oBAAqBD,GAE7B,CArBkCE,CAA0B/W,EAAa4D,EAAmBzM,GAAMA,EAAEgL,cAChG,OAAOgU,CACX,CAqBA,SAASvB,GAA6B3U,GAClC,MAAMgD,EAAS,GACT8R,EAAgB,GAChBzR,EAAa,GACb+Q,EAAS,GACTE,EAAU,GACV1pB,EAAO,CACT+qB,gBAAiB,GACjBC,kBAAmB,GACnBC,gBAAiB,IAEfkB,EAAS,CAACC,EAAKvW,KACjB2T,EAAO3T,GAAcuW,EACrB,MAAA1C,EAAQ7T,KAAgB6T,EAAQ7T,GAAc,IAC9C6T,EAAQ7T,GAAY5R,KAAKmoB,IAEvBC,EAAY,CAACxW,EAAYlS,EAAO4R,aAClC,MAAM+W,EAAkChX,GAAmCC,GACrE4B,EAAkBxB,GAA2B,SAAUE,EAAYN,GACzE2U,EAAcrU,GAAc,OAAAvV,EAAA4pB,EAAcrU,MAAe,GACzDqU,EAAcrU,GAAY5R,KAAK,CAC3B0S,YAAahT,EACbwT,kBACAoV,oBAAqBD,IAGzB,MAAMhW,EAAaT,EACnB4C,EAAWnC,GAAc,OAAA1E,EAAA6G,EAAWnC,MAAe,GACnDmC,EAAWnC,GAAYrS,KAAK,CACxByU,YAAa/U,EACbgnB,aAAcxT,EACdlF,SAAUqa,EACV1B,UAAW0B,EACXzB,UAAW,KACXC,qBAAsB,QA6C9B,OA1CAvkB,OAAOiT,QAAQpE,EAAWkC,cAAcrO,QAAQ,EAAE4M,EAAYc,YAC1D,MAAMhT,MAAEA,GAAUgT,EAElB,GADAyB,EAAOvC,GAAc,OAAAvV,EAAA8X,EAAOvC,IAAPvV,EAAsBqD,EAClB,aAArBgT,EAAYzQ,KAAqB,CACjC,MAAMkmB,EAAM,CACRlmB,KAAM,kBACNvC,MAAOgT,EAAYhT,MACnBsS,UAAWF,GAAmBY,EAAYpB,cAAeM,IAE7DsW,EAAOC,EAAKvW,GACZ7V,EAAK+qB,gBAAgBlV,GAAcuW,EACnCC,EAAUxW,EAAYlS,EAAOgT,EAAYpB,cAC7C,CACA,GAAyB,eAArBoB,EAAYzQ,KAAuB,CACnC,MAAMkmB,EAAM,CACRlmB,KAAM,oBACN+P,UAAWF,GAAmBY,EAAYpB,cAAeM,GACzDrP,OAAQmQ,EAAYhT,MAAMuH,IAAI,CAACvH,EAAOkG,KAClC,MAAM2d,EAAgB7Q,EAAYpB,cAAc1L,GAE1CoM,EAAYF,GAAmByR,EAAe3R,GAEpD,OADAwW,EAAUxW,EAAYlS,EAAO6jB,GACtB,CACH7jB,QACAsS,gBAIZkW,EAAOC,EAAKvW,GACZ7V,EAAKgrB,kBAAkBnV,GAAcuW,CACzC,CACA,GAAyB,aAArBzV,EAAYzQ,KAAqB,CACjC,MAAMkmB,EAAM,CACRlmB,KAAM,kBACN+P,UAAW,OACXtS,MAAOgT,EAAYhT,OAEvBwoB,EAAOC,EAAKvW,GACZ7V,EAAKirB,gBAAgBpV,GAAcuW,EACnCC,EAAUxW,EAAYlS,EAAOgT,EAAYpB,cAC7C,IAEG,CACH6C,SACA8R,gBACAzR,aACA+Q,SACAE,UACA1pB,OAER,CC1OA,SAAewsB,GAA0BrE,EAA+BxnB,EAAc8rB,EAEtFC,EAAqBC,GAAuB,OAAAjP,EAAAC,KAAA,uBACxC,MAAMiP,mCAAEA,GAAuCjsB,GACzC0N,QAAEA,EAAAX,QAASA,GAAYH,GAAW,CAKpCC,QAAS,OAEb7M,EAAaisB,mCAAqCve,EAC9Cue,IACOjsB,EAAa6b,oBACdoQ,GAEV,MAAMpQ,EA6CV,SAAiC2L,GAC7B,MAAM/V,aAAEA,EAAA+C,YAAcA,EAAA4D,iBAAaA,GAAqBmP,GAAmCC,GACrF0E,EAoBV,SAAuBza,EAAc+C,GACjC,MAAM2X,EAAU1a,EAAajP,OAAO,EAAGgQ,wBAAyBA,GAAmBjI,IAAI,EAAGmH,YAAaA,GACjGwa,EAAahtB,EAAOitB,GACpBC,EAAc5X,EAAYjK,IAAKpB,GAAMA,EAAEuI,QAC7C,MAAO,IAAIwa,KAAeE,EAC9B,CAzBuBC,CAAc5a,EAAc+C,GACzCmW,EAAwBD,GAA2BlW,EAAa4D,GAChEyD,EAAgB0B,EAAA,CAMlB+O,iBAAiB,EACjBjmB,mBAAmB,EACnBkmB,+BAAgC/E,EAChChJ,cAAe/M,EACfgN,aAAcjK,EACdgY,kBAAmBpU,EACnBqU,YAAaP,GACVvB,GAGP,OADA7b,GAAiB+M,EAAe,qBAAqB,GAC9CA,CACX,CAlE0B6Q,CAAwBlF,GAC9C,IAAImF,EAUJ,GATK3sB,EAAa6b,cAOd8Q,GAAqB,GAJrB3sB,EAAa6b,cAAgBA,EAC7B8Q,GAAqB,GAKrBb,GAEAjQ,EAAc4C,aAAahe,OAAS,EAAG,CAEvCyF,EAAa2V,EADc,MAAAiQ,OAAA,EAAAA,EAAmBjQ,GAElD,KACK,CAED3V,EAAa2V,QADoB,MAAAkQ,OAAA,EAAAA,EAAsBlQ,GAE3D,CAGI3V,EAAa2V,QADyB,MAAAmQ,OAAA,EAAAA,EAAwBnQ,IAGlE,MAAM+Q,EAA6BrU,GAAsCsD,EAAc2Q,kBAAmB,yBAC1G,IAAIK,GAAc,ECpDf,IAAuBC,EAAQC,EDqElC,OA8BJ,SAAuBC,EAAQC,GAC3B,MAAMC,EAAWF,EAAOziB,IAAK6S,GAASA,EAAKxF,QACrCuV,EAAWF,EAAO1iB,IAAK6S,GAASA,EAAKxF,QAC3C,OAAQsV,EAASxnB,MAAO0X,GAAS+P,EAASzqB,SAAS0a,KAE/C+P,EAASznB,MAAO0X,GAAS8P,EAASxqB,SAAS0a,GACnD,CApDSgQ,CAAc,OAAAztB,EAAAK,EAAa4sB,4BAAbjtB,EAA2C,GAAIitB,KAC9D5sB,EAAa4sB,2BAA6BA,QpB9BlD,SAA8B9V,EAAUsB,EAAkBf,EAAagW,EAAS9O,GAAuB,OAAAxB,EAAAC,KAAA,iBACnG,MAAM9E,EAAQK,GAAsCH,EAAkBtB,GAChEwW,EAAwB/O,EAAsB8O,SAC9ChhB,QAAQ8Q,IAAIjF,EAAM3N,IAAW6S,GAASL,EAAAC,KAAA,uBAClCM,GAAoB,IAAMF,EAAKxF,OAAO0V,GAAwBlQ,EAAM/F,EAC9E,IACJ,GoByBckW,CAAe,wBAAyB1R,EAAc2Q,kBAAmB,KAAM3Q,EAAeD,IACpGiR,GAAc,GAEdF,IAEIE,GC5DkBC,ED6DJ9sB,EAAa6b,cC7DDkR,ED6DgBlR,EC5DlDjW,OAAO4J,KAAKsd,GACPtqB,OAAQrB,IAAQ,GAChBmH,QAASnH,UAAe2rB,EAAO3rB,IACpCyE,OAAOU,iBAAiBwmB,EAAQlnB,OAAOW,0BAA0BwmB,KD6DzD7mB,EAAalG,EAAa6b,cAAeA,GAAe,IAGhE9O,IACO/M,EAAa6b,aACxB,GE7DA,MAAM7b,GAAeT,EAAgB,gDACjC,MAAQmO,QAAS8f,EAA6BzgB,QAAS0gB,GAAuC7gB,KAC9F,MAAO,CACH4gB,8BACAC,qCAER,EANqC,IAOrC,SAAeC,KAAuC,OAAA3Q,EAAAC,KAAA,iBAElD,GAAIhd,GAAa2tB,qBAAsB,CAEnC,aAD4B3tB,GAAa2tB,oBAE7C,CAEA,MAAMA,EAAuB9B,GAA0B7rB,GAAawnB,8BAA+BxnB,GAAc,KAC7G,MAAM2qB,EAAwB,CAQ1BiD,cAAc,GAGlB,OADA1nB,EAAaykB,ErDlBqBjb,GuCfC,uBckC5Bib,IAEX3qB,GAAa2tB,qBAAuBA,EACpC,MAAM9R,QAAsB8R,EAI5B,OAHO3tB,GAAa6b,cACpB7b,GAAaytB,qCAEN5R,CACX,GCSA,SAASgS,GAAkB1M,EAAKrV,GCnDzB,IAAmBrG,EDoDtBjF,ICnDsB,iBADAiF,EDoDG0b,ICnDiB,OAAR1b,GAAgB,SAAUA,GAAOT,EAAWS,EAAI2Y,ODmDnD,GAAGtS,wJAAiK,CAAEjL,UAAU,GACnN,CAEA,SAASitB,KAELttB,GAAc,EAAO,GADJE,EAAGqE,KAAK,+GACuE,CAAElE,UAAU,GAChH,CACA,SAASktB,GAAkBC,EAAQliB,GACxBA,EAAU9C,SAAS,WACrB5D,EAAQ4oB,EAAQ,iBAGdliB,EAAU9C,SAAS,WAC1BxF,EAAY4B,EAAQ4oB,EAAQ,cAAe,YAAa,GAAGliB,yCAC/D,CEzDA,SAAemiB,GAEfxc,EAAc+C,EAAa4D,EAAkB8T,GAAY,OAAAnP,EAAAC,KAAA,iBAGrD,aADM3Q,QAAQ8Q,IAAI1L,EAAajP,OAAQ2G,GAAqB,gBAAfA,EAAE8I,UAA4B1H,IAAKpB,UAAM,cAAAxJ,EAAAwJ,EAAE6e,eAAF,EAAAroB,EAAAskB,KAAA9a,MAG1F,SAEAsI,EAAc+C,EAAa4D,EAAkB8T,GACzC,MAAMgC,kBAAEA,EAAAC,gBAAmBA,GAkI/B,SAAwB1c,EAAc+C,EAAa4D,GAE/C,GAAI5D,EAAY/T,OAAS,EAAG,CAExB,MAAO,CAAEytB,kBADI/V,GAA4BC,EAAkB,iBACzB+V,gBAAiB,KACvD,CAGA,IAAID,EAAoB,KACxB,MAAMC,EAAkB,GAyBxB,OAxBA1c,EACKjP,OAAQ2G,GAAqB,gBAAfA,EAAE8I,UAA8B9I,EAAEqJ,mBAChDlK,QAAQ,EAAGgJ,WAAUqN,kBAEtB,GAAI,kBAAmBA,EAAa,CAChCnb,EAAY4B,EAAQuZ,EAAa,gBAAiB,YAAa,mCAAmCrN,2BAClG,MAAM8c,cAAEA,GAAkBzP,EACpB7H,EAAW,gBACjBoX,EAAoB,CAChBnX,aAAczF,EACdsG,OAAQwW,EACRtX,WACAY,YAAac,GAAsB1B,GAE3C,CACI,0BAA2B6H,IAC3Bnb,EAAY4B,EAAQuZ,EAAa,wBAAyB,UAAW,2CAA2CrN,yBAChH9N,EAAY4B,EAAQuZ,EAAa,wBAAyB,UAAW,2CAA2CrN,WAAkBqN,EAAY0P,4EAC9IF,EAAgB7qB,KAAK,CACjBgrB,eAAgBC,GAAQjd,GACxBkd,QAAS7P,EAAY0P,2BAI1B,CAAEH,oBAAmBC,kBAChC,CArKmDM,CAAehd,EAAc+C,EAAa4D,GACnFsW,EAGV,SAAuBP,EAAiB1c,EAAc+C,EAAa0X,GAC/D,MAAMwC,EAAa,GAEnB,GAAIla,EAAY/T,OAAS,EAAG,CAExB,MAAMkuB,GAAwB,EAC9Bna,EACKhS,OAAQ2G,IAAOA,EAAEqX,aACjBlY,QAASmM,IACV,MAAM/C,EAAS+C,EAAW/C,OAC1B,IAAIkd,EAAY,KAChB,CACI,MAAM1Z,EAAa,QACbc,EAAcU,GAAsBjC,EAAYS,GACtD,GAAIc,EAAa,CACb,MAAMiV,EAAQjV,EAAYhT,MACnBgT,EAAYpB,cACnB,MAAMS,EAAkBD,GAAmBY,EAAYpB,cAAeM,GACtE,GAAqB,iBAAV+V,EACP2D,EAAY,CACRld,SACAid,wBACAxD,YAAaF,EACb4D,qBAAsBxZ,EACtByZ,UAAW,cAGd,CACD,MAAMla,cAAEA,GAAkBoB,GAClB7Q,EAAQyP,IAAmBA,EAAcC,UACjD,MAAMC,qBAAEA,GAAyBF,EAI7B8B,GAAsBjC,EAAY,gDAAiD,YACnFqZ,KACJc,EAAY,CACRld,SACAid,wBACAI,cAAe9D,EACf+D,sBAAuBla,EACvB+Z,qBAAsBxZ,EACtByZ,UAAW,WAEnB,CACJ,CACJ,CACA,IAAKF,EAAW,CACZ,MAAM1D,gBAAEA,GAAoBzW,GAEtB0W,YAAEA,EAAA8D,kBAAaA,GAAsB/D,EACpCA,EAAgBC,YAAYxoB,WAAW,KAC9CisB,EAAY,CACRld,SACAwd,yBAA0BD,EAC1BN,wBACAxD,cACA0D,qBAAsB,KACtBC,UAAW,aAEnB,CAEAJ,EAAWprB,KAAKsrB,IAExB,CAGA,GAA2B,IAAvBpa,EAAY/T,OAAc,CAE1B,MAAMkuB,GAAwB,EAC9BzC,EACK1pB,OAAQkP,IAAYiT,GAAcjT,IAClCpJ,QAASoJ,IACV,MAAMgN,EAAgBjN,EAAaiD,KAAMvL,GAAMA,EAAEuI,SAAWA,GAAyB,gBAAfvI,EAAE8I,UACxE,GAAKyM,GAAmB,YAAaA,EAAcC,YAa9C,CACD,MAAMrN,SAAEA,EAAAqN,YAAUA,GAAgBD,EAElC,GADOC,EAAYwQ,QACf/pB,EAAQuZ,EAAa,UAAW,UAAW,CAC3C,MAAMwM,EAAcxM,EAAYwQ,QAShC,OARA3rB,EAAY2nB,EAAYxoB,WAAW,KAAM,4DAA4D2O,2BAAkC6Z,yCAAmDA,sBAC1LuD,EAAWprB,KAAK,CACZoO,SACAid,wBACAxD,cACA0D,qBAAsBvd,EACtBwd,UAAW,UAGnB,CACA,GAAI1pB,EAAQuZ,EAAa,UAAW,YAAa,CAC7C,MAAMoQ,EAAgBpQ,EAAYwQ,QAEb,kDACDxQ,GACZmP,KAWR,YARAY,EAAWprB,KAAK,CACZoO,SACAid,wBACAI,gBACAC,sBAAuB1d,EACvBud,qBAAsBvd,EACtBwd,UAAW,YAGnB,CACAtrB,GAAY,EAAO,yBAAyB8N,sCAChD,KA/CiE,CAC7D,MAAM6Z,EC/FtB,SAA6CzZ,EAAQyc,GAEjD,MAGMiB,EAHuBjB,EACxB3rB,OAAO,EAAG8rB,oBAAqB5c,EAAO/O,WAAW2rB,IACjDpc,KAAK5B,GAAY,EAAGge,oBAAqBA,EAAe7tB,SACzB,GACpC,IAAI4uB,EACJ,GAAID,EAAQ,CAGR,MAAMd,eAAEA,EAAAE,QAAgBA,GAAYY,EAE7BZ,EAAQ7rB,WAAW,MAAQ+O,EAAO/O,WAAW,MAAQ2rB,EAAe3rB,WAAW,KAC/E+O,EAAO/O,WAAW2rB,GACF,MAAnBA,GACQA,EAAetlB,SAAS,KAChCqmB,EAAkB7oB,EAAMkL,EAAQ4c,EAAe7tB,OAAQ,IAGvD4uB,EAAkB3d,EAEf2d,EAAgB1sB,WAAW,KAClC0sB,EAAkBb,GAAWA,EAAQxlB,SAAS,KAAO,GAAK,KAAOxC,EAAM6oB,EAAiB,EAAG,EAC/F,MAEIA,EAAkB3d,EAmBtB,OAjBO2d,EAAgB1sB,WAAW,KAElC0sB,EAAkBA,EACbhtB,MAAM,KACNG,OAAQgI,GAAgB,UAARA,GAA2B,QAARA,GAAyB,UAARA,GACpD3H,KAAK,KAEFwsB,EAAgB3sB,SAAS,UACzB2sB,EAAgBrmB,SAAS,KAC7BqmB,EAAgBrmB,SAAS,YACzBqmB,EAAkB7oB,EAAM6oB,EAAiB,GAAI,IAEzB,KAApBA,IACAA,EAAkB,KAEfA,EAAgB1sB,WAAW,KAC1B0sB,EAAgBrmB,SAAS,KAC1BqmB,CACX,CDkDoCC,CAAoC5d,EAAQyc,GACzDhD,EAAYxoB,WAAW,KACtBwoB,EAAYniB,SAAS,KAC7B0lB,EAAWprB,KAAK,CACZoO,SACAid,wBACAxD,cACA0D,qBAAsB,KACtBK,yBAA0B,GAAGxd,WAC7Bod,UAAW,cAEnB,GAqCR,CACA,OAAOJ,CACX,CAhIuBa,CAAcpB,EAAiB1c,EAAc+C,EAAa0X,GAC7E,MAAO,CAAEwC,aAAYR,oBACzB,CARWsB,CAAmB/d,EAAc+C,EAAa4D,EAAkB8T,EAC3E,GA0KA,SAASqC,GAAQjd,GACNA,EAAS3O,WAAW,KACnB2O,EAAStI,SAAS,KAC1B,MACMymB,EAAUjpB,EADF8K,EAASjP,MAAM,KACA,MAAOQ,KAAK,MAAQ,IAGjD,OAFO4sB,EAAQ9sB,WAAW,KAClB8sB,EAAQzmB,SAAS,KAClBymB,CACX,CE9LA,SAAeC,KAAiC,OAAA3S,EAAAC,KAAA,iBAC5C,MAAMnB,QAAsB6R,KAE5B,OADAxnB,EAAa2V,QAIjB,SAAgCA,GAAe,OAAAkB,EAAAC,KAAA,iBAC3C,MAAM0R,WAAEA,EAAAR,kBAAYA,SAA4BD,GAAepS,EAAc2C,cAAe3C,EAAc4C,aAAc5C,EAAc2Q,kBAAmB3Q,EAAc4Q,aACvK,MAAO,CACHkD,YAAajB,EACbkB,mBAAoB1B,EAE5B,GAVsCpC,CAAiBjQ,IAC5CA,CACX,GCFA,SAAegU,GAA4BxO,GAAa,OAAAtE,EAAAC,KAAA,iBACpD,MAAMnB,QAAsB6T,KAErBjmB,ECNY,KDOnB,MAAMqmB,EEHV,WACI,MAAMzY,EAAc,CAChBhR,mBAAmB,EACnB0pB,eAAe,GAGnB,OADAjhB,GAAiBuI,EAAa,qBAAqB,GAC5CA,CACX,CFJ+B2Y,GAC3B9pB,EAAa4pB,EAAoB,CAC7BlC,cAAc,EACdxU,gBAAgB,EAChBiI,cACA5E,eAAgBZ,EAChB2C,cAAe3C,EAAc2C,cAC7BqF,YAAa,KACbzE,YAAa,KACb0E,YChBe,MDsBnB,OAHA5d,EAAa4pB,ElBdjB,SAAmCzY,GACjBA,EAAYgK,YAC1B3E,GAAsBrF,GACtB,MAAM4Y,EAAyB,GAgB/B,OAfAjf,GAAqBif,EAAwB,cAAe,CACxDriB,IAAKmW,GACLhV,YAAY,EACZ0b,cAAc,IAElBzZ,GAAqBif,EAAwB,MAAO,CAChDriB,IAAKoW,GACLjV,YAAY,EACZ0b,cAAc,IAElBzZ,GAAqBif,EAAwB,YAAa,CACtDriB,IAAKsW,GACLnV,YAAY,EACZ0b,cAAc,IAEXwF,CACX,CkBPmCC,CAA0BJ,IElB7D,SAAiCA,EAAoBzE,GACjDnlB,EAAa4pB,EAAoBzE,EAErC,CFiBiC8E,CAAwBL,EAAoBjU,EAAcyP,qBAEhFwE,CACX,GGxBA,SAASM,GAAe5b,EAAa9C,SACjC,MAAMsc,EAASxZ,EAAYhS,OAAQ2G,GAAMA,EAAEuI,SAAWA,GAC/Csc,EAAOvtB,OAEd,OADmB,OAAAd,EAAAquB,EAAO,IAAPruB,EAAa,IAEpC,CCJA,SAAe0wB,GAAiC5b,EAAY6b,GAAO,OAAAvT,EAAAC,KAAA,iBAC/D,GAAI,sBAAuBvI,EAGvB,OAAOA,EAEX,MAAMjV,SAAEA,EAAA+wB,qBAAUA,GAAyB9b,EAAW+b,2BAKhD7Z,EAKV,SAA0C8Z,GACtC,MAAM9Z,EAAemP,GAA4B2K,EAA4B1K,wBAC7E,OAAOpP,CACX,CARyB+Z,OAJqBH,GAO1C,OAFA3qB,OAAO6Z,OAAOhL,EAAWkC,aAAcA,GACvCzQ,EAAauO,EAAY,CAAEkc,mBAAmB,IACvClc,CACX,GCXA,MAAMmc,GAAW,iBACjB,SAAeC,GAA8Bnf,EAAQD,EAAc+C,EAAa4D,GAAkB,OAAA2E,EAAAC,KAAA,iBAC9F,MAAM8T,EAAsBtf,GAAuBC,EAAcC,GAC3D+C,EAAa2b,GAAe5b,EAAa9C,GAC/C,IAAIqf,EACJ,IAOIA,SAJqB1kB,QAAQ8Q,IAAI,CAC7B1I,GAAc4b,GAAiC5b,MAC5Cqc,EAAoBvmB,IAAKpB,UAAM,cAAAxJ,EAAAwJ,EAAE6e,eAAF,EAAAroB,EAAAskB,KAAA9a,QAEZ,EAC9B,OACOxH,GAOH,MAcR,SAAsBA,GAClB,KAAMA,aAAeH,OACjB,OAAO,EAeX,MAZiC,CAE7B,8CAEA,4CAEA,mCAEA,mCAEA,4BAE4BkK,KAAMslB,GAAMrvB,EAAIsvB,QAAQ5X,cAAc3W,SAASsuB,EAAE3X,eACrF,CAtCY6X,CAAavvB,IACbiE,OAAO6Z,OAAO9d,EAAK,CAAEivB,CAACA,KAAW,IAK/BjvB,CACV,CACA,MAAM6oB,EAAsB,GAG5B,OAFAtkB,EAAaskB,EAAqBnB,GAAyByH,EAAqBC,EAAkB3Y,IAClGlS,EAAaskB,EAAqB,CAAE2G,iBAAkBL,IAC/CtG,CACX,GACA,SAAS4G,GAA4BzvB,GACjC,QAAKA,IAGoB,IAAlBA,EAAIivB,GACf,CCrCA,SAASS,GAAuBpqB,EAAKqqB,GAGzBrqB,EAAItE,WAAW,KACvB,MAAMkF,eAAEA,EAAAR,aAAgBA,EAAAsB,SAAcA,GAAa3B,EAASC,EAAK,KACjE,IAAIsqB,EAAa,GAAG5oB,IAAWd,GAAkB,KAIjD,OAHK,MAAAypB,OAAA,EAAAA,EAAShqB,eACViqB,GAAclqB,GAAgB,IAC3BkqB,EAAW5uB,WAAW,KACtB4uB,CACX,CCPA,SAASC,GAAcC,GACnB,MAAM5nB,EAAO4nB,EAAQC,aAAa,QAClC,OAAiB,OAAT7nB,IACH1C,EAAM0C,IACE,KAATA,K3EmRe5C,E2ElRD4C,G3EmRNlH,WAAW,OAAS6I,EAAcvE,I2ExPlD,SAA4B4C,GACxB,GAAIA,EAAKlH,WAAW,KAChB,OAAO,EACX,GAAIkH,EAAKnH,SAAS,MACd2uB,GAAuBxnB,EAAM,CAAEvC,aAAa,MACxC+pB,GAAuB5sB,OAAOyH,SAASrC,KAAM,CAAEvC,aAAa,IAChE,OAAO,EAEX,OAAO,CACX,CAnCQqqB,CAAmB9nB,IAkB3B,SAAwB4nB,GACpB,MAAM5jB,EAAS4jB,EAAQC,aAAa,UAC9BE,EAAMH,EAAQC,aAAa,OACjC,MAAkB,WAAX7jB,GAAkC,cAAXA,GAAkC,aAAR+jB,GAAsBH,EAAQI,aAAa,WACvG,CArBQC,CAAeL,IACfM,GAAcN,KAuCtB,SAAuB5nB,GACnB,MAAM3C,ENnDa,IMoDZuC,EAAavC,GACpB,MAAMsC,cAAEA,GAAkBxC,EAAS6C,EAAM3C,GACzC,OAAQsC,CACZ,CA3CSwoB,CAAcnoB,KAKvB,SAAoB4nB,GAEhB,GAuCShtB,OAAOwtB,kCApCX,CACD,MAAMC,EAAUT,EAAQC,aAAa,kBACrC,OAAmB,OAAZQ,GAAgC,UAAZA,CAC/B,CALI,OAAO,CAMf,CAZSC,CAAWV,G3E4QpB,IAAuBxqB,C2E3QvB,CAiBA,SAAS8qB,GAAcN,GACnB,MAA6C,UAAtCA,EAAQC,aAAa,YAChC,CCnCA,SAASU,GAAejpB,GACpB,GAAmB,SAAfA,EAAE8I,SACF,MAAO,GAEX,GAAI9I,EAAE0X,YACF,OAAO1X,EAAE0X,YAEN1X,EAAEwV,YAAaxV,EAAEmI,SAExB,OADoB1L,OAAO4J,KAAKrG,EAAEwV,YAEtC,CCRA,SAAS0T,IAAevB,oBAAEA,EAAAwB,oBAAqBA,EAAA5gB,OAAqBA,IAChE,MAAO,CAAE6gB,WACT,WAGQ,GAD4BD,EAAoB5mB,KAAMvC,GAAMA,EAAEuI,SAAWA,GAAyB,UAAfvI,EAAE8I,UAGjF,OAqBRzO,EAHgCstB,EAAoBplB,KAAMvC,GAC/CipB,GAAejpB,GAAGzG,SAAS,WAED,CACjC,wCACA,0DACA,CACI,uEACGouB,EAAoBvmB,IAAI,CAACpB,EAAGD,IAAM,KAAKA,EAAI,OAAOC,EAAEmI,aACzDzO,KAAK,OACTA,KAAK,OA5BQ,EAKX,IAD4ByvB,EAAoB5mB,KAAMvC,GAAMA,EAAEuI,SAAWA,GAAyB,iBAAfvI,EAAE8I,UAEjF,OAAO,EAKX,GAD8B6e,EAAoBplB,KAAMvC,GAAMA,EAAEuI,SAAWA,GAAyB,iBAAfvI,EAAE8I,UAA+BmgB,GAAejpB,GAAGzG,SAAS,WAE7I,OAAO,EAGf,OAAO,CACX,CAtBqB6vB,GAAcztB,gBAqCAgsB,EAAoBplB,KAAMvC,GAC9CipB,GAAejpB,GAAGzG,SAAS,kBAI9C,CCtCA,SAAS8vB,GAAsB/gB,EAAcC,GACzC,IAAIof,EAAsBtf,GAAuBC,EAAcC,GAC/D,MAAM4gB,EAAsB1gB,GAAuBH,EAAcC,IAC3D6gB,WAAEA,kBAAYztB,GAAoButB,GAAe,CAAEvB,sBAAqBwB,sBAAqB5gB,WAC/F6gB,IAEAzB,EAAsBA,EAAoBtuB,OAAQ2G,GAAMA,EAAE4J,MAAM,iBAAmBqf,GAAejpB,GAAGzG,SAAS,WAC9GouB,EA+BR,SAAmCA,GAC/B,MAAM2B,EAAuB,GAC7B,UAAWtpB,KAAK2nB,EAEZ,GADA2B,EAAqBnvB,KAAK6F,GACtBipB,GAAejpB,GAAGzG,SAAS,wBAC3B,MAGR,OAAO+vB,CACX,CAxC8BC,CAA0B5B,IAEpD,MAAM6B,cAAEA,EAAAC,mBAAeA,GCf3B,UAA8B9B,oBAAEA,EAAAwB,oBAAqBA,EAAAC,WAAqBA,EAAAztB,gBAAYA,IAClF,IAAI6tB,EAAgB,GACpB,MAAM/R,EAA0B0R,EAAoB9vB,OAAQ2G,IAAO2nB,EAAoBpuB,SAASyG,IAC1FypB,EAAqB,GAK3B,GAJAA,EAAmBtvB,QAAQwtB,EAAoBvmB,IAAKpB,IAAA,CAASwG,GAAIxG,EAAEmI,SAAUuhB,YAAY,EAAOC,iBAAiB,MAEjHF,EAAmBtvB,QAAQsd,EAAwBrW,IAAKpB,IAAA,CAASwG,GAAIxG,EAAEmI,SAAUuhB,YAAY,EAAMC,iBAAiB,MAEhHP,EACAI,EAAgB7B,EAAoBvmB,IAAKpB,GAAMA,EAAEmI,cAEhD,CAED,MAAMyhB,EAOd,SAA4BjuB,GACxB,OAAOA,EACD,yDACA,wDACV,CAX4BkuB,CAAmBluB,GACvC8tB,EAAmBtvB,KAAK,CAAEqM,GAAIojB,EAAaF,YAAY,EAAOC,iBAAiB,IAC/EH,EAAgB,CAACI,EACrB,CAEA,MAAO,CAAEJ,gBAAeC,qBAC5B,CDJkDK,CAAqB,CAC/DnC,sBACAwB,sBACAC,aACAztB,oBAEJ,MAAO,CAAEytB,aAAYztB,kBAAiB6tB,gBAAeC,qBAAoB9B,sBAAqBwB,sBAClG,CEpBA,SAAeY,GAAqBxhB,EAAQ2F,GAAa,OAAA0F,EAAAC,KAAA,uBFsBzD,SAAyCmW,EAAcC,EAAQC,GAAkC,OAAAtW,EAAAC,KAAAsW,UAAA,UAAxD7hB,EAAcC,GAAQ6hB,6BAAEA,IAC7D,MAAMzC,EAAsBtf,GAAuBC,EAAcC,SAC3DrF,QAAQ8Q,IAAI2T,EAAoBvmB,IAAWpB,GAAM4T,EAAAC,KAAA,uBAC5C7T,EAAE4J,MAAM,gBAAkB5J,EAAE4J,MAAM,2BAInC,OAAApT,IAAEmhB,sBAAF,EAAAnhB,EAAAskB,KAAA9a,EASV,IACJ,GEtCUqqB,CAA0Bnc,EAAYmH,cAAe9M,EAAQ,CAC/D6hB,8BAA8B,IAElC,MAAM9e,EAAa2b,GAAe/Y,EAAYoF,eAAegC,aAAc/M,IACrE+hB,sBAAEA,kBAAuB3uB,GCPnC,SAA2B2P,EAAYhD,EAAcC,eAEjD,GAAI+C,EAAY,CACZ,MAAM3P,EAAkB,OAAAmM,EAAA,YAAsBwD,EAAY,gBAAiB,iBAAnD,EAAA9U,EAA+DqD,QAA/DiO,EAExB,MAAO,CAAEwiB,sBADqB,OAAAC,EAAA,OAAAla,EAAA9C,GAAsBjC,EAAY,wBAAyB,iBAA3D,EAAA+E,EAAuExW,QAAvE0wB,EACE5uB,kBACpC,CACK,CAGD,MAAMytB,WAAEA,EAAAztB,gBAAYA,GAAoB0tB,GAAsB/gB,EAAcC,GAC5E,MAAO,CAAE+hB,uBAAwBlB,EAAYztB,kBACjD,CACJ,CDNuD6uB,CAAkBlf,EAAY4C,EAAYmH,cAAe9M,GAC5G,OAAO+hB,GAAyB3uB,CACpC,GEHA,MAEM8uB,GAAkB,IAOxB,SAASC,GAAmB1I,EAAazhB,IANzC,SAA2ByhB,EAAarf,EAAY,WAChD,IAAIgoB,EAAa,GAAGhoB,kBAA0BioB,GAAU5I,KACxD3nB,EAA4B,KAAhB2nB,EAAoB,GAAG2I,+BAAwCC,GAAU,gBACrFvwB,EAAY,CAAC,IAAK,KAAKd,SAASyoB,EAAY,IAAK,GAAG2I,2BAAoCC,GAAU,WAAWA,GAAU,QACvHvwB,GAAa2nB,EAAYzoB,SAAS,MAAO,GAAGoxB,gBAAyBC,GAAU5I,EAAY9oB,MAAM,MAAMQ,KAAK,gBAChH,CAEImxB,CAAkB7I,GAClB,MAAM8I,EAAWC,GAAiB/I,GAC5BgJ,EAAqBF,EACtB1pB,IAAK6pB,GACFA,EAAQC,MACD,QAEPD,EAAQE,KACD,KAGQF,EAAQG,OC5BpBjqB,QAAQ,yBAA0B,SD8BxCC,IAAKymB,GAAM,IAAIA,MACfnuB,KAAK,IACJ2xB,EAAa,IAAIC,OAAO,IAAIN,QAC5BO,EAAkBhrB,EAAYmQ,MAAM2a,GAS1C,IAAKE,EACD,OAAO,KACX,MAAMC,EAAc,IACbrZ,KAAMsZ,GAAiBF,EAC9B,IAAIG,EAAU,EACd,MAAMC,EAAmBb,EAASzxB,OAAQ4xB,GAAYA,EAAQE,MAAM7zB,OAAS,EAW7E,OAVAwzB,EAAS3rB,QAAQ,CAAC8rB,EAASlrB,KACvB,IAAIzD,EAAMmvB,EAAc1rB,GAIxB,GAHIkrB,EAAQC,QACRM,EAAYP,EAAQC,OAAS5uB,GAE7B2uB,EAAQE,KAAM,CACd,MAAMD,EAAQ,IAAIS,IAAqBD,EAAU,KACjDF,EAAYN,GAAS5uB,CACzB,IAEG,CAAEkvB,cACb,CACA,SAAST,GAAiB/I,GACtB,MAAM8I,EAAW,GACXc,EAAc/D,IAChB,MAAMgE,EAAcf,EAASA,EAASxzB,OAAS,UAC3Cu0B,WAAaT,QACbS,EAAYT,QAAUvD,EAGtBiD,EAAS3wB,KAAK,CAAEixB,OAAQvD,KAG1BxpB,EAAQ2jB,EAAY9oB,MAAM,KAuBhC,OAtBAmF,EAAMc,QAAQ,CAAC0oB,EAAG9nB,KAsDtB,IAAiB+rB,EArDC,IAAN/rB,GACA6rB,EAAW,MAoDNE,EAnDGjE,GAoDIruB,WAxHA,MAwH+BsyB,EAAatyB,WAAWixB,KAnDnEpzB,GAAewwB,EAAEruB,WAAWixB,IAAkB,yBAAyBG,GAAU5I,WAAqB4I,GAAU5I,EAAY9oB,MAAMuxB,IAAiB/wB,KArEvI,gBAqEyK,CAAEhC,UAAU,IACjMozB,EAAS3wB,KAAK,CAAE+wB,MAAOrD,EAAExqB,MAAM,MAGrB,MAANwqB,GAAa9nB,IAAM1B,EAAM/G,OAAS,GAAqB,MAAhB0qB,GAAuC,OAAhBA,EAC9D8I,EAAS3wB,KAAK,CAAEgxB,MAAM,IAGtBtD,EAAE3uB,MAAM,KAAKiG,QAAQ,CAAC0oB,EAAG9nB,KACX,IAANA,GACA+qB,EAAS3wB,KAAK,CAAEgxB,MAAM,IAChB,KAANtD,GACA+D,EAAW/D,OAMxBiD,CACX,CAiBA,SAASiB,GAAmB/J,GACxB,MAAM8I,EAAWC,GAAiB/I,GAC5BgK,EAAoBnE,IAAM,MAAAA,OAAA,EAAAA,EAAG3uB,MAAM,KAAKG,OAAO4yB,SAAS30B,SAAU,EACxE,IAAI40B,EAA+B,EACnC,UAAWjB,KAAWH,EAAU,CAC5B,IAAKG,EAAQG,OACT,MACJc,GAAgCF,EAAiBf,EAAQG,OAC7D,CAIA,MAAO,CAAEc,+BAA8BC,oBAHXrB,EAAS1pB,IAAKymB,GAAMmE,EAAiBnE,EAAEuD,SAASgB,OAAO,CAACC,EAAKC,IAAMD,EAAMC,EAAG,GAG5CC,eAFrCzB,EAASzxB,OAAQwuB,GAAMA,EAAEqD,OAAO5zB,OAEqBk1B,cADtD1B,EAASzxB,OAAQwuB,GAAMA,EAAEsD,MAAM7zB,OAEzD,CAIA,SAASm1B,GAAoBzK,GACzB,MACMtR,EAAQga,GAAmB1I,EADrBA,GAGZ,OAAiD,IAA1CvlB,OAAO4J,KAAKqK,EAAM8a,aAAal0B,MAC1C,CACA,SAASszB,GAAU5I,GACf,OAAI3mB,IACO,IAAI2mB,MAGS,KAAhBA,IACAA,EAAc,MAEXzqB,EAAGqE,KAAKomB,GAEvB,CE9HA,SAAS0K,GAAYC,EAAaC,WAC9B,CACI,MAAMC,EAAc,OAAAr2B,EAAAm2B,EAAYG,YAAZt2B,EAA0B,EACxCu2B,EAAc,OAAAjlB,EAAA8kB,EAAYE,YAAZhlB,EAA0B,EAC9C,GAAI+kB,IAAgBE,EAChB,OAAOF,EAAcE,GAAc,EAAK,CAEhD,CACA,IAAKH,EAAY5K,YACb,OAAO,EAEX,IAAK2K,EAAY3K,YACb,OAAO,EASX,CACI,MACM6C,EAAS1d,GADG6a,GAAgB+J,GAAmB/J,GAAakK,6BACnD/kB,CAAsBwlB,EAAY3K,YAAa4K,EAAY5K,aAC1E,GAAe,IAAX6C,EAKA,OAAOA,CAEf,CAEA,CACI,MACMA,EAAS1d,GADG6a,GAAgB+J,GAAmB/J,GAAamK,oBACnDhlB,CAAsBwlB,EAAY3K,YAAa4K,EAAY5K,aAC1E,GAAe,IAAX6C,EAKA,OAAOA,CAEf,CAEA,CACI,MACMA,E1EtBd,SAAoBzd,GAChB,MAAO,CAACC,EAAUC,KACd,MAAMC,EAAOH,EAASC,GAChBG,EAAOJ,EAASE,GACtB,OAAIC,IAASC,EACF,EAEJD,EAAOC,GAAO,EAAK,EAElC,C0EauBwlB,CADGhL,GAAgB+J,GAAmB/J,GAAawK,cACnDQ,CAAqBL,EAAY3K,YAAa4K,EAAY5K,aACzE,GAAe,IAAX6C,EAKA,OAAOA,CAEf,CAEA,CACI,MACMA,EAAS1d,GADG6a,GAAgB+J,GAAmB/J,GAAauK,eACnDplB,CAAsBwlB,EAAY3K,YAAa4K,EAAY5K,aAC1E,GAAe,IAAX6C,EAKA,OAAOA,CAEf,CACA,OAAO,CACX,CCnFA,SAAeoI,GAAsB/e,GAAa,OAAA0F,EAAAC,KAAA,iBAC9C,MAAMqZ,EAAmC,GACzC,IAAKhf,EAAYoF,eAAemT,mBAC5B,OAAO,KACX,MAAM3M,QAuBV,SAAsCiL,EAAmB7W,GAAa,OAAA0F,EAAAC,KAAA,iBAClE,IAAIK,WAAEA,GAAec,GAAmB+P,EAAmB7W,EAAayE,IACxE+R,GAAkBxQ,EAAY,4BAA4B6Q,EAAkBnX,gBAE5EsG,QAAmBA,EACnB,MAAMvR,EAAY,uCAAuCoiB,EAAkBnX,eAI3E,GAHAvT,EAAY6Z,SCtChB,SAA0BhY,EAAKmK,GAC3B,IAAKzJ,EAAcV,GACf,OAAO,EAEX,UAAWlE,KAAOyE,OAAO4J,KAAKnK,GAC1B,IAAKmK,EAAK9M,SAASvB,GACf,OAAO,EAGf,OAAO,CACX,CD8BSm1B,CAAiBjZ,EAAY,CAAC,iBAAmBjY,EAAQiY,EAAY,eAAiB,GAAGvR,mBAA2BpL,EAAGqE,KAAK,YAAYrE,EAAGqE,KAAK,8CAA8CrE,EAAGqE,KAAK,qCACvMsY,QACA,OAAO,KAGX,GADA7Z,EAAY4B,EAAQiY,EAAY,cAAe,UAAW,GAAGvR,cAAsBpL,EAAGqE,KAAK,2EACvFK,EAAQiY,EAAWhG,YAAa,YAAcjS,EAAQiY,EAAWhG,YAAa,SAAU,QAAS,CACjG,MAAMyc,EAAa,GAAGhoB,cAAsBpL,EAAGqE,KAAK,sCAAsCrE,EAAGqE,KAAK,sBAClGvB,EAAY4B,EAAQiY,EAAWhG,YAAa,SAAU,UAAW,GAAGyc,sBACpEtwB,EAAY6T,EAAYoF,eAAegQ,YAAY/pB,SAAS2a,EAAWhG,YAAY3F,QAAS,GAAGoiB,KE/CvG,SAAqB30B,EAAKo3B,EAAaC,EAAaxF,GAAMA,GAEtD,GADO7xB,EAAIsB,OACQ,IAAftB,EAAIsB,OACJ,OAAO+1B,EAAUr3B,EAAI,IACzB,MAAMs3B,EAASt3B,EAAIqH,MAAM,EAAGrH,EAAIsB,OAAS,GACnCi2B,EAAOv3B,EAAIA,EAAIsB,OAAS,GACxBk2B,EAAYx3B,EAAIsB,OAAS,EAAI,IAAM,GACzC,OAAOg2B,EAAOlsB,IAAIisB,GAAW3zB,KAAK,MAAQ,GAAG8zB,KAAaJ,KAAiBC,EAAUE,EACzF,CFuCqHE,CAAYvf,EAAYoF,eAAegQ,YAAYliB,IAAKymB,GAAMtwB,EAAGqE,KAAKisB,IAAK,QAC5L,CACI5rB,EAAQiY,EAAWhG,YAAa,gBAChC0W,GAAkB1Q,EAAWhG,YAAa,GAAGvL,cAAsBpL,EAAGqE,KAAK,8DAE/E,MAAM8xB,EAAoBvxB,GAAS,GAAGwG,cAAsBpL,EAAGqE,KAAK,oBAAoBO,wCAA2C5E,EAAGqE,KAAK,8CACvIK,EAAQiY,EAAWhG,YAAa,SAChC7W,GAAc,EAAOq2B,EAAiB,OAAQ,CAAEh2B,UAAU,IAC1Dwc,EAAWhG,YAAYsM,WAAatG,EAAWhG,YAAYpQ,WACpDoW,EAAWhG,YAAYpQ,KAE9B7B,EAAQiY,EAAWhG,YAAa,iBAChC7W,GAAc,EAAOq2B,EAAiB,eAAgB,CAAEh2B,UAAU,IAClEwc,EAAWhG,YAAYsM,WAAatG,EAAWhG,YAAYgK,mBACpDhE,EAAWhG,YAAYgK,aAE9Bjc,EAAQiY,EAAWhG,YAAa,eAChCxL,GAEAwR,EAAWhG,YAAYsM,WAAY,GAAG7X,cAAsBpL,EAAGqE,KAAK,0CAA0CrE,EAAGqE,KAAK,iBAE1H6R,GAAgCyG,EAAWhG,YAAa,CACpDN,aAAcmX,EAAkBnX,aAChCD,SAAU,kBAEd,MAAMggB,EAA0B,GAEhC,OADA5wB,EAAa4wB,EAAyBzZ,EAAWhG,aAC1Cyf,CACX,GAnEsCC,CAAuB1f,EAAYoF,eAAemT,mBAAoBvY,GACxG,OAAI4L,IACA/c,EAAamwB,EAAkCpT,GAC3C7d,EAAQixB,EAAkC,SAAU,WACpDjxB,EAAQixB,EAAkC,SAAU,UAE/CjxB,EAAQixB,EAAkC,eAIpCjxB,EAAQixB,EAAkC,cAAe,UAHhEnwB,EAAamwB,EAAkC,CAAE1B,YAAa,KAKlEzuB,EAAamwB,EAAkC,CAC3CW,qCAAqC,IAElCX,IAGfnwB,EAAamwB,EAAkC,CAC3CW,qCAAqC,IAElCX,EACX,GGnBA,SAAepL,GAAM5T,EAAa4f,GAAuB,OAAAla,EAAAC,KAAA,uBACrD,MAAMka,EAAuB,GAQD,CACxB,MAAMb,QAAyCD,GAAsB/e,GACrE,GAAIgf,EAAkC,CAClC,GAAIA,EAAiCW,oCAEjC,OADOX,EAAiC3kB,OACjC2kB,EAGPnwB,EAAagxB,EAAsBb,EAE3C,CAEAnwB,EAAamR,EAAagf,EAC9B,CAGA7yB,EADmB6T,EAAYoF,eAAegQ,YACvBhsB,OAAS,EAAG,qDAC5B4W,EAAYoF,eAAe+B,cAAc/d,OAAS,GAAK4W,EAAYoF,eAAegC,aAAahe,OACtG,MAAMiJ,YAAEA,GAAgB2N,EACjB3N,EAAY/G,WAAW,KAC9B,MAAMw0B,EAAe,SACf9qB,QAAQ8Q,IAAI9F,EAAYoF,eAAekT,YAAYplB,IAAWqkB,GAAc7R,EAAAC,KAAA,iBAC9E,MAAMtL,OAAEA,EAAAod,UAAQA,GAAcF,EAE9B,GAA4B,eAAxBA,EAAUE,UAA4B,CACtC,MAAM3D,YAAEA,GAAgByD,EAClB/U,EAAQga,GAAmB1I,EAAazhB,GAC9C,GAAImQ,EAAO,CACP,MAAM8a,YAAEA,GAAgB9a,EACxBsd,EAAa7zB,KAAK,CAAEoO,SAAQijB,cAAaxJ,cAAa2D,aAC1D,CACA,MACJ,CAEA,GAA4B,WAAxBF,EAAUE,UAAwB,CAClC,MAAM3D,YAAEA,GAAgByD,EAClB/U,EAAQga,GAAmB1I,EAAazhB,GAC9C,GAAImQ,EAAO,CACP,MAAM8a,YAAEA,GAAgB9a,EAExBsd,EAAa7zB,KAAK,CACdoO,SACAyZ,cACAwJ,cACA7F,aAER,CACA,MACJ,CAEA,GAA4B,aAAxBF,EAAUE,UAA0B,CACpC,MAAMC,cAAEA,EAAAC,sBAAeA,GAA0BJ,EAC3C/U,QzBnElB,SAAoCkV,EAAe1X,EAAa2X,GAAuB,OAAAjS,EAAAC,KAAA,iBACnF,IAAMK,WAAY2Q,GAAW7P,GAAmB,CAC5CvG,OAAQmX,EACRhY,aAAciY,EACdlY,SAAU,SACXO,EAAayE,IAMhB,GALA+R,GAAkBG,EAAQ,sBAAsBgB,KAGhDhB,QAAeA,GAEA,IAAXA,EACA,OAAO,KAOX,IALe,IAAXA,IACAA,EAAS,IAEbxqB,EAAYuC,EAAcioB,GAAS,sBAAsBgB,oEAAwFtuB,EAAGqE,KAAK,qBAAqBqR,KAAKC,iBAAiB2X,kBAEhM,UAAWA,EAAQ,CACnB,MAAMnU,MAAEA,GAAUmU,EAElB,GADAxqB,EAA6B,kBAAVqW,EAAqB,OAAOnZ,EAAGqE,KAAK,iDAAiDiqB,2BACnGnV,EACD,OAAO,IAEf,CACA,IAAIoc,EAAa,KACb,eAAgBjI,IAChBiI,EAAajI,EAAOiI,WACpBzyB,EAAkC,iBAAfyyB,EAAyB,OAAOv1B,EAAGqE,KAAK,sDAAsDiqB,0BAErHjB,GAAkBC,EAAQ,OAAOttB,EAAGqE,KAAK,wDAAwDiqB,YACjG,MAAM2F,EAAc3G,EAAO2G,aAAe,GAM1C,OALAnxB,IAAc,gBAAiBwqB,GAAS,aAAattB,EAAGqE,KAAK,mHACtDgB,EAAc4uB,GACrB/uB,OAAO4J,KAAKwe,GAAQ1lB,QAASnH,IACzBqC,EAAoB,UAARrC,GAA2B,gBAARA,GAAiC,eAARA,EAAsB,sBAAsB6tB,iDAAqEtuB,EAAGqE,KAAK5D,gCAAkCT,EAAGqE,KAAK,aAAarE,EAAGqE,KAAK,uBAAuBrE,EAAGqE,KAAK,oBAE5Q,CACHkxB,aACAtB,cAER,GyByBgCyC,CAAqBrI,EAAe1X,EAAa2X,GACrE,GAAInV,EAAO,CACP,MAAM8a,YAAEA,EAAAsB,WAAaA,GAAepc,EACpCsd,EAAa7zB,KAAK,CAAEoO,SAAQukB,aAAYtB,cAAa7F,aACzD,CACA,MACJ,CAEJ,KJ5EJ,SAA2BqI,GAGvBA,EACKjlB,KAAK2jB,IACL3jB,KAAKtB,GAAWymB,GAAwC,aAAzBA,EAAWvI,aAA8BuI,EAAWpB,YAAcoB,EAAWpB,WAAa,IACzH/jB,KAAKtB,GAAWymB,GAAwC,WAAzBA,EAAWvI,YAA0E,IAAhD8G,GAAoByB,EAAWlM,eACnGjZ,KAAKtB,GAAWymB,GAAwC,aAAzBA,EAAWvI,YAA6BuI,EAAWpB,aAClF/jB,KAAKtB,GAAWymB,GAAwC,WAAzBA,EAAWvI,YAA0E,IAAhD8G,GAAoByB,EAAWlM,eACnGjZ,KAAKtB,GAAWymB,GAAwC,eAAzBA,EAAWvI,YAC1C5c,KAAKtB,GAAWymB,GAAwC,aAAzBA,EAAWvI,aAA8BuI,EAAWpB,YAAcoB,EAAWpB,WAAa,GAClI,CIkEIqB,CAAkBH,GAClB,MAAMI,EAAS,OAAA53B,EAAAw3B,EAAa,IAAbx3B,EAAmB,KASlC,GADAuG,EAAagxB,EAAsB,CAAEM,YAAaD,KAC7CA,EAKD,OAJArxB,EAAagxB,EAAsB,CAC/BxlB,OAAQ,KACRijB,YAAa,KAEVuC,EAEX,CACI,MAAMvC,YAAEA,GAAgB4C,EACjBxxB,EAAc4uB,GACrBzuB,EAAagxB,EAAsB,CAC/BxlB,OAAQ6lB,EAAO7lB,OACfijB,YAAa4C,EAAO5C,aAE5B,CACA,OAAOuC,CACX,GA1GI1yB,KACAI,ICFJ,MAAM5E,KAA+B,kDAAmD,CACpFy3B,mBAAoB,OAExB,SAASC,KACL,MAAMD,mBAAEA,GAAuBz3B,GAC/B,OAAOy3B,CACX,CACA,SAASE,GAAsBF,GAC3Bz3B,GAAay3B,mBAAqBA,CACtC,CCPA,MAAMG,GAA+B,IAC/BC,GAAsB,CACxBC,aAAc,QACdzgB,YAAaugB,IAEXG,GAAuB,CACzBD,aAAc,QACdzgB,aAAa,GAGX2gB,GAAyBD,GAC/B,SAASE,GAAoB5gB,EAAaoa,GACtC,IAAIyG,EAAkBF,GAMtB,GAJI,kBAAmB3gB,EAAYE,SAC/B/T,GAAY,EAAO,4FAGnB,yBAA0B6T,EAAYE,QAAS,CAC/C,MAAM4gB,EAAuB9gB,EAAYE,QAAQ4gB,qBASjDD,EAAgBJ,aAAeK,CACnC,CACA,GAAI,aAAc9gB,EAAYE,QAAS,CACnC,MAAM6gB,SAAEA,GAAa/gB,EAAYE,SAChB,IAAb6gB,IACAF,EAAkBL,KACL,IAAbO,IACAF,EAAkBH,IAEtBnyB,OAAO6Z,OAAOyY,EAAiBE,IACK,IAAhCF,EAAgB7gB,cAChB6gB,EAAgB7gB,YAAcugB,GAEtC,CAKA,GAJIM,EAAgBJ,aAIhBrG,EAAS,CACT,CACI,IAAI4G,EAAO5G,EAAQC,aAAa,iBACnB,OAAT2G,IACa,KAATA,IACAA,EAAO,QACE,SAATA,IACAH,EAAkBL,IACT,UAATQ,IACAH,EAAkBH,IAE9B,CACA,CACI,IAAIM,EAAO5G,EAAQC,aAAa,+BACnB,OAAT2G,IACa,UAATA,IACAH,EAAgBJ,cAAe,GAEnCI,EAAgBJ,aAAeO,EAEvC,CACA,CACI,IAAIA,EAAO5G,EAAQC,aAAa,8BAChC,GAAa,OAAT2G,EAAe,CACF,KAATA,IACAA,EAAO,QACE,SAATA,IACAH,EAAgB7gB,YAAcugB,IACrB,UAATS,IACAH,EAAgB7gB,aAAc,GAClC,MAAM6C,EAAI9P,SAASiuB,EAAM,IACpBC,OAAOC,MAAMre,KACdge,EAAgB7gB,YAAc6C,EAEtC,CACJ,CACJ,CACA,OAAOge,CACX,CCrEAtzB,IACA,MAAM5E,KAA+B,qCAAsC,CACvEw4B,6BAA8Bn1B,QAC9Bo1B,iCAAkC,KAClCC,iBAAkB,IAAIC,iBAAiBC,IAEvCC,SAAUhuB,SAASiuB,qBAAqB,KACxCC,uBAAwB,KAmC5B,SAASC,GAAiC3hB,EAAqC2W,GAEtEiL,MAELC,GAA4B7hB,EAAa2W,EAAQ,KACrD,CACA,SAASkL,GAA4B7hB,EAAa2W,EAAQmL,GACjC,OAAjBA,IACAA,EASR,WACI,MAAM1B,EAAqBC,KAE3B,IAAKD,EACD,OAAO5c,IACX,MAAMue,EAAmBnB,GAAoBR,EAAoB,MAC3D0B,EAAuD,iBAAjCC,EAAiB/hB,YAA2B+hB,EAAiB/hB,YAAcugB,GACvG,OAAOuB,CACX,CAjBuBE,IACnB,MAAMl4B,EAAMm4B,GAAYjiB,EAAY3N,aAEpC1J,GAAa+4B,uBAAuB53B,GAAO,CACvCo4B,gBAAiB/qB,KAAKD,MACtB4qB,eACAnL,SAER,CA0DA,SAAS4K,KACD54B,GAAay4B,kCACbhrB,aAAazN,GAAay4B,kCAC9Bz4B,GAAay4B,iCAAmClsB,WAAW,KAEnD,wBAAyB9H,OACzB+0B,oBAAoBC,GAA+B,CAAE5sB,QAAS,MAI9DN,WAAWktB,GAA+B,MAE/C,IACP,CAkBA,SAASA,KACL,QAAShI,KAAWzxB,GAAa64B,SAAU,CACvC,GAAI74B,GAAaw4B,yBAAyBp3B,IAAIqwB,GAC1C,SAEJ,GADAzxB,GAAaw4B,yBAAyBn3B,IAAIowB,GACtCD,GAAcC,GACd,SACJA,EAAQ/kB,iBAAiB,YAAa,KAClCgtB,GAAgBjI,EAAS,UAC1B,CAAEkI,SAAS,IACdlI,EAAQ/kB,iBAAiB,aAAc,KACnCgtB,GAAgBjI,EAAS,UAC1B,CAAEkI,SAAS,IACG,IAAIC,qBAAsB/gB,IACvCA,EAAQvQ,QAASuxB,IACTA,EAAMC,gBACNJ,GAAgBjI,EAAS,gBAI5BsI,QAAQtI,EACrB,CACJ,CACA,SAAeiI,GAAgBjI,EAASuI,GAAO,OAAAjd,EAAAC,KAAA,iBAC3C,IAAIoc,EACJ,MAAM3B,EAAqBC,KAC3B,GAAID,EACA2B,EAAmBnB,GAAoBR,EAAoBhG,OAE1D,CACD,IAAIwH,KAMA,OAJAG,EAAmB,CAAEtB,aAAc,QAASzgB,YAAawD,IAMjE,CAEA,GAAI2W,GAAcC,GACd,OACJ,MAAMwI,EAAYxI,EAAQC,aAAa,QACjCwI,QA6BV,SAAkCD,GAAW,OAAAld,EAAAC,KAAA,iBACzC,MAAMkd,QAAwBrK,GAA4BoK,GAC1D,IAAI/C,EACJ,IACIA,QAA6BjM,GAAMiP,EACvC,OACMvvB,GAEF,OAAO,IACX,CAEA,OADAzE,EAAag0B,EAAiBhD,GACvBgD,CACX,GAzCkCC,CAAmBF,IAC5C,MAAAC,OAAA,EAAAA,EAAiBxoB,UAEftM,EAAQ80B,EAAiB,SAAU,iBAC9BhH,GAAqBgH,EAAgBxoB,OAAQwoB,YAEnD7tB,QAAQ8Q,IAAI,MACDJ,EAAAC,KAAA,iBACLoc,EAAiBtB,eAAiBkC,UA7KlD,SAA8BE,GAAiB,OAAAnd,EAAAC,KAAA,iBAC3C,UACU6T,GAA8BqJ,EAAgBxoB,OAAQwoB,EAAgB1b,cAAe0b,EAAgBzd,eAAegC,aAAcyb,EAAgBzd,eAAe+P,kBAC3K,OACO7qB,GACH,IAAIyvB,GAA4BzvB,GAI5B,MAAMA,EAHNy4B,GAAqBz4B,GAAK,EAKlC,CACJ,GAkKsB04B,CAAeH,GAE7B,GALc,GAKb,KACYnd,EAAAC,KAAA,iBACT,GAAc,aAAVgd,GAAwBZ,EAAiB/hB,YAAa,CACtD,MAAMlW,EAAMm4B,GAAYW,GAClBK,EAAQt6B,GAAa+4B,uBAAuB53B,GAClD,IAAKm5B,GAASC,GAAUD,GAAQ,CAE5B,MAAMnB,EAAeC,EAAiB/hB,kBA1K1D,SAAkD6iB,EAAiBf,GAAc,OAAApc,EAAAC,KAAA,iBAC7E,MAAMgR,QAAezN,GAA8B2Z,GAAiB,GACpEhB,GAA4BgB,EAAiBlM,EAAQmL,EACzD,GAwK0BqB,CAAmCN,EAAiBf,EAC9D,CACJ,CACJ,GAXC,MAaT,GACA,SAASoB,GAAUD,GACf,OAAO9rB,KAAKD,MAAQ+rB,EAAMf,gBAAkBe,EAAMnB,YACtD,CAeA,SAASG,GAAYryB,GACbA,EAAItE,WAAW,OACfsE,EAAM,KACHA,EAAItE,WAAW,KAEtB,OADYsE,EAAI5E,MAAM,KAAK,EAE/B,CAEA,SAAS42B,KACL,MAAO,wBAAyBx0B,MACpC,CClQA,SAAeg2B,GAAuBpjB,EAAakH,GAAuB,OAAAxB,EAAAC,KAAA,iBACtE,IAAII,EAAO,KAGPA,EADmB9F,GAAuBD,EAAa,UAG3D,CACI,MAAMqjB,EAAapjB,GAAuBD,EAAa,kBACnDqjB,IACAtd,EAAOsd,EAEf,CACA,IAAKtd,EAAM,CACP,MAAMud,EAyBd,SAA4BtjB,SACxB,IAAIpQ,EAEJ,IACIA,EAEI,OAAAtH,IAAY+J,aAAZ/J,EAEI0X,EAAY,WACxB,OACM1M,GAAE,CAER,OADA1D,EAAM,MAAAA,IAAOxC,OAAOyH,SAASrC,KACtB5C,CACX,CAtCgC2zB,CAAmBvjB,GAE3C,GAAIA,EAAYoF,eAAegC,aAAahe,OAAS,EAEjD+C,GAAY,EAAO,6CAA6Cm3B,gEAE/D,CAGD,MAAME,EAAyBxjB,EAAY8Z,iBAAiB3uB,OAAQ2G,GAAqB,iBAAfA,EAAE8I,UAC5E,IAAIxO,EAEAA,EADkC,IAAlCo3B,EAAuBp6B,OACd,2CAA6Ck6B,EAIlD,6DACIE,EAAuBtwB,IAAKpB,GAAMA,EAAEmI,UAAUzO,KAAK,KAE/DW,GAAY,EAAOC,EACvB,CACJ,OAEM+Z,GAAqBJ,EAAM/F,EAAakH,EAClD,GCvCA,SAASuc,GAAcxJ,GACnB,OAAOD,GAAuB5sB,OAAOyH,SAASrC,KAAMynB,EACxD,CCGA,MAAMtxB,KAA+B,aAAc,CAC/C+6B,eAAe,EACfC,cAAU,IAQd,SAASC,KACL,GAAIC,GAAez2B,OAAO02B,QAAQx2B,OAC9B,OAEJy2B,GAEJ,SAAiBC,aACb,MAAMC,EAAYC,KACZC,EAAiBC,KACjBC,EAAc,UACpB,IAAIC,EAYAA,EAXCN,EAWmB,CAChBC,UAAW,OAAA37B,EAAA07B,EAAiBC,WAAjB37B,EAA8B27B,EACzCE,eAAgB,OAAAvqB,EAAAoqB,EAAiBG,gBAAjBvqB,EAAmCuqB,EACnDE,YAAa,OAAAliB,EAAA6hB,EAAiBK,aAAjBliB,EAAgCkiB,EAC7CE,iBAAiB,GAdD,CAChBN,YACAE,iBACAE,cACAE,iBAAiB,GAczB,OAAOD,CACX,CA5B8BE,CAAQp3B,OAAO02B,QAAQx2B,OAErD,CA2BA,SAASm3B,KAQL,OAPcr3B,OAAO02B,QAAQx2B,KAQjC,CACA,SAAS82B,KAEL,MADuB,CAAEpsB,EAAG5K,OAAOs3B,QAASzsB,EAAG7K,OAAOC,QAE1D,CACA,SAAS62B,KACL,WAAW/sB,MAAOG,SACtB,CACA,SAASqtB,KACL,MAAMR,EAAiBC,KACjB92B,EAAQm3B,KACdV,GAAoBjsB,EAAAoO,EAAA,GAAK5Y,GAAL,CAAY62B,mBACpC,CAkBA,SAASJ,GAAoBz2B,EAAOsC,GAChC,MAAMg1B,EAAO,MAAAh1B,IAAO,KACpBxC,OAAO02B,QAAQe,aAAav3B,EAAO,GAAIs3B,EAE3C,CACA,SAASE,GAA4Bx3B,EAAOsC,GAGxCm1B,QAAQC,UAAUH,aAAajuB,KAAKxJ,OAAO02B,QAA3CiB,CAAoDz3B,EAAO,GAAIsC,EACnE,CAqCA,SAASi0B,GAAev2B,GACpB,SAAI5B,EAAS4B,MAAU,oBAAqBA,GAahD,CAMA,SAAS23B,KACL,MAAO,CACHr1B,IAAK6zB,KACLn2B,MAAOm3B,KAEf,CAWA,SAASS,KApEDv8B,GAAa+6B,gBAEjB/6B,GAAa+6B,eAAgB,EAC7B,CAAC,YAAa,gBAAgBzyB,QAASk0B,IACnC,MAAMC,EAAeh4B,OAAO02B,QAAQqB,GAAUvuB,KAAKxJ,OAAO02B,SAC1D12B,OAAO02B,QAAQqB,GAAY,CAACE,EAAgB,MAAOzxB,KAC/CzH,EAAYk5B,SAAyD35B,EAAS25B,GAAgB,WAAWF,6CACzG,MAAMG,EAAgBzB,GAAewB,GAC/BA,EACAnf,EAAA,CACEqe,iBAAiB,EACjBJ,eAAgBC,KAChBH,UAAWC,KACXG,YAAa,QACVgB,GAGXD,EAAaE,KAAkB1xB,GACxBmE,GAAUutB,EAAel4B,OAAO02B,QAAQx2B,OAC/C3E,GAAag7B,SAAWsB,KAExBM,eAAe,KACPxtB,GAAUutB,EAAel4B,OAAO02B,QAAQx2B,SAE5CiB,OAAO6Z,OAAOkd,EAAel4B,OAAO02B,QAAQx2B,OAE5Cw3B,GAA4BQ,EAAe1xB,EAAK,IACzCmE,GAAUutB,EAAel4B,OAAO02B,QAAQx2B,cA2C3Ds2B,IACJ,CCxKA,SAAS4B,GAAkBC,EAAc71B,GACrC,IAAK61B,GAAgB71B,GA0BzB,SAAyBA,GACrB,OAAOA,EAAIvE,SAAS,MAAQuE,EAAIvE,SAAS,UAC7C,CA5BgCq6B,CAAgB91B,GAExC,YAcR,SAA8BA,GAC1B,MAAMy1B,EAAgBj4B,OAAO02B,QAAQx2B,MACrCw3B,GAA4B,KAAMl1B,GAKlCxC,OAAOyH,SAAS5B,QAAQrD,GACxBk1B,GAA4BO,EAAez1B,EAC/C,CAxBQ+1B,CAAqB/1B,GAGzB,GAAI61B,GAAgB,MAAOA,EAEvB,YADAG,GAAUH,GAGd,SAAIA,WAAcI,eACd,OAGJC,GAuFJ,WACI,IAAIz1B,KAAEA,GAASjD,OAAOyH,SACtB,MAAa,KAATxE,EACO,MACJA,EAAK/E,WAAW,KACvB+E,EAAOA,EAAKlB,MAAM,GACXkB,EACX,CA/FiB01B,GAEjB,CAiBA,SAASD,GAAkBz1B,GACvB,GAAKA,EAGA,CACD,MAAMiI,EAAKjF,mBAAmBhD,GACxB21B,EAAaxyB,SAASgF,eAAeF,IAAO9E,SAASyyB,kBAAkB3tB,GAAI,GAC7E0tB,GACAA,EAAWE,iBAEXF,EAAWG,SAEG,QAAT91B,GACL+1B,IAER,MAbIA,IAcR,CACA,SAASA,KACLR,GAAU,CAAE5tB,EAAG,EAAGC,EAAG,GACzB,CAUA,SAAS2tB,GAAUzB,GACf,MAAMkC,EAAS,KAEXj5B,OAAOk5B,SAASnC,EAAensB,EAAGmsB,EAAelsB,IAE/CsuB,EAAO,IACFn5B,OAAOs3B,UAAYP,EAAensB,GAAK5K,OAAOC,UAAY82B,EAAelsB,EAGhFsuB,MAEJF,IAEIE,KAEJC,sBAAsB,KAClBH,IACIE,KAEJrxB,WAAW,IAAYwQ,EAAAC,KAAA,iBAEnB,GADA0gB,IACIE,IACA,OAKJ,MAAM/2B,GAAA,IAAY2H,MAAOG,UACzB,OAAa,CAGT,SAFMxC,GAAM,IACZuxB,IACIE,IACA,OAEJ,IADM,IAA0BpvB,MAAOG,UAAY9H,EACzB,IACtB,MACR,CACJ,GAAG,KAEX,CAUA,SAASi3B,KAELr5B,OAAOiI,iBAAiB,SCnH5B,SAAkBqxB,EAAMC,GACpB,IAAIC,GAAW,EACf,MAAO,KACEA,IACDA,GAAW,EACX1xB,WAAW,KACP0xB,GAAW,EACXF,KACDC,IAGf,CDwGsCE,CAASlC,GAAoBmC,KAAKC,KAAK,IAAO,IAAK,CAAEzE,SAAS,IAChGntB,GAAWwvB,GACf,CD3GAO,KACAv8B,GAAag7B,SAAWsB,KGJxB,MAAMt8B,GAAeT,EAAgB,8CAA+C,IACpF,SAAS8+B,K9FAT,IAAoB5xB,E8FEhB6xB,KACA9xB,GAAW8xB,I9FHK7xB,E8FIL,IAAMzM,GAAau+B,qBAAuBC,K9FHrD/5B,OAAOiI,iBAAiB,mBAAoB,KACP,YAA7B7B,SAAS8B,iBACTF,K8FEZ,CAKA,SAAS+xB,KACD,sBAAuB/5B,OAAO02B,UAC9B12B,OAAO02B,QAAQsD,kBAAoB,SAE3C,CACA,SAASH,KACD,sBAAuB75B,OAAO02B,UAE9B12B,OAAO02B,QAAQsD,kBAAoB,OAE3C,CC3BA,SAASC,GAAe/8B,GAChBoB,EAASpB,IAGTA,EAAIg9B,iBAGRr9B,QAAQ2C,MAAMtC,EAClB,CCiBA,MAAM3B,GAAeT,EAAgB,uDACjC,MAAQmO,QAASkxB,EAAyB7xB,QAAS8xB,GAAmCjyB,KACtF,MAAO,CACHkyB,cAAe,EACfF,0BACAC,iCAER,EAPqC,KAQ/BD,wBAAEA,IAA4B5+B,GACpC,SAAe++B,GAAqBC,GAAY,OAAAjiB,EAAAC,KAAA,iBAC5C7O,GAAkB,0BAClB,MAAMkT,YAAEA,EAAcyZ,KAAAmE,0BAAiBA,GAA4B,uBAAOC,EAAAjgB,wBAAsBA,EAA0B,GAAAkgB,cAAIA,EAAgB,EAAAC,sBAAGA,EAAAC,uBAAuBA,GAAyB,EAAAC,sBAAMA,GAA2BN,EAClO,IAAIlC,aAAEA,GAAiBkC,EACvB,MAAMO,oBAAEA,GAAwBv/B,GR6HhCA,GAAa04B,iBAAiB8G,aQ3H9B,MAAMC,iBAAEA,EAAAC,yBAAkBA,EAAAC,cAA0BA,GA2exD,WACI,MAAMC,IAAiB5/B,GAAa8+B,cAEpC,IAAIe,GAAwB,EAC5B,MAAMH,EAA2B,KAC7BG,GAAwB,GAGtBJ,EAAoBK,IAIlB,GADuC,IAAjBF,IACAC,IAA0BC,EAC5C,OAAO,EAIf,OAAOF,IAAiB5/B,GAAa8+B,eAEzC,MAAO,CACHW,mBACAC,2BACAC,cAAgC,IAAjBC,EAEvB,CAngB0EG,IzD6J1E,SAAmCC,EAAcb,GAC7C,MAAMc,EAAa,CAGfD,EAAe,GAAKt/B,EAAGqE,KAAK,6BAC5Bo6B,EAAgB,GAAKz+B,EAAGqE,KAAK,gCAE5BvC,OAAO4yB,SACPvyB,KAAK,SACVW,EAAYw8B,EAAeb,GAAiB,EAAG,6BAA6Bc,kDAA2DA,KAC3I,CyDtKIC,CAA0BjhB,EAAwBxe,OAAQ0+B,GAC1D,MAAMgB,EAAuB,CACzB9e,cACA6d,uBACAjgB,0BACAogB,yBACAC,wBACAK,iBAEJ,GAAI3/B,GAAaogC,wBACbn0B,GAAaoV,QAIjB,GADArhB,GAAa6+B,kCACTY,IAEJ,aACA,WAAmC,OAAA1iB,EAAAC,KAAA,iBAC/B,MAAMqjB,EAAiB1+B,GAAQob,EAAAC,KAAA,uBACrBsjB,EAAY,CAAE3+B,OACxB,GACM0V,QAAoBkpB,IAAoB,EAAOJ,GACrD,GAAIV,IACA,OAEJ,GAAIz/B,GAAawgC,oBAIRxgC,GAAaygC,gBAAiB,CAC/BzgC,GAAaygC,iBAAkB,EAC/B,MAAMvoB,EAAQD,GAA0B,wBAAyBsnB,GACjE,UACUtiB,GAAe/E,EAAOb,EAAa0I,GAC7C,OACOpe,GAEH,kBADM0+B,EAAQ1+B,GAElB,CACA,GAAI89B,IACA,MACR,CAGJ,GAAIE,EAAe,CACf,MAAMzf,EAAwBD,KAG9B/Z,EAAamR,EAAa6I,GAE1B8Y,GAAiC3hB,EAAa,CAAEoJ,2BAA4BP,GAChF,CAGA,CACI,IAAIgX,EACJ,IACIA,QAA6BjM,GAAM5T,EACvC,OACO1V,GAEH,kBADM0+B,EAAQ1+B,GAElB,CACA,GAAI89B,IACA,OAGJ,GAAIE,EAAe,CAGf,MAAyChgC,EAAAu3B,GAAjCxlB,qBAAQijB,GAAyBh1B,EACzCuG,EAAamR,EADmBnG,EAASvR,EAAT,CAAxB,SAAQ,iBAETyF,EAAQiS,EAAa,cAAe,WAC/C,MAEInR,EAAamR,EAAa6f,GAE9B,IAAKyI,EAAe,CAChB,IAAKzI,EAAqBxlB,OAWtB,YADAzF,GAAaoV,GAGjB,MAAMqf,QAAyBxN,GAAqBgE,EAAqBxlB,OAAQ2F,GACjF,GAAIooB,IACA,OACJ,IAAKiB,EAED,YADAz0B,GAAaoV,GAGjB,MAAMsf,EAAazJ,EAAqBxlB,eACpC6tB,WAAqB7tB,SACrBwlB,EAAqBxlB,SAAW6tB,EAAoB7tB,OACxD,GAAI0tB,GAAyBuB,EAEzB,MAER,CACJ,CACOv7B,EAAQiS,EAAa,SAAU,UACtC,MAAM8J,QAAYyf,GAAyCvpB,EAAasoB,EAAeF,GAIvF,IAAIte,EAAI0f,KAER,GAAI,QAAS1f,QACHkf,EAAQlf,EAAIxf,UAatB,GAVwBwf,EAAI9J,YAC5BsgB,GAAsBtgB,GAElBA,EAAYE,QAAQsoB,sBACpBH,IAGAl/B,GCtKL,uBAQH,MAAMsgC,KAAa,OAAA7vB,EAAA,gBAAO8vB,qCAAP,EAAAphC,EAAuCqhC,gBAAvC,EAAA/vB,EAAkDgwB,MAC/DC,KAAa,OAAAxN,EAAA,OAAAla,EAAA/U,OAAOs8B,qCAAP,EAAAvnB,EAAuC2nB,yBAAvC,EAAAzN,EAA2DuN,MAExEG,IAAa38B,OAAO48B,yCAK1B,OAAOP,GAAYI,GAAYE,CACnC,CDqJ2BE,GAAW,6HAA8H,CAAEzgC,UAAU,KAGpK4+B,IAAJ,CAGA,GAAIE,EAAe,CAEf,IAAI4B,EADGn8B,EAAQiS,EAAa,4BAA6B,QAEzD,IACIkqB,QpDlJhB,SAAmDlqB,GAAa,OAAA0F,EAAAC,KAAA,iBAC5D,UAAWlG,IAAY,CAAC,OAAQ,kBAIxB4L,GAAqB5L,EAAUO,WACzBsL,GAAiB7L,EAAUO,IAGzC,OAAOA,CACX,GoDwI6CmqB,CAAoCnqB,EACrE,OACO1V,GAEH,kBADM0+B,EAAQ1+B,GAElB,CACA,GAAI89B,IACA,OAGJ,aAAagC,EAAepqB,EAChC,CACK,CAED,IAAIoJ,EACJ,MAAMihB,ERpKlB,SAAkCrqB,GAG9B,IAFyB4gB,GAAoB5gB,EAAa,MAEpCA,YAClB,OAAO,KACX,MAAMlW,EAAMm4B,GAAYjiB,EAAY3N,aAC9B4wB,EAAQt6B,GAAa+4B,uBAAuB53B,GAClD,OAAKm5B,GAASA,EAAMtM,OAAOnM,uBAAyB0Y,GAAUD,GACnD,KACmBA,EAAMtM,OAAOvN,0BAM/C,CQqJ0CkhB,CAAyBtqB,GACvD,GAAIqqB,EACAjhB,EAA6BihB,OAG7B,IACI,MAAM1T,QAAezN,GAA8BlJ,GAAa,GAChE,GAAI2W,EAAOnM,sBACP,OACJpB,EAA6BuN,EAAOvN,2BAEpCuY,GAAiC3hB,EAAa2W,EAClD,OACOrsB,GAEH,kBADM0+B,EAAQ1+B,GAElB,CAEJ,GAAI89B,IACA,OAKJ,IAAImC,EAFJ17B,EAAamR,EAAaoJ,GAG1B,IACImhB,QAAmCpf,GAA8BnL,GAAa,EAClF,OACO1V,GAEH,kBADM0+B,EAAQ1+B,GAElB,CACA,GAAI89B,IACA,OAEJ,aAAagC,EAAepqB,EAChC,CAzDI,CA0DR,GA3KawqB,GAgLb,SAAevB,EAAYjzB,GAAM,OAAA0P,EAAAC,KAAA,iBAC7B,MAAMrb,IAAEA,GAAQ0L,EAGX0R,GAAapd,IAId+8B,GAAe/8B,GAOnB,MAAM0V,QAAoBkpB,IAAoB,EAAMJ,GACpD,GAAIV,IACA,OAKJ,IAAIrd,EACJ,GALAlc,EAAamR,EAAa,CACtByqB,oBAAqBngC,IAIrBod,GAAapd,GAAM,CACnB,MAAMwf,QAqFd,SAAgCxf,GAAkB,OAAAob,EAAAC,KAAA,iBAC9C,MAEMoF,EAFWzgB,EAEiB0gB,kBAElC,GAAID,EAAiBhD,YAMjB,aALM2f,GAAqB5vB,OACpB6vB,GADoB,CAEvBlC,kBAAc,EACd7d,wBAAyB,IAAIA,EAAyBmD,MAEnD,CAAEye,MAAM,GAGnB,GAAIze,EAAiBH,aAAc,CAC/B,MAAM8f,EAAc3f,EAAiBH,aAAahb,IAClD,OAAK86B,EAAYp/B,WAAW,YAMlBo8B,GAAqB5vB,OACpB6vB,GADoB,CAEvBlC,kBAAc,EACdzb,YAAa0gB,EACb9C,2BAA2B,EAC3BC,sBAAsB,EACtBC,cAAeA,EAAgB,KAGhC,CAAE0B,MAAM,KAbX50B,GAAa81B,GACN,CAAElB,MAAM,GAavB,CAEA,MAAO,CAAEze,mBACb,GAxH0B4f,CAAiBrgC,GACnC,GAAIwf,EAAI0f,KACJ,OACJze,EAAmBjB,EAAIiB,gBAC3B,OAIJ,SAA+B/K,EAAahK,EAAM+U,GAAkB,OAAArF,EAAAC,KAAA,iBAChE,MAAMqjB,EAAW1+B,IAMb+8B,GAAe/8B,IAEbsgC,E9C/Qd,SAAwBxwB,EAAc+C,GAClC,GAAIA,EAAY/T,OAAS,EAAG,CACxB,MAAMyhC,EAAmB1tB,EAAYhS,OAAQ2G,GAAMA,EAAEqX,aACrD,OAAgC,IAA5B0hB,EAAiBzhC,OACV,MACX+C,EAAwC,IAA5B0+B,EAAiBzhC,OAAc,sCACpCyhC,EAAiB,GAAGxwB,OAC/B,CAEA,MAAMywB,EAAejjC,EAAOuS,EAAalH,IAAI,EAAGmH,YAAaA,GAAQlP,OAAQkP,GAAWiT,GAAcjT,KAEtG,GADAlO,EAAY2+B,EAAa1hC,QAAU,EAAG,0DAA0D0hC,EAAat/B,KAAK,QAC9Gs/B,EAAa1hC,OAAS,EAGtB,OAFoB0hC,EAAa,GAIrC,OAAO,IACX,C8C8P4BC,CAAe/qB,EAAYmH,cAAenH,EAAYoF,eAAegC,cACzF,IAAKwjB,EACD,MAAM,IAAIzgC,MAAM,0BACpB0E,EAAamR,EAAa,CACtB3F,OAAQuwB,EACRtN,YAAa,KAGbvS,GACOA,EAAiBF,gBAExBhc,EAAamR,EAAa+K,GAC1Blc,EAAamR,EAAa,CAAEmD,MAA4C,MAArC4H,EAAiBF,mBAGpDhc,EAAamR,EAAa,CAAEmD,OAAO,IAEvC,MAAMkmB,QAAyBxN,GAAqB7b,EAAY3F,OAAQ2F,GACxE,GAAIooB,IACA,OACJ,IAAKiB,EAED,YADAz0B,GAAaoV,GAMjB,MAAMF,QAAYyf,GAAyCvpB,EAAasoB,EAAeF,GAIvF,GAAIte,EAAI0f,KACJ,OACJ,GAAI,QAAS1f,EAET,YADAkf,EAAQlf,EAAIxf,KAKhB,IAAI8e,EAgBAmhB,EAlBoBzgB,EAAI9J,YAC5BsgB,GAAsBtgB,GAEtB,IACI,MAAM2W,QAAezN,GAA8BlJ,GAAa,GAChE,GAAI2W,EAAOnM,sBACP,OACJpB,EAA6BuN,EAAOvN,0BACxC,OACO9e,GAEH,YADA0+B,EAAQ1+B,EAEZ,CACA,IAAI89B,IAAJ,CAIAv5B,EAAamR,EAAaoJ,GAE1B,IACImhB,QAAmCpf,GAA8BnL,GAAa,EAClF,OACO1V,GAEH,YADA0+B,EAAQ1+B,EAEZ,CACI89B,YAGEgC,EAAepqB,EAAahK,GAf9B,CAgBR,GA9EUg1B,CAAgBhrB,EAAahK,EAAM+U,EAC7C,GAkHA,SAAeqf,EAAepqB,EAAamJ,GAAa,OAAAzD,EAAAC,KAAA,iBACpD,MAAMqjB,EAAiB1+B,GAAQob,EAAAC,KAAA,iBACtBwD,EAIDke,GAAe/8B,SAHT2+B,EAAY,CAAE3+B,OAK5B,GAEA,GAAI3B,GAAasiC,sCAEPtiC,GAAasiC,8BACZtiC,GAAasiC,8BAChB7C,KACA,QAqHhB,SAAmBx4B,EAAKg4B,GACpB,GAAInE,OAAoB7zB,EACpB,QL3bR,SAA0BA,EAAKg4B,GAC3B,GAAKA,EAaD7D,GAAoBU,KAAY70B,OAbJ,CAC5B,MAAMtC,EAAQ,CACV22B,UAAWC,KAEXC,eAAgB,KAChBE,YAAa,OACbE,iBAAiB,GAIrBn3B,OAAO02B,QAAQoH,UAAU59B,EAAO,GAAIsC,EACxC,CAIJ,CK4aIu7B,CAAiBv7B,EAAKg4B,EAC1B,CAvHQwD,CAAUphB,EAAa4d,GACvBj/B,GAAau/B,oBAAsBloB,EAC5BrX,GAAasiC,8BACpB,MAAMI,OAAqC3lB,EAAAC,KAAA,iBACvC,IAAI2lB,EACJ,UACUlI,GAAuBpjB,EAAa2I,GAC9C,OACOre,GAEHghC,EAAsBhhC,CAC1B,CAGA,OAFA3B,GAAasiC,mCAAgC,EAC7CtiC,GAAawgC,mBAAoB,EAC1BmC,CACX,MACA3iC,GAAasiC,8BAAgCI,EAC7C,MAAMC,QAA4BD,EAElC,GADO1iC,GAAasiC,+BAChBK,UACMtC,EAAQsC,GACTniB,GAFT,CASA,GAAImf,IAAkBgD,EAAqB,CACvC,UACU7lB,GAAS,iBAAkBzF,EAAa2I,GAClD,OACOre,GAEH,SADM0+B,EAAQ1+B,IACT6e,EACD,MACR,CACA,GAAIif,GAAiB,GACjB,MACR,CAEA,IAAIA,GAAiB,GAArB,CAGA,GAAIz/B,GAAaygC,gBAAiB,CAC9BzgC,GAAaygC,qBAAkB,EAE/B,MAAMvoB,EAAQD,GAA0B,sBAAuBsnB,GAC/D,UACUtiB,GAAe/E,EAAOb,EAAa2I,GAC7C,OACOre,GAEH,SADM0+B,EAAQ1+B,IACT6e,EACD,MACR,CACA,GAAIif,GAAiB,GACjB,MACR,CACA,IAAK3C,GAAgByC,EAAqB,CACtC,MAAMqD,EAAyBC,GAA6BtD,GACtDuD,EAAyBD,GAA6BxrB,IAC7B,IAA3ByrB,IAC2B,IAA3BF,KAiIM1mB,EAhIO4mB,MAgID3mB,EAhIyBymB,IAmI5CxjC,MAAM+F,QAAQ+W,IAAU9c,MAAM+F,QAAQgX,IAEpCD,EAAKzb,SAAW0b,EAAK1b,QAAUyb,EAAKxW,MAAM,CAAC4V,EAAGpS,IAAMgT,EAAKhT,KAAOiT,EAAKjT,OApIhE4zB,EAAe,CAAEI,gBAAgB,GAEzC,CA6HR,IAAsBhhB,EAAMC,EAlHpB,OATA0gB,GAAkBC,EAAczb,GFlcpCrhB,GAAau+B,qBAAsB,EACnCC,KEmcQnnB,EAAYiJ,2BpD5TxB,SAA4CjJ,GACpCA,EAA2C,mCAC3CrX,GAAaghB,iCAAkC,EAEvD,CoDyTY+hB,CAAmC1rB,GRtT3CrX,GAAa04B,iBAAiBqB,QAAQlvB,SAASm4B,KAAM,CACjDC,WAAW,EACXC,SAAS,IQuTTtK,KACA54B,GAAamjC,oBAAsB9rB,EAmC3C,SAAuBgK,GACnB,MAAA5c,OAAO5E,QAAU4E,OAAO5E,MAAQ,IAChC4E,OAAO5E,MAAMujC,iBAAmB/hB,CACpC,CArCQgiB,CAAchiB,GACPhK,CApCH,CAnBJ,CAwDJ,GACJ,GACA,SAAekpB,GAAoBpN,EAAgBC,GAA+H,OAAArW,EAAAC,KAAAsW,UAAA,UAA/IgQ,GAAgBjiB,YAAEA,EAAA6d,qBAAaA,EAAAjgB,wBAAsBA,yBAAyBogB,EAAAC,sBAAwBA,EAAAK,cAAuBA,UAC5J,MAAMJ,EAAsB,OAAA5/B,EAAAK,GAAau/B,qBAAb5/B,EAAoC,KAC1D0X,QAAoBwY,GAA4BxO,GACtDnb,EAAamR,EAAakG,EAAA,CACtB2hB,uBACAG,yBACAkE,YAAa5D,IAAkB2D,EAC/B/D,uBACGD,IAGP15B,OAAOsJ,eAAemI,EAAa,uBAAwB,CACvDzJ,IAAA,KACIpN,GAAc,EAAO,oFAAqF,CACtGM,gBAAgB,EAChBD,UAAU,IAEP0+B,GAEXxwB,YAAY,IAKZ7I,EAAamR,EAFsB2H,GAA8BC,IAIrE,OAAO5H,CACX,GAYA,SAAS+iB,GAAqBz4B,EAAKwB,GAC/BnD,GAAaogC,yBAA0B,EAChChP,GAA4BzvB,GAC/BwB,GAEA7B,QAAQ6B,IAAIxB,G9G5ZpB,SAAoBX,EAAWE,GAAKL,SAAEA,UAKlCK,EAAM2C,EADN3C,EAAM6C,EAAc7C,IAEN,CACV,MAAMf,cAAEA,GAAkBH,EACpBmB,EAAMD,EACZ,GAAIf,EAAciB,IAAID,GAClB,OAGAhB,EAAckB,IAAIF,EAE1B,CACAnB,WAAagE,cAAbhE,UACAA,EAAaiD,OAAO/B,EAAK,OAC7B,C8G4YIsiC,CAAW,EAAO,CACd,gCACuB,wDACvB,kCACA,iFAEChhC,OAAO4yB,SACPvyB,KAAK,KAAM,CAAEhC,UAAU,GAChC,CA6BA,SAASgiC,GAA6BxrB,GAClC,MAAM1L,EAAI0L,EAAYhY,KAAK+qB,gBAAgBqZ,mBAC3C,IAAK93B,EACD,OAAO,EACX,IAAIlG,EAAMkG,EAAE3I,MACZ,MAAMwT,EAAkB7K,EAAE2J,UAEpBouB,EjBtdV,SAAqCvY,GACjC,MAAMuY,EAAqB,GAM3B,OALiBxP,GAAiB/I,GACzB7iB,QAAS8rB,IACVA,EAAQC,OACRqP,EAAmBpgC,KAAK8wB,EAAQC,SAEjCqP,CACX,CiB8c+BC,CAA4BntB,GAQvD,OAPIxR,EAAWS,KACXA,EAAMA,EAAI4R,EAAa,CACnBb,gBAAiB7K,EAAE2J,cAKf,IAAR7P,EACO,CACH+Q,KACGktB,EAAmBn5B,IAAK8pB,GACXhd,EAAYsd,YAAYN,KAOzC5uB,CACX,CAgBA,SAAem7B,GAAyCvpB,EAAasoB,EAAeF,GAAkB,OAAA1iB,EAAAC,KAAA,iBAClG,IACIrb,EACA6oB,EAFAoZ,GAAS,EAGb,IACIpZ,QAA4BqG,GAA8BxZ,EAAY3F,OAAQ2F,EAAYmH,cAAenH,EAAYoF,eAAegC,aAAcpH,EAAYoF,eAAe+P,kBACjL,OACOqX,GAGH,GAFAliC,EAAMkiC,EACND,GAAS,EA0BjB,SAAyCjiC,EAAK0V,EAAasoB,GACvD,IAAKvO,GAA4BzvB,GAC7B,OAAO,EAEX,GAAIg+B,EAIA,MAHAvF,GAAqBz4B,GAAK,GAGpBA,EAGNy4B,GAAqBz4B,GAAK,GAG9B,OADAsK,GAAaoL,EAAYgK,cAClB,CACX,CAxCYyiB,CAAgCniC,EAAK0V,EAAasoB,GAClD,MAAO,CAAEkB,MAAM,EAKvB,CACA,GAAIpB,IACA,MAAO,CAAEoB,MAAM,GACnB,GAAI+C,EACA,MAAO,CAAEjiC,OACbuE,EAAamR,EAAamT,GAC1B,UACU1N,GAAS,sBAAuBzF,EAAa2I,GACvD,OACO6jB,GAEHD,GAAS,CACb,CACA,OAAInE,IACO,CAAEoB,MAAM,GACf+C,EACO,CAAEjiC,OACN,CAAE0V,cACb,GElmBA,SAAe0sB,KAAa,OAAAhnB,EAAAC,KAAA,iBACxB7O,GAAkB,gBAClB,MAAM61B,uBAAEA,EAAAhJ,SAAwBA,EAAAiJ,QAAUA,GPkI9C,WACI,MAAMjJ,SAAEA,GAAah7B,GACfgkC,EAAkD,OAAzBv/B,OAAO02B,QAAQx2B,MACzCq/B,GACD/I,KAEJ,MAAMgJ,EAAU3H,KAEhB,OADAt8B,GAAag7B,SAAWiJ,EACjB,CAAED,yBAAwBhJ,WAAUiJ,UAC/C,CO3I0DC,GAMjDF,UAQT,SAA2ChJ,EAAUiJ,GAAS,OAAAlnB,EAAAC,KAAA,iBAC1D,MAAM8f,EAAemH,EAAQt/B,MAAM62B,qBAAkB,EAErD,GADyB2I,GAAWF,EAAQh9B,OAASk9B,GAAWnJ,EAAS/zB,MAAQg9B,EAAQh9B,MAAQ+zB,EAAS/zB,IAItG,YADA41B,GAAkBC,GAGtB,MACMsC,EAD0D,SAA9B6E,EAAQt/B,MAAM+2B,aAAyD,SAA/BV,EAASr2B,MAAM+2B,YAEnFwD,EAAwB+E,EAAQt/B,MAAM22B,WAAcN,EAASr2B,MAAM22B,UAAmB2I,EAAQt/B,MAAM22B,UAAYN,EAASr2B,MAAM22B,UAAhD,WAC/EyD,GAAqB,CAAEjC,eAAcoC,uBAAsBE,yBACrE,GAfcgF,CAA4BpJ,EAAUiJ,GAEpD,GAcA,SAASE,GAAWl9B,GAChB,OAAOA,EAAI5E,MAAM,KAAK,EAC1B,CCpDA,SAAegiC,GAAYC,GAAI,OAAAvnB,EAAAC,KAAA,iBAC3B,IAmCJ,SAA2BsnB,GACvB,QAAqB,IAAdA,EAAGC,QAAiBD,EAAGE,SAAYF,EAAGG,UAAaH,EAAGI,QAAWJ,EAAGK,QAC/E,CArCSC,CAAkBN,GACnB,OACJ,MAAM7S,EAoCV,SAAqB5jB,GACjB,KAA0B,MAAnBA,EAAOg3B,SAAiB,CAC3B,MAAMC,WAAEA,GAAej3B,EACvB,IAAKi3B,EACD,OAAO,KAEXj3B,EAASi3B,CACb,CACA,OAAOj3B,CACX,CA7CoBk3B,CAAYT,EAAGz2B,QAC/B,IAAK4jB,EACD,OACJ,MAAM5nB,EAAO4nB,EAAQC,aAAa,QAClC,GAAa,OAAT7nB,EACA,OACJ,GAAIkoB,GAAcN,GACd,OAIJ,GAAI5nB,EAAKnH,SAAS,M3B2BtB,SAA0BmH,GACtB,OAAIA,EAAKlH,WAAW,KACTkH,IAASpF,OAAOyH,SAASxE,KAC7B2pB,GAAuBxnB,KAAUwnB,GAAuB5sB,OAAOyH,SAASrC,KACnF,C2B/B8Bm7B,CAAiBn7B,GAKvC,OAHAy6B,EAAGW,sBAEH9H,GAAkBtzB,EAAKxH,MAAM,KAAK,IAGtC,GAAImvB,GAAcC,GACd,OAEJ,IAAIqL,EADJwH,EAAGW,iBAEH,CACI,MAAMt/B,EAAI8rB,EAAQC,aAAa,wBACrB,OAAN/rB,IACAm3B,EAAe,CAAEI,eAAsB,UAANv3B,GACzC,OACMo5B,GAAqB,CACvBjC,eACAzb,YAAaxX,EACbq1B,sBAAsB,GAE9B,kjGCzCAt6B,ItH4DA,WACI,MAAM5E,EAAeI,IACrBI,GAA+C,IAAjCR,EAAa8E,gBApCC,4GAoCmD,CAC3EjE,UAAU,EACVC,gBAAgB,IAEpBN,OAA+C,IAAjCR,EAAa8E,gBAA+BzE,EAAyB,CAC/EQ,UAAU,EACVC,gBAAgB,IAEpBd,EAAa8E,iBAAkB,EAE3B9E,EAAae,qBAAsB,EACvCT,GACJ,CsHnEA4kC,GzCiDA,SAAgD1d,GAA+BzK,EAAAC,KAAA,iBAEvEhd,GAAawnB,gCAAkCA,WACxCxnB,GAAa2tB,qBACpB3tB,GAAawnB,8BAAgCA,QAEvCkG,KAEd,GyCxDAyX,CAAiC3d,ICAjC,WAAkCzK,EAAAC,KAAA,iBAqB9BqhB,KACA9B,KACAuB,KHNAr5B,OAAOiI,iBAAiB,WAAYq3B,IGbpC,MAAMqB,EAQV,WAAiC,OAAAroB,EAAAC,KAAA,iBL0hBtBhd,GAAa8+B,oBKxhBdC,GAAqB,CACvBjC,aAAc,CAAEI,gBAAgB,GAChCgC,qBAAsB,KACtBG,wBAAwB,GAEhC,GAfmCgG,GFR/Bx6B,SAAS6B,iBAAiB,QAAS23B,IXkJnCzL,WapIMwM,CACV,GDVAE","names":["unique","arr","Array","from","Set","getGlobalObject","moduleId","defaultValue","globals","_a","globalThis","_vike","getGlobals","PROJECT_VERSION","globalObject","genGlobalConfig","instances","alreadyLogged","getGlobalObjectSafe","clientNotSingleInstance","assertSingleInstance","versions","assertWarning","length","pc","bold","underline","onlyOnce","showStackTrace","checkSingleInstance","condition","errorMessage","msg","key","has","add","console","warn","Error","createErrorWithCleanStackTrace","numberOfStackTraceLinesToRemove","err","process","cwd","node","release","name","stack","errStack","stackLines","str","split","linesRemoved","stackLine__cleaned","filter","line","includes","startsWith","isStackTraceLine","join","clean","isObject","value","logger","logType","log","showStackTraceList","WeakSet","push","projectTagWithVersion","assertUsage","errMsg","exitOnError","alwaysShowStackTrace","usageError","addPrefixProjectName","addPrefixAssertType","addWhitespace","onBeforeLog","error","exit","getProjectError","tag","prefix","color","showProjectVersion","isBrowser","window","scrollY","state","assertClientRouting","noContradiction","isClientRouting","cyan","isCallable","thing","Function","isArray","hasProp","obj","prop","type","propValue","val","every","v","Object","values","isObjectOfStrings","isPlainObject","getPrototypeOf","constructor","objectAssign","objAddendum","objAddendumCanBeOriginalObject","_isOriginalObject","defineProperties","getOwnPropertyDescriptors","slice","to","sliceArray","list","listSlice","start","end","el","parseUrl","url","baseServer","isUrl","hashString","hashOriginal","withoutHash","urlWithoutHash","parts","extractHash","hash","decodeSafe","searchString","searchOriginal","withoutSearch","urlWithoutHashNorSearch","extractSearch","baseURI","getBaseURI","search","searchAll","URLSearchParams","forEach","hasOwnProperty","protocol","origin","pathnameAbsoluteWithBase","pathname","parseOrigin","base","pathnameRelative","baseRestoreTrailingSlash","endsWith","pop","i","p","pathnameAbsolute","resolveUrlPathnameRelative","getPathnameAbsoluteWithBase","pathnameOriginal","isBaseMissing","isBaseServer","urlPathname","baseServerNormalized","removeBaseServer","href","urlRecreated","createUrlFromComponents","host","hostname","port","ret","parseInt","parseHost","replace","map","dir","urlComponent","decodeURIComponent","e","decodeURI","document","isUrlWithWebProtocol","uriWithoutProtocol","parseProtocol","rest","uri","before","after","test","SEP2","isUrlAbsolute","isUrlRelative","isUrlPathAbsolute","some","c","isWebUrlProtocol","assertUsageUrlAbsolute","errPrefix","string","getErrMsg","redirectHard","location","sleep","milliseconds","Promise","r","setTimeout","onPageHide","listener","addEventListener","visibilityState","genPromise","timeout","timeoutSeconds","resolve","reject","finished","promise_internal","resolve_","reject_","args","timeoutClear","timeouts","t","clearTimeout","promise","Proxy","get","target","errorPrefix","removeStackErrorPrefix","Reflect","bind","trackers","catchInfiniteLoop","functionName","maxNumberOfCalls","withinSeconds","now","Date","tracker","createTracker","getTime","count","warned","changeEnumerable","enumerable","descriptor","getOwnPropertyDescriptor","defineProperty","__spreadProps","deepEqual","x","y","ok","keys","tx","findAndParseJson","id","elem","getElementById","jsonStr","textContent","parse","reviver","_key","replacement","replaceAll","resolved","higherFirst","getValue","element1","element2","val1","val2","makeFirst","isNotNullish","stringifyStringArray","stringList","objectDefineProperty","_b","__objRest","extTemplates","scriptFileExtensionList","isScriptFile","filePath","ext","getPageFilesClientSide","pageFilesAll","pageId","determine","getPageFilesServerSide","envIsClient","env","pageFilesRelevant","isRelevant","fileType","sort","e1First","e2First","noOrder","e1","e2","isDefaultPageFile","e1_isRenderer","isRendererPageFile","e2_isRenderer","e1_distance","getPathDistance","e2_distance","isEnv","getPageFilesSorter","getPageIdFile","iso","files","pageIdFile","pageIdFileEnv","pageIdFileIso","getRendererFile","rendererFileEnv","rendererFileIso","pathA","pathB","idx","pathAWithoutCommon","pathBWithoutCommon","BUILT_IN_CLIENT_ROUTER","BUILT_IN_CLIENT","getPageContextRequestUrl","pageContextRequestUrl","fileExtension","hasTrailingSlash","pathnameModified","urlToFile","getPageConfig","pageConfigs","pageConfig","find","getConfigValueFilePathToShowToUser","definedAtData","definedBy","filePathToShowToUser","getHookFilePathToShowToUser","getConfigDefinedAtOptional","sentenceBegin","configName","begin","getDefinedAtString","definedAtString","definedAt","operation","getDefinedByString","fileExportPathToShowToUser","exportPath","exportName","exportObjectPath","suffix","getExportPath","getConfigValueTyped","configValue","typeActual","valuePrintable","String","JSON","stringify","getValuePrintable","problem","configDefinedAt","assertConfigValueType","getConfigValueRuntime","configValues","assertPageContextProvidedByUser","pageContextProvidedByUser","hookName","hookFilePath","assertOnBeforeRenderHookReturn","hookReturnValue","keysExpected","keysUnknown","assertHookReturnedObject","pageContext","getHookFromPageContext","exports","hooksTimeout","config","hookTimeout","getHookTimeout","hookFn","file","exportsAll","exportValue","getHook","getHookFromPageContextNew","hooks","getHookFromPageConfigGlobal","pageConfigGlobal","getHookFromConfigValue","getHookTimeoutGlobal","getHookFromPageConfigGlobalCumulative","getHookTimeoutDefault","assertHookFn","hooksTimeoutProvidedByUser","hooksTimeoutProvidedbyUserNormalized","hooksTimeoutProvidedByUserNormalized","entries","hookTimeoutProvidedbyUser","warning","timeoutName","timeoutVal","getHooksTimeoutProvidedByUserNormalized","providedbyUser","isPrerendering","toLowerCase","flags","DEBUG","_c","define_process_env_default","getDEBUG","getFlagsActivated","flagsActivated","match","isAll","isGlobal","humanizeTime","seconds","n","round","plural","rounded","toFixed","addIs404ToPageProps","is404","pageProps","addIs404","isDebug","stackTraceLimit","Infinity","flag","f","assertFlagsActivated","NOT_SERIALIZABLE","getProxyForPublicUsage","objName","skipOnInternalProp","fallback","_","propStr","propName","isKeyDotNotationCompatible","onNotSerializable","getProp","prepareGlobalContextForPublicUsage","globalContext","preparePageContextForPublicUsage","_isProxyObject","descriptors","fromEntries","key1","key2","compareString","str2","str1","sortPageContext","globalContextPublic","_globalContext","assertPropertyGetters","isPropertyGetter","userHookErrors","WeakMap","execHook","__async","this","execHookDirect","pageContextForPublicUsage","all","hook","hookReturn","execHookDirectAsync","__spreadValues","execHookDirectSingle","hooksWithResult","hookFnCaller","timeoutErr","timeoutWarn","clearTimeouts","currentTimeoutWarn","currentTimeoutErr","isNotDisabled","providePageContextInternal","set","execHookDirectSync","then","errIntro","execHookGuard","prepareForPublicUsage","_pageFilesAll","_pageConfigs","pageRouteFile","fileExports","guard","findPageGuard","stamp","isAbortError","getPageContextFromAllRewrites","pageContextsFromRewrite","urlRewrites","urlRewrite","_urlRewrite","indexOf","assertNoInfiniteLoop","pageContextFromAllRewrites","pageContextFromRewrite","assign","isServerSideError","preparePageContextForPublicUsageClientShared","Page","resolveGetters","supportVueReactiviy","preparePageContextForPublicUsageClientMinimal","preparePageContextForPublicUsageClient","getPageContextFromHooks_serialized","pageContextSerialized","pageContextSerializedInHtml","getPageContextSerializedInHtml","processPageContextFromServer","_hasPageContextFromServer","getPageContextFromServerHooks","isErrorPage","pageContextFromServerHooks","isOldDesign","hasOnBeforeRenderServerSideOnlyHook","pageFilesServerSideOnly","exportNames","loadExportNames","analyzePageServerSide","pageContextInitIsPassedToClient","hasServerOnlyHook","hasPageContextServer","res","pageContextUrl","urlOriginal","response","fetch","contentType","headers","contentTypeCorrect","isCorrect","status","is404ServerSideRouted","responseText","text","pageContextFromServer","_urlRedirect","abortStatusCode","isAbortPageContext","pageContextAbort","_pageContextAbort","AbortRender","fetchPageContextFromServer","getPageContextFromClientHooks","dataHookExecuted","hookClientOnlyExists","execHookDataLike","dataHookEnv","getHookEnv","client","server","execHookClient","pageContextFromHook","data","execHookData","pageContextFromOnBeforeRender","execHookOnBeforeRender","hookEnv","removeBuiltInOverrides","getUrlParsed","urlResolved","isBaseToBeRemoved","urlLogical","urlHandler","_urlHandler","_baseServer","urlPathnameGetter","urlGetter","call","urlParsedGetter","urlParsed","hashIsAvailable","warnHashNotAvailable","urlParsedEnhanced","enforceTrue","forbiddenDefaultExports","determinePageIdOld","pageSuffix","isErrorPageId","_isV1Design","getPageFileObject","suffix2","determineFileType","pageFile","isRendererFilePath","defaultPageFilePath","isDefaultFilePath","defaultPageDir","filePathSegment","isAncestorDefaultPage","isErrorPageFile","SIDE_EXPORTS_TOLERATE","SIDE_EXPORTS_DO_NOT_CHECK","parsePageConfigsSerialized","pageConfigsSerialized","pageConfigGlobalSerialized","pageConfigSerialized","parseConfigValuesSerialized","configValuesSerialized","configValueType","getConfigDefinedAt","assertRouteConfigValue","configValueSeriliazed","valueSerialized","common","valueSerializedElement","sideExports","parseValueSerialized","addSideExports","sideExport","getDefinedAtFile","parseTransform","definedAtFile","exportValues","isValid","exportNamesValid","exportDefault","code","exportNamed","exportNamesInvalid","exportInvalid","assertPlusFileExport","parseVirtualFileExportsGlobalEntry","virtualFileExportsGlobalEntry","pageFilesLazy","assertPageConfigsSerialized","assertPageConfigGlobalSerialized","pageFilesMap","parseGlobResult","globValue","loadModule","loadFile","explainer","assertExportValues","pageFilesExportNamesLazy","moduleExports","pageFilesEager","pageFilesExportNamesEager","pageFilesList","globObject","globFiles","getPublicCopy","configInternal","_source","source","_sources","sources","_from","resolvePageConfigPublic","pageConfigGlobalValues","pageConfigValues","resolveConfigPublic_V1Design","resolvePageContextConfig","pageFiles","configEntries","element","makeLast","isFromDefaultExport","isTemplateFile","defaultExportName","defaultExportValue","assertDefaultExports","getExportValues","exportSource","_filePath","_fileType","_isFromDefaultExport","configsStandard","configsCumulative","configsComputed","pageExports","pageContextAddendum","configurable","resolveGlobalContextConfig","globalContextAddendum","getConfigValues","globalConfigPublicBase","pages","pageConfigPublic","page","route","routeFilesystem","routeString","resolveGlobalConfigPublicPage","globalConfigPublic","_globalConfigPublic","resolveGlobalConfigPublic","addSrc","src","addLegacy","configValueFilePathToShowToUser","configDefinedByFile","createGlobalContextShared","addGlobalContext","addGlobalContextTmp","addGlobalContextAsync","previousCreateGlobalContextPromise","allPageIds","fileIds","allPageIds2","getAllPageIds","isGlobalContext","_virtualFileExportsGlobalEntry","_pageConfigGlobal","_allPageIds","createGlobalContextBase","isNewGlobalContext","onCreateGlobalContextHooks","hooksCalled","objOld","objNew","hooks1","hooks2","hooksFn1","hooksFn2","hooksAreEqual","hookArg","hookArgForPublicUsage","execHookGlobal","globalContextInitialPromise","globalContextInitialPromiseResolve","getGlobalContextClientInternalShared","globalContextPromise","isClientSide","assertSyncRouting","warnDeprecatedAllowKey","assertRouteParams","result","loadPageRoutes","onBeforeRouteHook","filesystemRoots","onBeforeRoute","filesystemRoutingRoot","filesystemRoot","dirname","urlRoot","getGlobalHooks","pageRoutes","comesFromV1PageConfig","pageRoute","routeDefinedAtString","routeType","routeFunction","routeFunctionFilePath","definedAtLocation","routeFilesystemDefinedBy","default","fsBase","filesystemRoute","deduceRouteStringFromFilesystemPath","getPageRoutes","loadPageRoutesSync","dirPath","getGlobalContextClientInternal","_pageRoutes","_onBeforeRouteHook","createPageContextClientSide","pageContextCreated","isPageContext","createPageContextObject","pageContextUrlComputed","getPageContextUrlComputed","createPageContextShared","findPageConfig","loadAndParseVirtualFilePageEntry","isDev","moduleExportsPromise","loadVirtualFilePageEntry","virtualFileExportsPageEntry","parseVirtualFileExportsPageEntry","isPageEntryLoaded","errStamp","loadPageConfigsLazyClientSide","pageFilesClientSide","pageConfigLoaded","s","message","isFetchError","_pageFilesLoaded","isErrorFetchingStaticAssets","normalizeClientSideUrl","options","urlCurrent","isLinkSkipped","linkTag","getAttribute","isHrefSamePageHash","rel","hasAttribute","isLinkExternal","isLinkIgnored","hasBaseServer","_disableAutomaticLinkInterception","attrVal","isVikeLink","getExportNames","analyzeExports","pageFilesServerSide","isHtmlOnly","analyzePageClientSide","pageFilesClientSide_","removeOverriddenPageFiles","clientEntries","clientDependencies","onlyAssets","eagerlyImported","clientEntry","getVikeClientEntry","determineClientEntry","isClientSideRoutable","_0","_1","_2","arguments","sharedPageFilesAlreadyLoaded","analyzePageClientSideInit","isClientRuntimeLoaded","_d","analyzeClientSide","PARAM_TOKEN_OLD","resolveRouteString","errPrefix2","highlight","assertRouteString","segments","parseRouteString","routeRegexStrInner","segment","param","glob","static","routeRegex","RegExp","routeRegexMatch","routeParams","segmentsValue","globIdx","hasMultipleGlobs","pushStatic","segmentLast","routeSegment","analyzeRouteString","countStaticParts","Boolean","numberOfStaticPartsBeginning","numberOfStaticParts","reduce","sum","a","numberOfParams","numberOfGlobs","isStaticRouteString","sortMatches","routeMatch1","routeMatch2","precedence1","precedence","precedence2","lowerFirst","execHookOnBeforeRoute","pageContextFromOnBeforeRouteHook","isObjectWithKeys","conjunction","colorizer","firsts","last","lastComma","joinEnglish","deprecatedReturn","pageContextAddendumHook","getPageContextFromHook","_routingProvidedByOnBeforeRouteHook","skipOnBeforeRouteHook","pageContextFromRoute","routeMatches","resolveRouteFunction","routeMatch","resolvePrecedence","winner","_routeMatch","pageContextCurrent","getPageContextCurrent","setPageContextCurrent","PAGE_CONTEXT_MAX_AGE_DEFAULT","prefetchSettingTrue","staticAssets","prefetchSettingFalse","prefetchSettingDefault","getPrefetchSettings","prefetchSetting","prefetchStaticAssets","prefetch","attr","Number","isNaN","linkPrefetchHandlerAdded","addLinkPrefetchHandlers_debounce","mutationObserver","MutationObserver","addLinkPrefetchHandlers","linkTags","getElementsByTagName","prefetchedPageContexts","populatePageContextPrefetchCache","isBrilloutDocpress","setPageContextPrefetchCache","resultMaxAge","prefetchSettings","getResultMaxAge","getCacheKey","resultFetchedAt","requestIdleCallback","addLinkPrefetchHandlers_apply","prefetchOnEvent","passive","IntersectionObserver","entry","isIntersecting","observe","event","urlOfLink","pageContextLink","getPageContextLink","disableClientRouting","prefetchAssets","found","isExpired","prefetchPageContextFromServerHooks","execHookOnRenderClient","renderHook","urlToShowToUser","getUrlToShowToUser","pageClientsFilesLoaded","getCurrentUrl","monkeyPatched","previous","enhanceHistoryState","isVikeEnhanced","history","replaceHistoryState","stateNotEnhanced","timestamp","getTimestamp","scrollPosition","getScrollPosition","triggeredBy","stateVikeEnhanced","_isVikeEnhanced","enhance","getState","scrollX","saveScrollPosition","url_","replaceState","replaceHistoryStateOriginal","History","prototype","getHistoryInfo","initHistory","funcName","funcOriginal","stateOriginal","stateEnhanced","queueMicrotask","setScrollPosition","scrollTarget","hasTextFragment","scrollToTextFragment","setScroll","preserveScroll","scrollToHashOrTop","getUrlHash","hashTarget","getElementsByName","scrollIntoView","focus","scrollToTop","scroll","scrollTo","done","requestAnimationFrame","autoSaveScrollPosition","func","waitTime","isQueued","throttle","Math","ceil","scrollRestoration_init","scrollRestoration_enable","initialRenderIsDone","scrollRestoration_disable","scrollRestoration","logErrorClient","isAlreadyLogged","firstRenderStartPromise","firstRenderStartPromiseResolve","renderCounter","renderPageClientSide","renderArgs","overwriteLastHistoryEntry","isBackwardNavigation","redirectCount","doNotRenderIfSamePage","isClientSideNavigation","pageContextInitClient","previousPageContext","disconnect","isRenderOutdated","setHydrationCanBeAborted","isFirstRender","renderNumber","hydrationCanBeAborted","isRenderCleanup","getIsRenderOutdated","rewriteCount","abortCalls","assertNoInfiniteAbortLoop","pageContextBeginArgs","clientRoutingIsDisabled","onError","handleError","getPageContextBegin","isFirstRenderDone","isTransitioning","isClientRoutable","isSamePage","loadPageConfigsLazyClientSideAndExecHook","skip","isReact1","__REACT_DEVTOOLS_GLOBAL_HOOK__","renderers","size","isReact2","rendererInterfaces","isReact3","__vite_plugin_react_preamble_installed__","isReact","pageContextAugmented","getPageContextFromHooks_isHydration","renderPageView","pageContextPrefetched","getPageContextPrefetched","pageContextFromClientHooks","renderPageNominal","errorWhileRendering","urlRedirect","handleAbortError","errorPageId","errorPageConfigs","errorPageIds","getErrorPageId","renderErrorPage","onRenderClientPreviousPromise","pushState","pushHistoryState","changeUrl","onRenderClientPromise","onRenderClientError","keepScrollPositionPrev","getKeepScrollPositionSetting","keepScrollPositionNext","setPageContextInitIsPassedToClient","body","childList","subtree","renderedPageContext","fullyRenderedUrl","stampFinished","isForErrorPage","isHydration","assertInfo","keepScrollPosition","routeParameterList","getRouteStringParameterList","hasErr","err_","handleErrorFetchingStaticAssets","onPopState","isHistoryStateEnhanced","current","onPopStateBegin","removeHash","handleBackForwardNavigation","onLinkClick","ev","button","ctrlKey","shiftKey","altKey","metaKey","isNormalLeftClick","tagName","parentNode","findLinkTag","isHrefCurrentUrl","preventDefault","assertSingleInstance_onClientEntryClientRouting","setVirtualFileExportsGlobalEntry","renderFirstPagePromise","renderFirstPage","initClientRouter"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122],"sources":["../../../../node_modules/vike/dist/esm/utils/unique.js","../../../../node_modules/vike/dist/esm/utils/getGlobalObject.js","../../../../node_modules/vike/dist/esm/utils/PROJECT_VERSION.js","../../../../node_modules/vike/dist/esm/utils/assertSingleInstance.js","../../../../node_modules/vike/dist/esm/utils/createErrorWithCleanStackTrace.js","../../../../node_modules/vike/dist/esm/utils/isNodeJS.js","../../../../node_modules/vike/dist/esm/utils/isObject.js","../../../../node_modules/vike/dist/esm/utils/assert.js","../../../../node_modules/vike/dist/esm/utils/isBrowser.js","../../../../node_modules/vike/dist/esm/utils/assertRoutingType.js","../../../../node_modules/vike/dist/esm/utils/isCallable.js","../../../../node_modules/vike/dist/esm/utils/isArray.js","../../../../node_modules/vike/dist/esm/utils/hasProp.js","../../../../node_modules/vike/dist/esm/utils/isArrayOfStrings.js","../../../../node_modules/vike/dist/esm/utils/isObjectOfStrings.js","../../../../node_modules/vike/dist/esm/utils/isPlainObject.js","../../../../node_modules/vike/dist/esm/utils/objectAssign.js","../../../../node_modules/vike/dist/esm/utils/slice.js","../../../../node_modules/vike/dist/esm/utils/parseUrl.js","../../../../node_modules/vike/dist/esm/utils/redirectHard.js","../../../../node_modules/vike/dist/esm/utils/sleep.js","../../../../node_modules/vike/dist/esm/utils/onPageVisibilityChange.js","../../../../node_modules/vike/dist/esm/utils/genPromise.js","../../../../node_modules/vike/dist/esm/utils/catchInfiniteLoop.js","../../../../node_modules/vike/dist/esm/utils/changeEnumerable.js","../../../../node_modules/vike/dist/esm/utils/deepEqual.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/onLoad.js","../../../../node_modules/vike/dist/esm/client/shared/getJsonSerializedInHtml.js","../../../../node_modules/vike/dist/esm/utils/sorter.js","../../../../node_modules/vike/dist/esm/utils/isNullish.js","../../../../node_modules/vike/dist/esm/utils/stringifyStringArray.js","../../../../node_modules/vike/dist/esm/utils/objectDefineProperty.js","../../../../node_modules/vike/dist/esm/utils/isScriptFile.js","../../../../node_modules/vike/dist/esm/shared/getPageFiles/getAllPageIdFiles.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/getPageContext/removeBuiltInOverrides.js","../../../../node_modules/vike/dist/esm/shared/getPageContextRequestUrl.js","../../../../node_modules/vike/dist/esm/utils/urlToFile.js","../../../../node_modules/vike/dist/esm/shared/page-configs/helpers.js","../../../../node_modules/vike/dist/esm/shared/page-configs/getConfigDefinedAt.js","../../../../node_modules/vike/dist/esm/shared/page-configs/getExportPath.js","../../../../node_modules/vike/dist/esm/shared/page-configs/getConfigValueTyped.js","../../../../node_modules/vike/dist/esm/utils/getValuePrintable.js","../../../../node_modules/vike/dist/esm/shared/page-configs/getConfigValueRuntime.js","../../../../node_modules/vike/dist/esm/shared/assertPageContextProvidedByUser.js","../../../../node_modules/vike/dist/esm/shared/assertOnBeforeRenderHookReturn.js","../../../../node_modules/vike/dist/esm/shared/assertHookReturnedObject.js","../../../../node_modules/vike/dist/esm/shared/hooks/getHook.js","../../../../node_modules/vike/dist/esm/utils/debug.js","../../../../node_modules/vike/dist/esm/utils/humanizeTime.js","../../../../node_modules/vike/dist/esm/shared/addIs404ToPageProps.js","../../../../node_modules/vike/dist/esm/shared/route/utils.js","../../../../node_modules/vike/dist/esm/shared/NOT_SERIALIZABLE.js","../../../../node_modules/vike/dist/esm/shared/getProxyForPublicUsage.js","../../../../node_modules/vike/dist/esm/utils/getPropAccessNotation.js","../../../../node_modules/vike/dist/esm/shared/prepareGlobalContextForPublicUsage.js","../../../../node_modules/vike/dist/esm/shared/preparePageContextForPublicUsage.js","../../../../node_modules/vike/dist/esm/utils/compareString.js","../../../../node_modules/vike/dist/esm/utils/isPropertyGetter.js","../../../../node_modules/vike/dist/esm/shared/hooks/execHook.js","../../../../node_modules/vike/dist/esm/shared/route/execHookGuard.js","../../../../node_modules/vike/dist/esm/shared/route/abort.js","../../../../node_modules/vike/dist/esm/shared/misc/pageContextInitIsPassedToClient.js","../../../../node_modules/vike/dist/esm/shared/misc/isServerSideError.js","../../../../node_modules/vike/dist/esm/client/shared/preparePageContextForPublicUsageClientShared.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/preparePageContextForPublicUsageClient.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/getPageContextFromHooks.js","../../../../node_modules/vike/dist/esm/shared/htmlElementIds.js","../../../../node_modules/vike/dist/esm/shared/getPageFiles/analyzePageServerSide.js","../../../../node_modules/vike/dist/esm/shared/getPageContextUrlComputed.js","../../../../node_modules/vike/dist/esm/shared/getPageFiles/assert_exports_old_design.js","../../../../node_modules/vike/dist/esm/shared/determinePageIdOld.js","../../../../node_modules/vike/dist/esm/shared/error-page.js","../../../../node_modules/vike/dist/esm/shared/getPageFiles/getPageFileObject.js","../../../../node_modules/vike/dist/esm/shared/getPageFiles/fileTypes.js","../../../../node_modules/vike/dist/esm/shared/page-configs/assertPlusFileExport.js","../../../../node_modules/vike/dist/esm/shared/page-configs/serialize/parsePageConfigsSerialized.js","../../../../node_modules/vike/dist/esm/shared/getPageFiles/parseVirtualFileExportsGlobalEntry.js","../../../../node_modules/vike/dist/esm/shared/page-configs/resolveVikeConfigPublic.js","../../../../node_modules/vike/dist/esm/shared/createGlobalContextShared.js","../../../../node_modules/vike/dist/esm/utils/objectReplace.js","../../../../node_modules/vike/dist/esm/client/shared/getGlobalContextClientInternalShared.js","../../../../node_modules/vike/dist/esm/shared/route/resolveRouteFunction.js","../../../../node_modules/vike/dist/esm/utils/isPromise.js","../../../../node_modules/vike/dist/esm/shared/route/loadPageRoutes.js","../../../../node_modules/vike/dist/esm/shared/route/deduceRouteStringFromFilesystemPath.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/getGlobalContextClientInternal.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/createPageContextClientSide.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/getBaseServer.js","../../../../node_modules/vike/dist/esm/shared/createPageContextShared.js","../../../../node_modules/vike/dist/esm/shared/page-configs/findPageConfig.js","../../../../node_modules/vike/dist/esm/shared/page-configs/loadAndParseVirtualFilePageEntry.js","../../../../node_modules/vike/dist/esm/client/shared/loadPageConfigsLazyClientSide.js","../../../../node_modules/vike/dist/esm/client/shared/normalizeClientSideUrl.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/isLinkSkipped.js","../../../../node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide/getExportNames.js","../../../../node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide/analyzeExports.js","../../../../node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide.js","../../../../node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide/determineClientEntry.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/isClientSideRoutable.js","../../../../node_modules/vike/dist/esm/shared/getPageFiles/analyzeClientSide.js","../../../../node_modules/vike/dist/esm/shared/route/resolveRouteString.js","../../../../node_modules/vike/dist/esm/utils/escapeRegex.js","../../../../node_modules/vike/dist/esm/shared/route/resolvePrecedence.js","../../../../node_modules/vike/dist/esm/shared/route/execHookOnBeforeRoute.js","../../../../node_modules/vike/dist/esm/utils/isObjectWithKeys.js","../../../../node_modules/vike/dist/esm/utils/joinEnglish.js","../../../../node_modules/vike/dist/esm/shared/route/index.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/getPageContextCurrent.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/prefetch/getPrefetchSettings.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/prefetch.js","../../../../node_modules/vike/dist/esm/client/shared/execHookOnRenderClient.js","../../../../node_modules/vike/dist/esm/client/shared/getCurrentUrl.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/history.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/setScrollPosition.js","../../../../node_modules/vike/dist/esm/utils/throttle.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/scrollRestoration.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/logErrorClient.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/renderPageClientSide.js","../../../../node_modules/vike/dist/esm/utils/isReact.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/initOnPopState.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/initOnLinkClick.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/entry.js","../../../../node_modules/vike/dist/esm/client/runtime-client-routing/initClientRouter.js"],"sourcesContent":["export function unique(arr) {\n    return Array.from(new Set(arr));\n}\n","export { getGlobalObject };\n/**\n * Share information across module instances.\n *\n * @__NO_SIDE_EFFECTS__\n */\nfunction getGlobalObject(moduleId, defaultValue) {\n    const globals = getGlobals();\n    const globalObject = (globals[moduleId] ?? (globals[moduleId] = defaultValue));\n    return globalObject;\n}\nfunction getGlobals() {\n    var _a;\n    globalThis._vike ?? (globalThis._vike = {});\n    (_a = globalThis._vike).globals ?? (_a.globals = {});\n    return globalThis._vike.globals;\n}\n","// Automatically updated by @brillout/release-me\nexport const PROJECT_VERSION = '0.4.245';\n","export { assertSingleInstance_onClientEntryServerRouting };\nexport { assertSingleInstance_onClientEntryClientRouting };\nexport { assertSingleInstance_onAssertModuleLoad };\n//  - Show warning if there are two different Vike versions loaded\n//  - Show warning if entry of Client Routing and entry of Server Routing are both loaded\n//  - Show warning if Vike is loaded twice\nimport { unique } from './unique.js';\nimport { getGlobalObject } from './getGlobalObject.js';\nimport pc from '@brillout/picocolors';\nimport { PROJECT_VERSION } from './PROJECT_VERSION.js';\n/* Use original assertWarning() after all CJS is removed from node_modules/vike/dist/\nimport { assertWarning } from './assert.js'\n*/\nlet globalObject;\n// getGlobalObjectSafe() can be called before this line\nglobalObject ?? (globalObject = genGlobalConfig());\nfunction genGlobalConfig() {\n    return getGlobalObject('utils/assertSingleInstance.ts', {\n        instances: [],\n        alreadyLogged: new Set(),\n    });\n}\n// We need getGlobalObjectSafe() because globalObject is `undefined` when exported functions are called before globalObject is initialized\nfunction getGlobalObjectSafe() {\n    globalObject ?? (globalObject = genGlobalConfig());\n    return globalObject;\n}\nconst clientRuntimesClonflict = 'Client runtime of both Server Routing and Client Routing loaded https://vike.dev/client-runtimes-conflict';\nconst clientNotSingleInstance = 'Client runtime loaded twice https://vike.dev/client-runtime-duplicated';\nfunction assertSingleInstance() {\n    const globalObject = getGlobalObjectSafe();\n    {\n        const versions = unique(globalObject.instances);\n        assertWarning(versions.length <= 1, \n        // Do *NOT* patch Vike to remove this warning: you *will* eventually encounter the issues listed at https://vike.dev/warning/version-mismatch\n        // - This happened before: https://github.com/vikejs/vike/issues/1108#issuecomment-1719061509\n        `vike@${pc.bold(versions[0])} and vike@${pc.bold(versions[1])} loaded which is highly discouraged, see ${pc.underline('https://vike.dev/warning/version-mismatch')}`, { onlyOnce: true, showStackTrace: false });\n    }\n    if (globalObject.checkSingleInstance && globalObject.instances.length > 1) {\n        /*/ Not sure whether circular dependency can cause problems? In principle not since client-side code is ESM.\n        console.warn(clientNotSingleInstance)\n        /*/\n        assertWarning(false, clientNotSingleInstance, { onlyOnce: true, showStackTrace: true });\n        //*/\n    }\n}\nfunction assertSingleInstance_onClientEntryServerRouting(isProduction) {\n    const globalObject = getGlobalObjectSafe();\n    assertWarning(globalObject.isClientRouting !== true, clientRuntimesClonflict, {\n        onlyOnce: true,\n        showStackTrace: true,\n    });\n    assertWarning(globalObject.isClientRouting === undefined, clientNotSingleInstance, {\n        onlyOnce: true,\n        showStackTrace: true,\n    });\n    globalObject.isClientRouting = false;\n    if (isProduction)\n        globalObject.checkSingleInstance = true;\n    assertSingleInstance();\n}\nfunction assertSingleInstance_onClientEntryClientRouting(isProduction) {\n    const globalObject = getGlobalObjectSafe();\n    assertWarning(globalObject.isClientRouting !== false, clientRuntimesClonflict, {\n        onlyOnce: true,\n        showStackTrace: true,\n    });\n    assertWarning(globalObject.isClientRouting === undefined, clientNotSingleInstance, {\n        onlyOnce: true,\n        showStackTrace: true,\n    });\n    globalObject.isClientRouting = true;\n    if (isProduction)\n        globalObject.checkSingleInstance = true;\n    assertSingleInstance();\n}\n// Called by utils/assert.ts which is (most certainly) loaded by all entries. That way we don't have to call a callback for every entry. (There are a lot of entries: `client/router/`, `client/`, `node/runtime/`, `node/vite/`, `node/cli`.)\nfunction assertSingleInstance_onAssertModuleLoad() {\n    const globalObject = getGlobalObjectSafe();\n    globalObject.instances.push(PROJECT_VERSION);\n    assertSingleInstance();\n}\nfunction assertWarning(condition, errorMessage, { onlyOnce, showStackTrace }) {\n    const globalObject = getGlobalObjectSafe();\n    if (condition) {\n        return;\n    }\n    const msg = `[Vike][Warning] ${errorMessage}`;\n    if (onlyOnce) {\n        const { alreadyLogged } = globalObject;\n        const key = onlyOnce === true ? msg : onlyOnce;\n        if (alreadyLogged.has(key)) {\n            return;\n        }\n        else {\n            alreadyLogged.add(key);\n        }\n    }\n    if (showStackTrace) {\n        console.warn(new Error(msg));\n    }\n    else {\n        console.warn(msg);\n    }\n}\n","export { createErrorWithCleanStackTrace };\nimport { isNodeJS } from './isNodeJS.js';\nfunction createErrorWithCleanStackTrace(errorMessage, numberOfStackTraceLinesToRemove) {\n    const err = new Error(errorMessage);\n    if (isNodeJS()) {\n        err.stack = clean(err.stack, numberOfStackTraceLinesToRemove);\n    }\n    return err;\n}\nfunction clean(errStack, numberOfStackTraceLinesToRemove) {\n    if (!errStack) {\n        return errStack;\n    }\n    const stackLines = splitByLine(errStack);\n    let linesRemoved = 0;\n    const stackLine__cleaned = stackLines\n        .filter((line) => {\n        // Remove internal stack traces\n        if (line.includes(' (internal/') || line.includes(' (node:internal')) {\n            return false;\n        }\n        if (linesRemoved < numberOfStackTraceLinesToRemove && isStackTraceLine(line)) {\n            linesRemoved++;\n            return false;\n        }\n        return true;\n    })\n        .join('\\n');\n    return stackLine__cleaned;\n}\nfunction isStackTraceLine(line) {\n    return line.startsWith('    at ');\n}\nfunction splitByLine(str) {\n    // https://stackoverflow.com/questions/21895233/how-in-node-to-split-string-by-newline-n\n    return str.split(/\\r?\\n/);\n}\n","export function isNodeJS() {\n    if (typeof process === 'undefined')\n        return false;\n    if (!process.cwd)\n        return false;\n    // https://stackoverflow.com/questions/4224606/how-to-check-whether-a-script-is-running-under-node-js/35813135#35813135\n    if (!process.versions || typeof process.versions.node === 'undefined')\n        return false;\n    // https://stackoverflow.com/questions/4224606/how-to-check-whether-a-script-is-running-under-node-js/35813135#comment92529277_35813135\n    if (!process.release || process.release.name !== 'node')\n        return false;\n    return true;\n}\n","export function isObject(value) {\n    return typeof value === 'object' && value !== null;\n}\n","export { assert };\nexport { assertUsage };\nexport { assertWarning };\nexport { assertInfo };\nexport { getProjectError };\nexport { addOnBeforeLogHook };\nexport { getAssertErrMsg };\nexport { overwriteAssertProductionLogger };\nexport { isBug };\nexport { setAlwaysShowStackTrace };\nimport { assertSingleInstance_onAssertModuleLoad } from './assertSingleInstance.js';\nimport { createErrorWithCleanStackTrace } from './createErrorWithCleanStackTrace.js';\nimport { getGlobalObject } from './getGlobalObject.js';\nimport { isObject } from './isObject.js';\nimport { PROJECT_VERSION } from './PROJECT_VERSION.js';\nimport pc from '@brillout/picocolors';\nconst globalObject = getGlobalObject('utils/assert.ts', {\n    alreadyLogged: new Set(),\n    // Production logger. Overwritten by loggerNotProd.ts in non-production environments.\n    logger(msg, logType) {\n        if (logType === 'info') {\n            console.log(msg);\n        }\n        else {\n            console.warn(msg);\n        }\n    },\n    showStackTraceList: new WeakSet(),\n});\nassertSingleInstance_onAssertModuleLoad();\nconst projectTag = `[vike]`;\nconst projectTagWithVersion = `[vike@${PROJECT_VERSION}]`;\nconst bugTag = 'Bug';\nconst numberOfStackTraceLinesToRemove = 2;\n// @__NO_SIDE_EFFECTS__\nfunction assert(condition, debugInfo) {\n    if (condition)\n        return;\n    const debugStr = (() => {\n        if (!debugInfo) {\n            return null;\n        }\n        const debugInfoSerialized = typeof debugInfo === 'string' ? debugInfo : JSON.stringify(debugInfo);\n        return pc.dim(`Debug info for Vike maintainers (you can ignore this): ${debugInfoSerialized}`);\n    })();\n    const link = pc.underline('https://github.com/vikejs/vike/issues/new?template=bug.yml');\n    let errMsg = [\n        `You stumbled upon a Vike bug. Go to ${link} and copy-paste this error. A maintainer will fix the bug (usually within 24 hours).`,\n        debugStr,\n    ]\n        .filter(Boolean)\n        .join(' ');\n    errMsg = addWhitespace(errMsg);\n    errMsg = addPrefixAssertType(errMsg, bugTag);\n    errMsg = addPrefixProjectName(errMsg, true);\n    const internalError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);\n    globalObject.onBeforeLog?.();\n    throw internalError;\n}\nfunction assertUsage(condition, errMsg, { showStackTrace, exitOnError } = {}) {\n    if (condition)\n        return;\n    showStackTrace = showStackTrace || globalObject.alwaysShowStackTrace;\n    errMsg = addWhitespace(errMsg);\n    errMsg = addPrefixAssertType(errMsg, 'Wrong Usage');\n    errMsg = addPrefixProjectName(errMsg);\n    const usageError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);\n    if (showStackTrace) {\n        globalObject.showStackTraceList.add(usageError);\n    }\n    globalObject.onBeforeLog?.();\n    if (!exitOnError) {\n        throw usageError;\n    }\n    else {\n        console.error(showStackTrace ? usageError : errMsg);\n        process.exit(1);\n    }\n}\nfunction getProjectError(errMsg) {\n    errMsg = addWhitespace(errMsg);\n    errMsg = addPrefixAssertType(errMsg, 'Error');\n    errMsg = addPrefixProjectName(errMsg);\n    const projectError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);\n    return projectError;\n}\nfunction assertWarning(condition, msg, { onlyOnce, showStackTrace }) {\n    if (condition)\n        return;\n    showStackTrace = showStackTrace || globalObject.alwaysShowStackTrace;\n    msg = addWhitespace(msg);\n    msg = addPrefixAssertType(msg, 'Warning');\n    msg = addPrefixProjectName(msg);\n    if (onlyOnce) {\n        const { alreadyLogged } = globalObject;\n        const key = onlyOnce === true ? msg : onlyOnce;\n        if (alreadyLogged.has(key))\n            return;\n        alreadyLogged.add(key);\n    }\n    globalObject.onBeforeLog?.();\n    if (showStackTrace) {\n        const err = createErrorWithCleanStackTrace(msg, numberOfStackTraceLinesToRemove);\n        globalObject.showStackTraceList.add(err);\n        globalObject.logger(err, 'warn');\n    }\n    else {\n        globalObject.logger(msg, 'warn');\n    }\n}\nfunction assertInfo(condition, msg, { onlyOnce }) {\n    if (condition) {\n        return;\n    }\n    msg = addWhitespace(msg);\n    msg = addPrefixProjectName(msg);\n    if (onlyOnce) {\n        const { alreadyLogged } = globalObject;\n        const key = msg;\n        if (alreadyLogged.has(key)) {\n            return;\n        }\n        else {\n            alreadyLogged.add(key);\n        }\n    }\n    globalObject.onBeforeLog?.();\n    globalObject.logger(msg, 'info');\n}\nfunction addOnBeforeLogHook(onBeforeLog) {\n    globalObject.onBeforeLog = onBeforeLog;\n}\nfunction addPrefixAssertType(msg, tag) {\n    let prefix = `[${tag}]`;\n    const color = tag === 'Warning' ? 'yellow' : 'red';\n    prefix = pc.bold(pc[color](prefix));\n    return `${prefix}${msg}`;\n}\nfunction addWhitespace(msg) {\n    if (msg.startsWith('[')) {\n        return msg;\n    }\n    else {\n        return ` ${msg}`;\n    }\n}\nfunction addPrefixProjectName(msg, showProjectVersion = false) {\n    const prefix = showProjectVersion ? projectTagWithVersion : projectTag;\n    return `${prefix}${msg}`;\n}\n// TO-DO/eventually: remove this (refactor the whole log handling)\nfunction getAssertErrMsg(thing) {\n    let errMsg;\n    let errStack;\n    if (typeof thing === 'string') {\n        errMsg = thing;\n    }\n    else if (isObject(thing) && typeof thing.message === 'string' && typeof thing.stack === 'string') {\n        errMsg = thing.message;\n        errStack = thing.stack;\n    }\n    else {\n        return null;\n    }\n    for (const tag of [projectTagWithVersion, projectTag]) {\n        const showVikeVersion = tag === projectTagWithVersion;\n        const errStackPrefix = `Error: ${tag}`;\n        if (errStack?.startsWith(errStackPrefix)) {\n            if (globalObject.showStackTraceList.has(thing) || isBug(thing)) {\n                const assertMsg = errStack.slice(errStackPrefix.length);\n                return { assertMsg, showVikeVersion };\n            }\n        }\n        else if (errStack?.includes(tag)) {\n            // The following assert can fail, e.g. with following error:\n            // ```\n            // Error: Error running module \"/home/rom/code/vike-server/examples/cloudflare-react/cloudflare-entry.js\".\n            // Error running module \"photon:cloudflare:/home/rom/code/vike-server/examples/cloudflare-react/server.js\".\n            // Error running module \"/home/rom/code/vike-server/examples/cloudflare-react/server.js\".\n            // Error running module \"/home/rom/code/vike-server/node_modules/.pnpm/@photonjs+hono@0.0.6_@hattip+core@0.0.49_elysia@1.3.13_exact-mirror@0.1.6_@sinclair+typ_c39d432d43266746f390ace81b426601/node_modules/@photonjs/hono/dist/index.js?v=6ca51a04\".\n            // Error running module \"/home/rom/code/vike-server/node_modules/.pnpm/@photonjs+hono@0.0.6_@hattip+core@0.0.49_elysia@1.3.13_exact-mirror@0.1.6_@sinclair+typ_c39d432d43266746f390ace81b426601/node_modules/@photonjs/hono/dist/apply.dev.js?v=6ca51a04\".\n            // Error running module \"photon:get-middlewares:dev:hono\".\n            // Error running module \"/home/rom/code/vike-server/packages/vike-server/dist/universal.dev.js\".\n            // [vike][Wrong Usage] The global context isn't set yet, use getGlobalContextAsync() instead........\n            //     at async ProxyServer.fetch (file:///home/rom/code/vike-server/node_modules/.pnpm/miniflare@4.20250829.0/node_modules/miniflare/src/workers/core/proxy.worker.ts:174:11)\n            // ```\n            /*\n            throw new Error('Internal Vike error')\n            */\n        }\n        if (errMsg?.startsWith(tag)) {\n            const assertMsg = errMsg.slice(tag.length);\n            return { assertMsg, showVikeVersion };\n        }\n    }\n    return null;\n}\nfunction overwriteAssertProductionLogger(logger) {\n    globalObject.logger = logger;\n}\nfunction isBug(err) {\n    return String(err).includes(`[${bugTag}]`);\n}\n// Called upon `DEBUG=vike:error`\nfunction setAlwaysShowStackTrace() {\n    globalObject.alwaysShowStackTrace = true;\n}\n","export function isBrowser() {\n    // Using `typeof window !== 'undefined'` alone is not enough because some users use https://www.npmjs.com/package/ssr-window\n    return typeof window !== 'undefined' && typeof window.scrollY === 'number';\n    // Alternatively, test whether environment is a *real* browser: https://github.com/brillout/picocolors/blob/d59a33a0fd52a8a33e4158884069192a89ce0113/picocolors.js#L87-L89\n}\n","export { assertClientRouting };\nexport { assertServerRouting };\nexport { checkIfClientRouting };\nimport { assertUsage, assertWarning } from './assert.js';\nimport { getGlobalObject } from './getGlobalObject.js';\nimport { isBrowser } from './isBrowser.js';\nimport pc from '@brillout/picocolors';\nconst state = getGlobalObject('utils/assertRouterType.ts', {});\nfunction assertClientRouting() {\n    assertNoContradiction(checkIfClientRouting());\n    state.isClientRouting = true;\n}\nfunction checkIfClientRouting() {\n    return state.isClientRouting !== false;\n}\nfunction assertServerRouting() {\n    assertNoContradiction(state.isClientRouting !== true);\n    state.isClientRouting = false;\n}\nfunction assertNoContradiction(noContradiction) {\n    // If an assertion fails because of a wrong usage, then we assume that the user is trying to import from 'vike/client/router' while not setting `clientRouting` to `true`. Note that 'vike/client' only exports the type `PageContextBuiltInClient` and that the package.json#exports entry 'vike/client' will eventually be removed.\n    assertUsage(isBrowser(), `${pc.cyan(\"import { something } from 'vike/client/router'\")} is forbidden on the server-side`, { showStackTrace: true });\n    assertWarning(noContradiction, \"You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.\", { showStackTrace: true, onlyOnce: true });\n}\n","export function isCallable(thing) {\n    return thing instanceof Function || typeof thing === 'function';\n}\n","// Same as Array.isArray() but typesafe: asserts unknown[] instead of any[]\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","export { hasProp };\nimport { isCallable } from './isCallable.js';\nimport { isObject } from './isObject.js';\nimport { isArrayOfStrings } from './isArrayOfStrings.js';\nimport { isObjectOfStrings } from './isObjectOfStrings.js';\nimport { isArray } from './isArray.js';\nfunction hasProp(obj, prop, type) {\n    if (!isObject(obj))\n        return false;\n    if (!(prop in obj)) {\n        return type === 'undefined';\n    }\n    if (type === undefined) {\n        return true;\n    }\n    const propValue = obj[prop];\n    if (type === 'undefined') {\n        return propValue === undefined;\n    }\n    if (type === 'array') {\n        return isArray(propValue);\n    }\n    if (type === 'object') {\n        return isObject(propValue);\n    }\n    if (type === 'string[]') {\n        return isArrayOfStrings(propValue);\n    }\n    if (type === 'string{}') {\n        return isObjectOfStrings(propValue);\n    }\n    if (type === 'function') {\n        return isCallable(propValue);\n    }\n    if (isArray(type)) {\n        return typeof propValue === 'string' && type.includes(propValue);\n    }\n    if (type === 'null') {\n        return propValue === null;\n    }\n    if (type === 'true') {\n        return propValue === true;\n    }\n    if (type === 'false') {\n        return propValue === false;\n    }\n    return typeof propValue === type;\n}\n","export { isArrayOfStrings };\nimport { isArray } from './isArray.js';\nfunction isArrayOfStrings(val) {\n    return isArray(val) && val.every((v) => typeof v === 'string');\n}\n","export { isObjectOfStrings };\nimport { isObject } from './isObject.js';\nfunction isObjectOfStrings(val) {\n    return isObject(val) && Object.values(val).every((v) => typeof v === 'string');\n}\n","export function isPlainObject(value) {\n    // Is object?\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    // Support `Object.create(null)`\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    // Is plain object?\n    return (\n    /* Doesn't work in Cloudflare Pages workers\n    value.constructor === Object\n    */\n    value.constructor.name === 'Object');\n}\n","export { objectAssign };\nimport { assert } from './assert.js';\n// Same as Object.assign() but:\n//  - With type inference\n//  - Preserves property descriptors, which we need for preserving the getters of getPageContextUrlComputed()\nfunction objectAssign(obj, objAddendum, objAddendumCanBeOriginalObject) {\n    if (!objAddendum)\n        return;\n    if (!objAddendumCanBeOriginalObject)\n        assert(!objAddendum._isOriginalObject);\n    Object.defineProperties(obj, Object.getOwnPropertyDescriptors(objAddendum));\n}\n","import { assert } from './assert.js';\nexport { slice };\nfunction slice(thing, from, to) {\n    if (typeof thing === 'string') {\n        return sliceArray(thing.split(''), from, to).join('');\n    }\n    else {\n        return sliceArray(thing, from, to);\n    }\n}\nfunction sliceArray(list, from, to) {\n    const listSlice = [];\n    let start = from >= 0 ? from : list.length + from;\n    assert(start >= 0 && start <= list.length);\n    let end = to >= 0 ? to : list.length + to;\n    assert(end >= 0 && end <= list.length);\n    while (true) {\n        if (start === end) {\n            break;\n        }\n        if (start === list.length) {\n            start = 0;\n        }\n        if (start === end) {\n            break;\n        }\n        const el = list[start];\n        assert(el !== undefined);\n        listSlice.push(el);\n        start++;\n    }\n    return listSlice;\n}\n","// We don't use new URL() as it doesn't exactly do what we need, for example:\n//  - It loses the original URL parts (which we need to manipulate and recreate URLs)\n//  - It doesn't support the tauri:// protocol\n// Unit tests at ./parseUrl.spec.ts\nexport { parseUrl };\nexport { assertUsageUrlAbsolute };\nexport { assertUsageUrlPathAbsolute };\nexport { assertUsageUrlRedirectTarget };\nexport { isUrl };\nexport { isUri };\nexport { isUrlRedirectTarget };\nexport { isUrlRelative };\nexport { isUrlExternal };\nexport { isBaseServer };\nexport { assertUrlComponents };\nexport { createUrlFromComponents };\nimport { slice } from './slice.js';\nimport { assert, assertUsage } from './assert.js';\nimport pc from '@brillout/picocolors';\nfunction parseUrl(url, baseServer) {\n    assert(isUrl(url), url);\n    assert(baseServer.startsWith('/'));\n    // Hash\n    const { hashString: hashOriginal, withoutHash: urlWithoutHash } = extractHash(url);\n    assert(hashOriginal === null || hashOriginal.startsWith('#'));\n    const hash = hashOriginal === null ? '' : decodeSafe(hashOriginal.slice(1));\n    // Search\n    const { searchString: searchOriginal, withoutSearch: urlWithoutHashNorSearch } = extractSearch(urlWithoutHash);\n    assert(searchOriginal === null || searchOriginal.startsWith('?'));\n    let searchString = '';\n    if (searchOriginal !== null) {\n        searchString = searchOriginal;\n    }\n    else if (url.startsWith('#')) {\n        const baseURI = getBaseURI();\n        searchString = (baseURI && extractSearch(baseURI).searchString) || '';\n    }\n    const search = {};\n    const searchAll = {};\n    Array.from(new URLSearchParams(searchString)).forEach(([key, val]) => {\n        search[key] = val;\n        searchAll[key] = [...(searchAll.hasOwnProperty(key) ? searchAll[key] : []), val];\n    });\n    // Origin + pathname\n    let { protocol, origin, pathnameAbsoluteWithBase } = getPathnameAbsoluteWithBase(urlWithoutHashNorSearch, baseServer);\n    const pathnameOriginal = urlWithoutHashNorSearch.slice((origin || '').length);\n    assertUrlComponents(url, origin, pathnameOriginal, searchOriginal, hashOriginal);\n    // Base URL\n    let { pathname, isBaseMissing } = removeBaseServer(pathnameAbsoluteWithBase, baseServer);\n    // pageContext.urlParsed.href\n    const href = createUrlFromComponents(origin, pathname, searchOriginal, hashOriginal);\n    // pageContext.urlParsed.{hostname, port}\n    const host = !origin ? null : origin.slice(protocol.length);\n    const { hostname, port } = parseHost(host, url);\n    // decode after setting href\n    pathname = decodePathname(pathname);\n    /* Should it be `pathname` or `pathnameOriginal`? https://github.com/vikejs/vike/pull/2770\n    // pageContext.urlParsed.path\n    const path = pathname + (searchOriginal || '') + (hashOriginal || '')\n    */\n    assert(pathname.startsWith('/'));\n    return {\n        href,\n        protocol,\n        hostname,\n        port,\n        origin,\n        pathname,\n        pathnameOriginal: pathnameOriginal,\n        isBaseMissing,\n        search,\n        searchAll,\n        searchOriginal,\n        hash,\n        hashOriginal,\n    };\n}\nfunction extractHash(url) {\n    const [withoutHash, ...parts] = url.split('#');\n    const hashString = ['', ...parts].join('#') || null;\n    return { hashString, withoutHash: withoutHash };\n}\nfunction extractSearch(url) {\n    const [withoutSearch, ...parts] = url.split('?');\n    const searchString = ['', ...parts].join('?') || null;\n    return { searchString, withoutSearch: withoutSearch };\n}\nfunction decodeSafe(urlComponent) {\n    try {\n        return decodeURIComponent(urlComponent);\n    }\n    catch { }\n    try {\n        return decodeURI(urlComponent);\n    }\n    catch { }\n    return urlComponent;\n}\nfunction decodePathname(urlPathname) {\n    urlPathname = urlPathname.replace(/\\s+$/, '');\n    urlPathname = urlPathname\n        .split('/')\n        .map((dir) => decodeSafe(dir).split('/').join('%2F'))\n        .join('/');\n    return urlPathname;\n}\nfunction getPathnameAbsoluteWithBase(url, baseServer) {\n    // Search and hash already extracted\n    assert(!url.includes('?') && !url.includes('#'));\n    // url has origin\n    {\n        const { protocol, origin, pathname } = parseOrigin(url);\n        if (origin) {\n            return { protocol, origin, pathnameAbsoluteWithBase: pathname };\n        }\n        assert(pathname === url);\n    }\n    // url doesn't have origin\n    if (url.startsWith('/')) {\n        return { protocol: null, origin: null, pathnameAbsoluteWithBase: url };\n    }\n    else {\n        // url is a relative path\n        const baseURI = getBaseURI();\n        let base;\n        if (baseURI) {\n            base = parseOrigin(baseURI.split('?')[0].split('#')[0]).pathname;\n        }\n        else {\n            base = baseServer;\n        }\n        const pathnameAbsoluteWithBase = resolveUrlPathnameRelative(url, base);\n        return { protocol: null, origin: null, pathnameAbsoluteWithBase };\n    }\n}\nfunction getBaseURI() {\n    // In the browser, this is the Base URL of the current URL.\n    // Safe access `window?.document?.baseURI` for users who shim `window` in Node.js\n    const baseURI = typeof window !== 'undefined' ? window?.document?.baseURI : undefined;\n    return baseURI;\n}\nfunction parseOrigin(url) {\n    if (!isUrlWithWebProtocol(url)) {\n        return { pathname: url, origin: null, protocol: null };\n    }\n    else {\n        const { protocol, uriWithoutProtocol } = parseProtocol(url);\n        assert(protocol);\n        const [host, ...rest] = uriWithoutProtocol.split('/');\n        const origin = protocol + host;\n        const pathname = '/' + rest.join('/');\n        return { pathname, origin, protocol };\n    }\n}\nfunction parseHost(host, url) {\n    const ret = { hostname: null, port: null };\n    if (!host)\n        return ret;\n    // port\n    const parts = host.split(':');\n    if (parts.length > 1) {\n        const port = parseInt(parts.pop(), 10);\n        assert(port || port === 0, url);\n        ret.port = port;\n    }\n    // hostname\n    ret.hostname = parts.join(':');\n    return ret;\n}\nfunction parseProtocol(uri) {\n    const SEP = ':';\n    const [before, ...after] = uri.split(SEP);\n    if (after.length === 0 ||\n        // https://github.com/vikejs/vike/commit/886a99ff21e86a8ca699a25cee7edc184aa058e4#r143308934\n        // https://en.wikipedia.org/wiki/List_of_URI_schemes\n        // https://www.rfc-editor.org/rfc/rfc7595\n        !/^[a-z][a-z0-9\\+\\-]*$/i.test(before)) {\n        return { protocol: null, uriWithoutProtocol: uri };\n    }\n    let protocol = before + SEP;\n    let uriWithoutProtocol = after.join(SEP);\n    const SEP2 = '//';\n    if (uriWithoutProtocol.startsWith(SEP2)) {\n        protocol = protocol + SEP2;\n        uriWithoutProtocol = uriWithoutProtocol.slice(SEP2.length);\n    }\n    return { protocol, uriWithoutProtocol };\n}\nfunction isWebUrlProtocol(protocol) {\n    // Is there an alternative to having a blocklist?\n    // - If the blocklist becomes too big, maybe use a allowlist instead ['tauri://', 'file://', 'capacitor://', 'http://', 'https://']\n    const blocklist = [\n        // https://docs.ipfs.tech/how-to/address-ipfs-on-web\n        'ipfs://',\n        'ipns://',\n    ];\n    if (blocklist.includes(protocol))\n        return false;\n    return protocol.endsWith('://');\n}\n// Adapted from https://stackoverflow.com/questions/14780350/convert-relative-path-to-absolute-using-javascript/14780463#14780463\nfunction resolveUrlPathnameRelative(pathnameRelative, base) {\n    const stack = base.split('/');\n    const parts = pathnameRelative.split('/');\n    let baseRestoreTrailingSlash = base.endsWith('/');\n    if (pathnameRelative.startsWith('.')) {\n        // remove current file name\n        stack.pop();\n    }\n    for (const i in parts) {\n        const p = parts[i];\n        if (p == '' && i === '0')\n            continue;\n        if (p == '.')\n            continue;\n        if (p == '..')\n            stack.pop();\n        else {\n            baseRestoreTrailingSlash = false;\n            stack.push(p);\n        }\n    }\n    let pathnameAbsolute = stack.join('/');\n    if (baseRestoreTrailingSlash && !pathnameAbsolute.endsWith('/'))\n        pathnameAbsolute += '/';\n    if (!pathnameAbsolute.startsWith('/'))\n        pathnameAbsolute = '/' + pathnameAbsolute;\n    return pathnameAbsolute;\n}\nfunction removeBaseServer(pathnameAbsoluteWithBase, baseServer) {\n    assert(pathnameAbsoluteWithBase.startsWith('/'));\n    assert(isBaseServer(baseServer));\n    // Mutable\n    let urlPathname = pathnameAbsoluteWithBase;\n    assert(urlPathname.startsWith('/'));\n    assert(baseServer.startsWith('/'));\n    if (baseServer === '/') {\n        const pathname = pathnameAbsoluteWithBase;\n        return { pathname, isBaseMissing: false };\n    }\n    // Support `url === '/some-base-url' && baseServer === '/some-base-url/'`\n    let baseServerNormalized = baseServer;\n    if (baseServer.endsWith('/') && urlPathname === slice(baseServer, 0, -1)) {\n        baseServerNormalized = slice(baseServer, 0, -1);\n        assert(urlPathname === baseServerNormalized);\n    }\n    if (!urlPathname.startsWith(baseServerNormalized)) {\n        const pathname = pathnameAbsoluteWithBase;\n        return { pathname, isBaseMissing: true };\n    }\n    assert(urlPathname.startsWith('/') || urlPathname.startsWith('http'));\n    assert(urlPathname.startsWith(baseServerNormalized));\n    urlPathname = urlPathname.slice(baseServerNormalized.length);\n    if (!urlPathname.startsWith('/'))\n        urlPathname = '/' + urlPathname;\n    assert(urlPathname.startsWith('/'));\n    return { pathname: urlPathname, isBaseMissing: false };\n}\nfunction isBaseServer(baseServer) {\n    return baseServer.startsWith('/');\n}\nfunction assertUrlComponents(url, origin, pathnameOriginal, searchOriginal, hashOriginal) {\n    const urlRecreated = createUrlFromComponents(origin, pathnameOriginal, searchOriginal, hashOriginal);\n    assert(url === urlRecreated);\n}\nfunction createUrlFromComponents(origin, pathname, search, hash) {\n    const urlRecreated = `${origin || ''}${pathname}${search || ''}${hash || ''}`;\n    return urlRecreated;\n}\nfunction isUrl(url) {\n    // parseUrl() works with these URLs\n    return isUrlAbsolute(url) || isUrlRelative(url);\n}\nfunction isUrlRedirectTarget(url) {\n    return isUrlAbsolute(url) || isUri(url);\n}\nfunction isUrlAbsolute(url) {\n    return isUrlPathAbsolute(url) || isUrlWithWebProtocol(url);\n}\nfunction isUrlPathAbsolute(url) {\n    return url.startsWith('/');\n}\nfunction isUrlRelative(url) {\n    return ['.', '?', '#'].some((c) => url.startsWith(c)) || url === '';\n}\nfunction isUrlExternal(url) {\n    return !url.startsWith('/') && !isUrlRelative(url);\n}\n/*\nURL with protocol.\n\n  http://example.com\n  https://example.com\n  tauri://localhost\n  file://example.com\n  capacitor://localhost/assets/chunks/chunk-DJBYDrsP.js\n\n[Tauri](https://github.com/vikejs/vike/issues/808)\n[Electron (`file://`)](https://github.com/vikejs/vike/issues/1557)\n[Capacitor](https://github.com/vikejs/vike/issues/1706)\n */\nfunction isUrlWithWebProtocol(url) {\n    const { protocol } = parseProtocol(url);\n    return !!protocol && isWebUrlProtocol(protocol);\n}\n/*\nURIs that aren't URLs.\n\n  mailto:john@example.com\n\n  ipfs://bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq/wiki/Vincent_van_Gogh.html\n\n  magnet:?xt=urn:btih:3a15e1ac49683d91b20c2ffc252ea612a6c01bd7&dn=The.Empire.Strikes.Back.1980.Remastered.1080p.BluRay.DDP.7.1.x265-EDGE2020.mkv&xl=3225443573&tr=udp://tracker.opentrackr.org:1337/announce&tr=udp://tracker.torrent.eu.org:451&tr=udp://open.stealth.si:80/announce&tr=udp://tracker.openbittorrent.com:6969&tr=udp://tracker.tiny-vps.com:6969/announce&tr=udp://open.demonii.com:1337\n\nWe need to treat URIs differently than URLs.\n - For example, we cannot parse URIs (their structure is unknown e.g. a `magnet:` URI is completely different than a `http://` URL).\n   - The protocols tauri:// file:// capacitor:// follow the same structure as http:// and https:// URLs.\n     - Thus we can parse them like http:// and https:// URLs.\n*/\nfunction isUri(uri) {\n    const { protocol } = parseProtocol(uri);\n    return !!protocol && !isWebUrlProtocol(protocol);\n}\nfunction assertUsageUrlAbsolute(url, errPrefix) {\n    assertUsage(isUrlAbsolute(url), getErrMsg(url, errPrefix, true));\n}\nfunction assertUsageUrlPathAbsolute(url, errPrefix) {\n    assertUsage(isUrlPathAbsolute(url), getErrMsg(url, errPrefix));\n}\nfunction assertUsageUrlRedirectTarget(url, errPrefix, isUnresolved) {\n    const errMsg = getErrMsg(url, errPrefix, true, isUnresolved);\n    assertUsage(isUrlRedirectTarget(url) || (isUnresolved && url === '*'), errMsg);\n}\nfunction getErrMsg(url, errPrefix, allowProtocol, allowUri) {\n    let errMsg = `${errPrefix} is ${pc.string(url)} but it should start with ${pc.string('/')}`;\n    if (allowProtocol)\n        errMsg += ` or a protocol (e.g. ${pc.string('http://')})`;\n    if (allowUri)\n        errMsg += `, or be ${pc.string('*')}`;\n    return errMsg;\n}\n","export function redirectHard(url) {\n    window.location.href = url;\n}\n","export function sleep(milliseconds) {\n    return new Promise((r) => setTimeout(r, milliseconds));\n}\n","export { onPageHide };\nexport { onPageShow };\nfunction onPageHide(listener) {\n    window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'hidden') {\n            listener();\n        }\n    });\n}\nfunction onPageShow(listener) {\n    window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'visible') {\n            listener();\n        }\n    });\n}\n","export { genPromise };\n// Simple implementation without timeout: https://github.com/vikejs/vike/blob/2e59b922e7e0f227d26018dc2b74877c9b0f581b/vike/utils/genPromise.ts\nimport { assert, assertWarning } from './assert.js';\nconst timeoutSecondsDefault = 25;\nfunction genPromise({ timeout: timeoutSeconds = timeoutSecondsDefault, } = {}) {\n    let resolve;\n    let reject;\n    let finished = false;\n    const promise_internal = new Promise((resolve_, reject_) => {\n        resolve = (...args) => {\n            finished = true;\n            timeoutClear();\n            return resolve_(...args);\n        };\n        reject = (...args) => {\n            finished = true;\n            timeoutClear();\n            return reject_(...args);\n        };\n    });\n    const timeoutClear = () => timeouts.forEach((t) => clearTimeout(t));\n    const timeouts = [];\n    let promise;\n    if (!timeoutSeconds) {\n        promise = promise_internal;\n    }\n    else {\n        promise = new Proxy(promise_internal, {\n            get(target, prop) {\n                if (prop === 'then' && !finished) {\n                    const err = new Error(`Promise hasn't resolved after ${timeoutSeconds} seconds`);\n                    timeouts.push(setTimeout(() => {\n                        assert(err.stack);\n                        assertWarning(false, removeStackErrorPrefix(err.stack), { onlyOnce: false });\n                    }, timeoutSeconds * 1000));\n                }\n                const value = Reflect.get(target, prop);\n                return typeof value === 'function' ? value.bind(target) : value;\n            },\n        });\n    }\n    return { promise, resolve, reject };\n}\nfunction removeStackErrorPrefix(errStack) {\n    const errorPrefix = 'Error: ';\n    if (errStack.startsWith(errorPrefix))\n        errStack = errStack.slice(errorPrefix.length);\n    return errStack;\n}\n","export { catchInfiniteLoop };\nimport { assertUsage, assertWarning } from './assert.js';\nconst trackers = {};\nfunction catchInfiniteLoop(functionName, maxNumberOfCalls = 100, withinSeconds = 5) {\n    // Init\n    const now = new Date();\n    let tracker = (trackers[functionName] ?? (trackers[functionName] = createTracker(now)));\n    // Reset\n    const elapsedTime = now.getTime() - tracker.start.getTime();\n    if (elapsedTime > withinSeconds * 1000)\n        tracker = trackers[functionName] = createTracker(now);\n    // Count\n    tracker.count++;\n    // Error\n    const msg = `[Infinite Loop] Rendering ${tracker.count} times within ${withinSeconds} seconds [${functionName}]`;\n    if (tracker.count > maxNumberOfCalls) {\n        assertUsage(false, msg);\n    }\n    // Warning, at 50% threshold\n    if (!tracker.warned && tracker.count > maxNumberOfCalls * 0.5) {\n        // Warning is shown upon 10 calls a second, on average during 5 seconds, given the default parameters\n        assertWarning(false, msg, { onlyOnce: false, showStackTrace: true });\n        tracker.warned = true;\n    }\n}\nfunction createTracker(now) {\n    const tracker = {\n        count: 0,\n        start: now,\n    };\n    return tracker;\n}\n","/** Change enumerability of an object property. */\nexport function changeEnumerable(obj, prop, enumerable) {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n    Object.defineProperty(obj, prop, { ...descriptor, enumerable });\n}\n","// https://stackoverflow.com/questions/201183/how-to-determine-equality-for-two-javascript-objects/32922084#32922084\nexport function deepEqual(x, y) {\n    const ok = Object.keys, tx = typeof x, ty = typeof y;\n    return x && y && tx === 'object' && tx === ty\n        ? ok(x).length === ok(y).length && ok(x).every((key) => deepEqual(x[key], y[key]))\n        : x === y;\n}\n","export { onLoad };\nimport { assertIsBrowser } from '../../utils/assertIsBrowser.js';\nimport { assertClientRouting } from '../../utils/assertRoutingType.js';\nfunction onLoad() {\n    assertIsBrowser();\n    // Ensure we don't bloat the Server Routing runtime with Client Routing utils\n    assertClientRouting();\n}\n","export { getPageContextSerializedInHtml };\nexport { getGlobalContextSerializedInHtml };\nimport { parse } from '@brillout/json-serializer/parse';\nimport { hasProp, assert, assertUsage } from './utils.js';\nimport { htmlElementId_globalContext, htmlElementId_pageContext } from '../../shared/htmlElementIds.js';\n// elements should exist because:\n// 1. <script id=\"vike_pageContext\" type=\"application/json\"> appears before the <script> that loads Vike's client runtime (which includes this file)\n// 2. <script id=\"vike_pageContext\" type=\"application/json\"> is neither async nor defer\n// See https://github.com/vikejs/vike/pull/1271\nfunction getPageContextSerializedInHtml() {\n    const pageContextSerializedInHtml = findAndParseJson(htmlElementId_pageContext);\n    assert(hasProp(pageContextSerializedInHtml, 'pageId', 'string'));\n    assert(hasProp(pageContextSerializedInHtml, 'routeParams', 'string{}'));\n    return pageContextSerializedInHtml;\n}\nfunction getGlobalContextSerializedInHtml() {\n    const globalContextSerializedInHtml = findAndParseJson(htmlElementId_globalContext);\n    return globalContextSerializedInHtml;\n}\nfunction findAndParseJson(id) {\n    const elem = document.getElementById(id);\n    assertUsage(elem, \n    // It seems like it can be missing when HTML is malformed: https://github.com/vikejs/vike/issues/913\n    `Couldn't find #${id} (which Vike automatically injects in the HTML): make sure it exists (i.e. don't remove it and make sure your HTML isn't malformed)`);\n    const jsonStr = elem.textContent;\n    assert(jsonStr);\n    const json = parse(jsonStr, {\n        // Prevent Google from crawling URLs in JSON:\n        // - https://github.com/vikejs/vike/pull/2603\n        // - https://github.com/brillout/json-serializer/blob/38edbb9945de4938da1e65d6285ce1dd123a45ef/test/main.spec.ts#L44-L95\n        reviver(_key, value) {\n            if (typeof value === 'string') {\n                return { replacement: value.replaceAll('\\\\/', '/'), resolved: false };\n            }\n        },\n    });\n    return json;\n}\n","import { assert } from './assert.js';\nexport { higherFirst };\nexport { lowerFirst };\nexport { makeFirst };\nexport { makeLast };\nexport { reverse };\n/**\n * ```js\n * let arr = [\n *   { price: 10 },\n *   { price: 1000 },\n *   { price: 100 }\n * ]\n * arr = arr.sort(higherFirst(el => el.price))\n * isEqual(arr, [\n *   { price: 1000 },\n *   { price: 100 },\n *   { price: 10 }\n * ])\n * ```\n */\nfunction higherFirst(getValue) {\n    return (element1, element2) => {\n        const val1 = getValue(element1);\n        const val2 = getValue(element2);\n        if (val1 === val2) {\n            return 0;\n        }\n        return val1 > val2 ? -1 : 1;\n    };\n}\n/**\n * ```js\n * let arr = [\n *   { price: 10 },\n *   { price: 1000 },\n *   { price: 100 }\n * ]\n * arr = arr.sort(lowerFirst(el => el.price))\n * isEqual(arr, [\n *   { price: 10 },\n *   { price: 100 },\n *   { price: 1000 }\n * ])\n * ```\n */\nfunction lowerFirst(getValue) {\n    return (element1, element2) => {\n        const val1 = getValue(element1);\n        const val2 = getValue(element2);\n        if (val1 === val2) {\n            return 0;\n        }\n        return val1 < val2 ? -1 : 1;\n    };\n}\n/**\n * ```js\n * let arr = [\n *  { name: 'iphone', isRocket: false },\n *  { name: 'starship', isRocket: true }\n * ]\n * arr = arr.sort(makeFirst(el => el.isRocket))\n * isEqual(arr, [\n *  { name: 'starship', isRocket: true },\n *  { name: 'iphone', isRocket: false }\n * ])\n * ```\n */\nfunction makeFirst(getValue) {\n    return (element1, element2) => {\n        const val1 = getValue(element1);\n        const val2 = getValue(element2);\n        assert([true, false, null].includes(val1));\n        assert([true, false, null].includes(val2));\n        if (val1 === val2) {\n            return 0;\n        }\n        if (val1 === true || val2 === false) {\n            return -1;\n        }\n        if (val2 === true || val1 === false) {\n            return 1;\n        }\n        assert(false);\n    };\n}\n/**\n * ```js\n * let arr = [\n *  { name: 'starship', isRocket: true },\n *  { name: 'iphone', isRocket: false }\n * ]\n * arr = arr.sort(makeLast(el => el.isRocket))\n * isEqual(arr, [\n *  { name: 'iphone', isRocket: false },\n *  { name: 'starship', isRocket: true }\n * ])\n * ```\n */\nfunction makeLast(getValue) {\n    return makeFirst((element) => {\n        const val = getValue(element);\n        if (val === null) {\n            return null;\n        }\n        else {\n            return !val;\n        }\n    });\n}\n/** Reverse order result. */\nfunction reverse(sortKey) {\n    return (-1 * sortKey);\n}\n","export function isNullish(val) {\n    return val === null || val === undefined;\n}\n// someArray.filter(isNotNullish)\nexport function isNotNullish(p) {\n    return !isNullish(p);\n}\n// objectFilter(obj).filter(isNotNullish_keyVal)\nexport function isNotNullish_keyVal(arg) {\n    return !isNullish(arg[1]);\n}\n","export { stringifyStringArray };\nfunction stringifyStringArray(stringList) {\n    return '[' + stringList.map((str) => \"'\" + str + \"'\").join(', ') + ']';\n}\n","// Same as Object.defineProperty() but with type inference\nexport function objectDefineProperty(obj, prop, { get, ...args }) {\n    Object.defineProperty(obj, prop, { ...args, get });\n}\n","export { isScriptFile };\nexport { isPlainScriptFile };\nexport { isTemplateFile };\nexport { scriptFileExtensionList };\nexport { scriptFileExtensionPattern };\n// We can't use a RegExp:\n//  - Needs to work with Micromatch: https://github.com/micromatch/micromatch because:\n//    - Vite's `import.meta.glob()` uses Micromatch\n//  - We need this to be a allowlist because:\n//   - A pattern `*([a-zA-Z0-9]` doesn't work.\n//     - Because of ReScript: `.res` are ReScript source files which need to be ignored. (The ReScript compiler generates `.js` files alongside `.res` files.)\n//   - Block listing doesn't work.\n//     - We cannot implement a blocklist with a glob pattern.\n//     - A post `import.meta.glob()` blocklist filtering doesn't work because Vite would still process the files (e.g. including them in the bundle).\n// prettier-ignore\n// biome-ignore format:\nconst extJs = [\n    'js',\n    'cjs',\n    'mjs',\n];\n// prettier-ignore\n// biome-ignore format:\nconst extTs = [\n    'ts',\n    'cts',\n    'mts',\n];\nconst extJsOrTs = [...extJs, ...extTs];\n// prettier-ignore\n// biome-ignore format:\nconst extJsx = [\n    'jsx',\n    'cjsx',\n    'mjsx',\n];\n// prettier-ignore\n// biome-ignore format:\nconst extTsx = [\n    'tsx',\n    'ctsx',\n    'mtsx'\n];\nconst extJsxOrTsx = [...extJsx, ...extTsx];\n// prettier-ignore\n// biome-ignore format:\nconst extTemplates = [\n    'vue',\n    'svelte',\n    'marko',\n    'md',\n    'mdx'\n];\nconst scriptFileExtensionList = [...extJsOrTs, ...extJsxOrTsx, ...extTemplates];\nconst scriptFileExtensionPattern = '(' + scriptFileExtensionList.join('|') + ')';\nfunction isScriptFile(filePath) {\n    return scriptFileExtensionList.some((ext) => filePath.endsWith('.' + ext));\n}\nfunction isPlainScriptFile(filePath) {\n    return extJsOrTs.some((ext) => filePath.endsWith('.' + ext));\n}\nfunction isTemplateFile(filePath) {\n    return extTemplates.some((ext) => filePath.endsWith('.' + ext));\n}\n","// TO-DO/next-major-release: remove this file\nexport { getPageFilesClientSide };\nexport { getPageFilesServerSide };\nimport { assert, assertUsage, isNotNullish } from '../utils.js';\nfunction getPageFilesClientSide(pageFilesAll, pageId) {\n    return determine(pageFilesAll, pageId, true);\n}\nfunction getPageFilesServerSide(pageFilesAll, pageId) {\n    return determine(pageFilesAll, pageId, false);\n}\nfunction determine(pageFilesAll, pageId, envIsClient) {\n    const env = envIsClient ? 'CLIENT_ONLY' : 'SERVER_ONLY';\n    const pageFilesRelevant = pageFilesAll\n        .filter((p) => p.isRelevant(pageId) && p.fileType !== '.page.route')\n        .sort(getPageFilesSorter(envIsClient, pageId));\n    // Load the `.page.js` files specific to `pageId`\n    const getPageIdFile = (iso) => {\n        const files = pageFilesRelevant.filter((p) => p.pageId === pageId && p.isEnv(iso ? 'CLIENT_AND_SERVER' : env));\n        assertUsage(files.length <= 1, `Merge the following files into a single file: ${files.map((p) => p.filePath).join(' ')}`);\n        const pageIdFile = files[0];\n        assert(pageIdFile === undefined || !pageIdFile.isDefaultPageFile);\n        return pageIdFile;\n    };\n    const pageIdFileEnv = getPageIdFile(false);\n    const pageIdFileIso = getPageIdFile(true);\n    // A page can have only one renderer. In other words: Multiple `renderer/` overwrite each other.\n    // Load only load renderer (`/renderer/_default.*`)\n    const getRendererFile = (iso) => pageFilesRelevant.filter((p) => p.isRendererPageFile && p.isEnv(iso ? 'CLIENT_AND_SERVER' : env))[0];\n    const rendererFileEnv = getRendererFile(false);\n    const rendererFileIso = getRendererFile(true);\n    // A page can load multiple `_default.page.*` files of the same `fileType`. In other words: non-renderer `_default.page.*` files are cumulative.\n    // The exception being HTML-only pages because we pick a single page file as client entry. We handle that use case at `renderPage()`.\n    const defaultFilesNonRenderer = pageFilesRelevant.filter((p) => p.isDefaultPageFile && !p.isRendererPageFile && (p.isEnv(env) || p.isEnv('CLIENT_AND_SERVER')));\n    // Ordered by `pageContext.exports` precedence\n    const pageFiles = [pageIdFileEnv, pageIdFileIso, ...defaultFilesNonRenderer, rendererFileEnv, rendererFileIso].filter(isNotNullish);\n    return pageFiles;\n}\nfunction getPageFilesSorter(envIsClient, pageId) {\n    const env = envIsClient ? 'CLIENT_ONLY' : 'SERVER_ONLY';\n    const e1First = -1;\n    const e2First = +1;\n    const noOrder = 0;\n    return (e1, e2) => {\n        // `.page.js` files specific to `pageId` first\n        if (!e1.isDefaultPageFile && e2.isDefaultPageFile) {\n            return e1First;\n        }\n        if (!e2.isDefaultPageFile && e1.isDefaultPageFile) {\n            return e2First;\n        }\n        // Non-renderer `_default.page.*` before `renderer/**/_default.page.*`\n        {\n            const e1_isRenderer = e1.isRendererPageFile;\n            const e2_isRenderer = e2.isRendererPageFile;\n            if (!e1_isRenderer && e2_isRenderer) {\n                return e1First;\n            }\n            if (!e2_isRenderer && e1_isRenderer) {\n                return e2First;\n            }\n            assert(e1_isRenderer === e2_isRenderer);\n        }\n        // Filesystem nearest first\n        {\n            const e1_distance = getPathDistance(pageId, e1.filePath);\n            const e2_distance = getPathDistance(pageId, e2.filePath);\n            if (e1_distance < e2_distance) {\n                return e1First;\n            }\n            if (e2_distance < e1_distance) {\n                return e2First;\n            }\n            assert(e1_distance === e2_distance);\n        }\n        // `.page.server.js`/`.page.client.js` before `.page.js`\n        {\n            if (e1.isEnv(env) && e2.isEnv('CLIENT_AND_SERVER')) {\n                return e1First;\n            }\n            if (e2.isEnv(env) && e1.isEnv('CLIENT_AND_SERVER')) {\n                return e2First;\n            }\n        }\n        return noOrder;\n    };\n}\nfunction getPathDistance(pathA, pathB) {\n    // Index of first different character\n    let idx = 0;\n    for (; idx < pathA.length && idx < pathB.length; idx++) {\n        if (pathA[idx] !== pathB[idx])\n            break;\n    }\n    const pathAWithoutCommon = pathA.slice(idx);\n    const pathBWithoutCommon = pathB.slice(idx);\n    const distanceA = pathAWithoutCommon.split('/').length;\n    const distanceB = pathBWithoutCommon.split('/').length;\n    const distance = distanceA + distanceB;\n    return distance;\n}\n","export { removeBuiltInOverrides };\nimport { assert, assertWarning } from '../utils.js';\nconst BUILT_IN_CLIENT_ROUTER = ['urlPathname', 'urlParsed'];\nconst BUILT_IN_CLIENT = ['Page', 'pageExports', 'exports'];\nfunction removeBuiltInOverrides(pageContext) {\n    const alreadySet = [...BUILT_IN_CLIENT, ...BUILT_IN_CLIENT_ROUTER];\n    alreadySet.forEach((prop) => {\n        if (prop in pageContext) {\n            // We need to cast `BUILT_IN_CLIENT` to `string[]`\n            //  - https://stackoverflow.com/questions/56565528/typescript-const-assertions-how-to-use-array-prototype-includes\n            //  - https://stackoverflow.com/questions/57646355/check-if-string-is-included-in-readonlyarray-in-typescript\n            if (BUILT_IN_CLIENT_ROUTER.includes(prop)) {\n                assert(prop.startsWith('url'));\n                assertWarning(false, `pageContext.${prop} is already available in the browser when using Client Routing; adding '${prop}' to passToClient has no effect`, { onlyOnce: true });\n            }\n            else {\n                assertWarning(false, `pageContext.${prop} is a built-in that cannot be overridden; adding '${prop}' to passToClient has no effect`, { onlyOnce: true });\n            }\n            delete pageContext[prop];\n        }\n    });\n}\n","export { getPageContextRequestUrl };\nexport { pageContextJsonFileExtension };\nexport { doNotCreateExtraDirectory };\n// This module isn't loaded by the client-side of Server Routing => we don't include `urlToFile` to `./utils.ts`\nimport { urlToFile } from '../utils/urlToFile.js';\nconst pageContextJsonFileExtension = '.pageContext.json';\n// `/some-base-url/index.pageContext.json` instead of `/some-base-url.pageContext.json` in order to comply to common reverse proxy setups, see https://github.com/vikejs/vike/issues/443\nconst doNotCreateExtraDirectory = false;\n// See also node/renderPage/handlePageContextRequestUrl.ts\nfunction getPageContextRequestUrl(url) {\n    const pageContextRequestUrl = urlToFile(url, pageContextJsonFileExtension, doNotCreateExtraDirectory);\n    return pageContextRequestUrl;\n}\n","export { urlToFile };\nexport { baseServer };\nimport { assert } from './assert.js';\nimport { parseUrl } from './parseUrl.js';\nimport { slice } from './slice.js';\n// - When doing a `.pageContext.json` HTTP request, the base URL should be preserved. (The server-side will handle the base URL.)\n// - While pre-rendering there is no base URL\nconst baseServer = '/';\nfunction urlToFile(url, fileExtension, doNotCreateExtraDirectory) {\n    const { pathnameOriginal, searchOriginal, hashOriginal } = parseUrl(url, baseServer);\n    if (url.startsWith('/')) {\n        assert(url === `${pathnameOriginal}${searchOriginal || ''}${hashOriginal || ''}`, { url });\n    }\n    const hasTrailingSlash = pathnameOriginal.endsWith('/');\n    let pathnameModified;\n    if (doNotCreateExtraDirectory && pathnameOriginal !== '/') {\n        if (hasTrailingSlash) {\n            pathnameModified = slice(pathnameOriginal, 0, -1);\n        }\n        else {\n            pathnameModified = pathnameOriginal;\n        }\n        assert(!pathnameModified.endsWith('/'), { url });\n        assert(pathnameModified !== '');\n    }\n    else {\n        pathnameModified = pathnameOriginal + (hasTrailingSlash ? '' : '/') + 'index';\n    }\n    assert(pathnameModified);\n    pathnameModified = pathnameModified + fileExtension;\n    const fileUrl = `${pathnameModified}${searchOriginal || ''}${hashOriginal || ''}`;\n    return fileUrl;\n}\n","export { getPageConfig };\nexport { getConfigValueFilePathToShowToUser };\nexport { getHookFilePathToShowToUser };\nimport { assert, isArray } from '../utils.js';\nfunction getPageConfig(pageId, pageConfigs) {\n    const pageConfig = pageConfigs.find((p) => p.pageId === pageId);\n    assert(pageConfigs.length > 0);\n    assert(pageConfig);\n    return pageConfig;\n}\nfunction getConfigValueFilePathToShowToUser(definedAtData) {\n    // A unique file path only exists if the config value isn't cumulative nor computed:\n    //  - cumulative config values have multiple file paths\n    //  - computed values don't have any file path\n    if (!definedAtData || isArray(definedAtData) || definedAtData.definedBy)\n        return null;\n    const { filePathToShowToUser } = definedAtData;\n    assert(filePathToShowToUser);\n    return filePathToShowToUser;\n}\nfunction getHookFilePathToShowToUser(definedAtData) {\n    const filePathToShowToUser = getConfigValueFilePathToShowToUser(definedAtData);\n    assert(filePathToShowToUser);\n    return filePathToShowToUser;\n}\n","export { getConfigDefinedAt };\nexport { getConfigDefinedAtOptional };\nexport { getDefinedAtString };\nexport { getDefinedByString };\nimport { assert, checkType, isArray } from '../utils.js';\nimport pc from '@brillout/picocolors';\nimport { getExportPath } from './getExportPath.js';\nfunction getConfigDefinedAt(sentenceBegin, configName, definedAtData) {\n    return `${begin(sentenceBegin, configName)} at ${getDefinedAtString(definedAtData, configName)}`;\n}\nfunction getConfigDefinedAtOptional(sentenceBegin, configName, definedAtData) {\n    if (!definedAtData) {\n        return `${begin(sentenceBegin, configName)} internally`;\n    }\n    else {\n        return `${begin(sentenceBegin, configName)} at ${getDefinedAtString(definedAtData, configName)}`;\n    }\n}\nfunction begin(sentenceBegin, configName) {\n    return `${sentenceBegin} ${pc.cyan(configName)} defined`;\n}\nfunction getDefinedAtString(definedAtData, configName) {\n    let files;\n    if (isArray(definedAtData)) {\n        files = definedAtData;\n    }\n    else {\n        files = [definedAtData];\n    }\n    assert(files.length >= 1);\n    const definedAtString = files\n        .map((definedAt) => {\n        if (definedAt.definedBy)\n            return getDefinedByString(definedAt, configName);\n        const { filePathToShowToUser, fileExportPathToShowToUser } = definedAt;\n        const exportPath = getExportPath(fileExportPathToShowToUser, configName);\n        if (exportPath) {\n            return `${filePathToShowToUser} > ${pc.cyan(exportPath)}`;\n        }\n        else {\n            return filePathToShowToUser;\n        }\n    })\n        .join(' / ');\n    return definedAtString;\n}\nfunction getDefinedByString(definedAt, configName) {\n    if (definedAt.definedBy === 'api') {\n        return `API call ${pc.cyan(`${definedAt.operation}({ vikeConfig: { ${configName} } })`)}`;\n    }\n    const { definedBy } = definedAt;\n    if (definedBy === 'cli') {\n        return `CLI option ${pc.cyan(`--${configName}`)}`;\n    }\n    if (definedBy === 'env') {\n        return `environment variable ${pc.cyan(`VIKE_CONFIG=\"{${configName}}\"`)}`;\n    }\n    checkType(definedBy);\n    assert(false);\n}\n","export { getExportPath };\nimport { assert } from '../utils.js';\nfunction getExportPath(fileExportPathToShowToUser, configName) {\n    if (!fileExportPathToShowToUser)\n        return null;\n    let [exportName, ...exportObjectPath] = fileExportPathToShowToUser;\n    if (!exportName)\n        return null;\n    if (exportObjectPath.length === 0 && ['*', 'default', configName].includes(exportName))\n        return null;\n    assert(exportName !== '*');\n    let prefix = '';\n    let suffix = '';\n    if (exportName === 'default') {\n        prefix = 'export default';\n    }\n    else {\n        prefix = 'export';\n        exportObjectPath = [exportName, ...exportObjectPath];\n    }\n    exportObjectPath.forEach((prop) => {\n        prefix = `${prefix} { ${prop}`;\n        suffix = ` }${suffix}`;\n    });\n    const exportPath = prefix + suffix;\n    return exportPath;\n}\n","export { getConfigValueTyped };\nimport { assert, assertUsage, getValuePrintable } from '../utils.js';\nimport pc from '@brillout/picocolors';\nimport { getConfigDefinedAtOptional } from './getConfigDefinedAt.js';\nfunction getConfigValueTyped(configValue, configName, type) {\n    /* [NULL_HANDLING] Do we really need this? This doesn't seem to make sense, let's eventually (re)move this.\n    // Enable users to suppress global config values by setting the local config value to null\n    if (configValue.value === null) return null\n    */\n    const { value, definedAtData } = configValue;\n    if (type)\n        assertConfigValueType(value, type, configName, definedAtData);\n    return configValue;\n}\nfunction assertConfigValueType(value, type, configName, definedAtData) {\n    assert(value !== null);\n    const typeActual = typeof value;\n    if (typeActual === type)\n        return;\n    const valuePrintable = getValuePrintable(value);\n    const problem = valuePrintable !== null\n        ? `value ${pc.cyan(valuePrintable)}`\n        : `type ${pc.cyan(typeActual)}`;\n    const configDefinedAt = getConfigDefinedAtOptional('Config', configName, definedAtData);\n    const errMsg = `${configDefinedAt} has an invalid ${problem}: it should be a ${pc.cyan(type)} instead`;\n    assertUsage(false, errMsg);\n}\n","export function getValuePrintable(value) {\n    if ([null, undefined].includes(value))\n        return String(value);\n    if (['boolean', 'number', 'string'].includes(typeof value))\n        return JSON.stringify(value);\n    return null;\n}\n","export { getConfigValueRuntime };\nimport { getConfigValueTyped } from './getConfigValueTyped.js';\nfunction getConfigValueRuntime(pageConfig, configName, type) {\n    const configValue = pageConfig.configValues[configName];\n    if (!configValue)\n        return null;\n    return getConfigValueTyped(configValue, configName, type);\n}\n","export { assertPageContextProvidedByUser };\nimport { assert, assertUsage, assertWarning, isObject } from './utils.js';\nimport pc from '@brillout/picocolors';\nfunction assertPageContextProvidedByUser(pageContextProvidedByUser, { hookName, hookFilePath, }) {\n    if (pageContextProvidedByUser === undefined || pageContextProvidedByUser === null)\n        return;\n    assert(!hookName.endsWith(')'));\n    const errPrefix = `The ${pc.cyan('pageContext')} object provided by the ${hookName}() hook defined by ${hookFilePath}`;\n    assertUsage(isObject(pageContextProvidedByUser), `${errPrefix} should be an object (but it's ${pc.cyan(`typeof pageContext === ${JSON.stringify(typeof pageContextProvidedByUser)}`)} instead)`);\n    assertUsage(!('isPageContext' in pageContextProvidedByUser), `${errPrefix} shouldn't be the whole ${pc.cyan('pageContext')} object, see https://vike.dev/pageContext-manipulation#do-not-return-entire-pagecontext`);\n    // In principle, it's possible to use onBeforeRoute()` to override and define the whole routing.\n    // Is that a good idea to allow users to do this? Beyond deep integration with Vue Router or React Router, is there a use case for this?\n    assertWarning(!('pageId' in pageContextProvidedByUser), `${errPrefix} sets ${pc.cyan('pageContext.pageId')} which means that Vike's routing is overridden. This is an experimental feature: make sure to contact a vike maintainer before using this.`, { onlyOnce: true });\n    assertUsage(!('is404' in pageContextProvidedByUser), `${errPrefix} sets ${pc.cyan('pageContext.is404')} which is forbidden, use ${pc.cyan('throw render()')} instead, see https://vike.dev/render`);\n}\n","export { assertOnBeforeRenderHookReturn };\nimport { assertUsage, isPlainObject } from './utils.js';\nimport { assertPageContextProvidedByUser } from './assertPageContextProvidedByUser.js';\nimport { assertHookReturnedObject } from './assertHookReturnedObject.js';\nimport pc from '@brillout/picocolors';\nfunction assertOnBeforeRenderHookReturn(hookReturnValue, hookFilePath) {\n    if (hookReturnValue === undefined || hookReturnValue === null) {\n        return;\n    }\n    const errPrefix = `The onBeforeRender() hook defined by ${hookFilePath}`;\n    assertUsage(isPlainObject(hookReturnValue), `${errPrefix} should return a plain JavaScript object, ${pc.cyan('undefined')}, or ${pc.cyan('null')}`);\n    assertHookReturnedObject(hookReturnValue, ['pageContext'], errPrefix);\n    if (hookReturnValue.pageContext) {\n        assertPageContextProvidedByUser(hookReturnValue['pageContext'], { hookName: 'onBeforeRender', hookFilePath });\n    }\n}\n","export { assertHookReturnedObject };\nimport { assert, assertUsage, stringifyStringArray } from './utils.js';\nfunction assertHookReturnedObject(obj, keysExpected, errPrefix) {\n    assert(!errPrefix.endsWith(' '));\n    const keysUnknown = [];\n    const keys = Object.keys(obj);\n    for (const key of keys) {\n        if (!keysExpected.includes(key)) {\n            keysUnknown.push(key);\n        }\n    }\n    assertUsage(keysUnknown.length === 0, [\n        errPrefix,\n        'returned an object with following unknown keys:',\n        stringifyStringArray(keysUnknown) + '.',\n        'Only following keys are allowed:',\n        stringifyStringArray(keysExpected) + '.',\n    ].join(' '));\n}\n","export { getHookFromPageContext };\nexport { getHookFromPageContextNew };\nexport { getHookFromPageConfig };\nexport { getHookFromPageConfigGlobal };\nexport { getHookFromPageConfigGlobalCumulative };\nexport { getHook_setIsPrerenderering };\n// TO-DO/next-major-release: remove\n// We export for old V0.4 design which doesn't support config.hooksTimeout\nexport { getHookTimeoutDefault };\nimport { getGlobalObject } from '../../utils/getGlobalObject.js';\nimport { getHookFilePathToShowToUser } from '../page-configs/helpers.js';\nimport { getConfigValueRuntime } from '../page-configs/getConfigValueRuntime.js';\nimport { assert, assertUsage, checkType, isArray, isCallable, isObject } from '../utils.js';\nimport pc from '@brillout/picocolors';\nconst globalObject = getGlobalObject('hooks/getHook.ts', {});\nfunction getHookFromPageContext(pageContext, hookName) {\n    if (!(hookName in pageContext.exports)) {\n        return null;\n    }\n    const { hooksTimeout } = pageContext.config;\n    const hookTimeout = getHookTimeout(hooksTimeout, hookName);\n    const hookFn = pageContext.exports[hookName];\n    if (hookFn === null)\n        return null;\n    // TO-DO/eventually: use pageContext.configEntries in favor of pageContext.exportsAll once V0.4 is removed\n    const file = pageContext.exportsAll[hookName][0];\n    assert(file.exportValue === hookFn);\n    const hookFilePath = file.filePath;\n    assert(hookFilePath);\n    return getHook(hookFn, hookName, hookFilePath, hookTimeout);\n}\n// TO-DO/eventually: remove getHookFromPageContext() in favor of getHookFromPageContextNew()\nfunction getHookFromPageContextNew(hookName, pageContext) {\n    const { hooksTimeout } = pageContext.config;\n    const hookTimeout = getHookTimeout(hooksTimeout, hookName);\n    const hooks = [];\n    /* TO-DO/eventually: use pageContext.configEntries in favor of pageContext.exportsAll once V0.4 is removed\n    pageContext.configEntries[hookName]?.forEach((val) => {\n      const hookFn = val.configValue\n      if (hookFn === null) return\n      const hookFilePath = val.configDefinedByFile\n    */\n    pageContext.exportsAll[hookName]?.forEach((val) => {\n        const hookFn = val.exportValue;\n        if (hookFn === null)\n            return;\n        const hookFilePath = val.filePath;\n        assert(hookFilePath);\n        hooks.push(getHook(hookFn, hookName, hookFilePath, hookTimeout));\n    });\n    return hooks;\n}\nfunction getHookFromPageConfig(pageConfig, hookName) {\n    const configValue = getConfigValueRuntime(pageConfig, hookName);\n    if (!configValue?.value)\n        return null;\n    const { hookFn, hookFilePath } = getHookFromConfigValue(configValue);\n    const hooksTimeout = getConfigValueRuntime(pageConfig, 'hooksTimeout')?.value;\n    const hookTimeout = getHookTimeout(hooksTimeout, hookName);\n    return getHook(hookFn, hookName, hookFilePath, hookTimeout);\n}\nfunction getHookFromPageConfigGlobal(pageConfigGlobal, hookName) {\n    const configValue = pageConfigGlobal.configValues[hookName];\n    if (!configValue?.value)\n        return null;\n    const { hookFn, hookFilePath } = getHookFromConfigValue(configValue);\n    const hookTimeout = getHookTimeoutGlobal(hookName);\n    return getHook(hookFn, hookName, hookFilePath, hookTimeout);\n}\nfunction getHookFromPageConfigGlobalCumulative(pageConfigGlobal, hookName) {\n    const configValue = pageConfigGlobal.configValues[hookName];\n    if (!configValue?.value)\n        return [];\n    const val = configValue.value;\n    assert(isArray(val));\n    return val.map((v, i) => {\n        const hookFn = v;\n        const hookTimeout = getHookTimeoutGlobal(hookName);\n        assert(isArray(configValue.definedAtData));\n        const hookFilePath = getHookFilePathToShowToUser(configValue.definedAtData[i]);\n        return getHook(hookFn, hookName, hookFilePath, hookTimeout);\n    });\n}\nfunction getHookTimeoutGlobal(hookName) {\n    // TO-DO/perfection: we could use the global value of configooksTimeout but it requires some non-trivial refactoring\n    const hookTimeout = getHookTimeoutDefault(hookName);\n    return hookTimeout;\n}\nfunction getHook(hookFn, hookName, hookFilePath, hookTimeout) {\n    assert(hookFilePath);\n    assertHookFn(hookFn, { hookName, hookFilePath });\n    const hook = { hookFn, hookName, hookFilePath, hookTimeout };\n    return hook;\n}\nfunction getHookFromConfigValue(configValue) {\n    const hookFn = configValue.value;\n    assert(hookFn);\n    const hookFilePath = getHookFilePathToShowToUser(configValue.definedAtData);\n    return { hookFn, hookFilePath };\n}\nfunction assertHookFn(hookFn, { hookName, hookFilePath }) {\n    assert(hookName && hookFilePath);\n    assert(!hookName.endsWith(')'));\n    assert(!hookFilePath.endsWith(' '));\n    assertUsage(isCallable(hookFn), `Hook ${hookName}() defined by ${hookFilePath} should be a function`);\n    checkType(hookFn);\n}\nfunction getHookTimeout(hooksTimeoutProvidedByUser, hookName) {\n    const hooksTimeoutProvidedbyUserNormalized = getHooksTimeoutProvidedByUserNormalized(hooksTimeoutProvidedByUser);\n    if (hooksTimeoutProvidedbyUserNormalized === false)\n        return { error: false, warning: false };\n    const providedbyUser = hooksTimeoutProvidedbyUserNormalized[hookName];\n    const hookTimeout = getHookTimeoutDefault(hookName);\n    if (providedbyUser?.error !== undefined)\n        hookTimeout.error = providedbyUser.error;\n    if (providedbyUser?.warning !== undefined)\n        hookTimeout.warning = providedbyUser.warning;\n    return hookTimeout;\n}\n// Ideally this should be called only once and at build-time (to avoid bloating the client-side bundle), but we didn't implement any mechanism to valid config values at build-time yet\nfunction getHooksTimeoutProvidedByUserNormalized(hooksTimeoutProvidedByUser) {\n    if (hooksTimeoutProvidedByUser === undefined)\n        return {};\n    if (hooksTimeoutProvidedByUser === false)\n        return false;\n    assertUsage(isObject(hooksTimeoutProvidedByUser), `Setting ${pc.cyan('hooksTimeout')} should be ${pc.cyan('false')} or an object`);\n    const hooksTimeoutProvidedByUserNormalized = {};\n    Object.entries(hooksTimeoutProvidedByUser).forEach(([hookName, hookTimeoutProvidedbyUser]) => {\n        if (hookTimeoutProvidedbyUser === false) {\n            hooksTimeoutProvidedByUserNormalized[hookName] = { error: false, warning: false };\n            return;\n        }\n        assertUsage(isObject(hookTimeoutProvidedbyUser), `Setting ${pc.cyan(`hooksTimeout.${hookName}`)} should be ${pc.cyan('false')} or an object`);\n        const [error, warning] = ['error', 'warning'].map((timeoutName) => {\n            const timeoutVal = hookTimeoutProvidedbyUser[timeoutName];\n            if (timeoutVal === undefined || timeoutVal === false)\n                return timeoutVal;\n            const errPrefix = `Setting ${pc.cyan(`hooksTimeout.${hookName}.${timeoutName}`)} should be`;\n            assertUsage(typeof timeoutVal === 'number', `${errPrefix} ${pc.cyan('false')} or a number`);\n            assertUsage(timeoutVal > 0, `${errPrefix} a positive number`);\n            return timeoutVal;\n        });\n        hooksTimeoutProvidedByUserNormalized[hookName] = { error, warning };\n    });\n    return hooksTimeoutProvidedByUserNormalized;\n}\nfunction getHookTimeoutDefault(hookName) {\n    if (hookName === 'onBeforeRoute') {\n        return {\n            error: 5 * 1000,\n            warning: 1 * 1000,\n        };\n    }\n    if (globalObject.isPrerendering) {\n        return {\n            error: 2 * 60 * 1000,\n            warning: 30 * 1000,\n        };\n    }\n    else {\n        assert(!hookName.toLowerCase().includes('prerender'));\n    }\n    return {\n        error: 30 * 1000,\n        warning: 4 * 1000,\n    };\n}\nfunction getHook_setIsPrerenderering() {\n    globalObject.isPrerendering = true;\n}\n","export { debug };\nexport { createDebugger };\nexport { isDebug };\nexport { isDebugActivated };\nimport { isCallable } from './isCallable.js';\nimport { objectAssign } from './objectAssign.js';\nimport { assert, assertUsage } from './assert.js';\nimport { getTerminalWidth } from './getTerminalWidth.js';\nimport pc from '@brillout/picocolors';\nimport { isArray } from './isArray.js';\nimport { isObject } from './isObject.js';\n// Assert tree-shaking (ensure this module is loaded on the client-side only if debug is enabled).\nassert(!globalThis.__VIKE__IS_CLIENT ||\n    globalThis.__VIKE__IS_DEBUG ||\n    // Vite doesn't do tree-shaking in dev (maybe it will with Rolldown?)\n    import.meta.env.DEV);\nconst flags = [\n    'vike',\n    'vike:crawl',\n    'vike:error',\n    'vike:esbuild-resolve',\n    'vike:pluginExtractAssets',\n    'vike:pluginExtractExportNames',\n    'vike:glob',\n    'vike:globalContext',\n    'vike:log',\n    'vike:optimizeDeps',\n    'vike:outDir',\n    'vike:pageFiles',\n    'vike:pointer-imports',\n    'vike:requireResolve',\n    'vike:routing',\n    'vike:setup',\n    'vike:stream',\n    'vike:virtualFiles',\n    'vike:vite-rpc',\n];\nconst flagsSkipWildcard = ['vike:log'];\n// We purposely read process.env.DEBUG early, in order to avoid users from the temptation to set process.env.DEBUG with JavaScript, since reading & writing process.env.DEBUG dynamically leads to inconsistencies such as https://github.com/vikejs/vike/issues/2239\nconst DEBUG = getDEBUG() ?? '';\nif (isDebug())\n    Error.stackTraceLimit = Infinity;\nassertFlagsActivated();\nfunction createDebugger(flag, optionsGlobal) {\n    assert(flags.includes(flag));\n    const debugWithOptions = (optionsLocal) => {\n        return (...msgs) => {\n            const options = { ...optionsGlobal, ...optionsLocal };\n            debug_(flag, options, ...msgs);\n        };\n    };\n    const debug = (...msgs) => debugWithOptions({})(...msgs);\n    objectAssign(debug, { options: debugWithOptions, isActivated: isDebugActivated(flag) });\n    return debug;\n}\nfunction debug(flag, ...msgs) {\n    return debug_(flag, {}, ...msgs);\n}\nfunction debug_(flag, options, ...msgs) {\n    if (!isDebugActivated(flag))\n        return;\n    let [msgFirst, ...msgsRest] = msgs;\n    const padding = ' '.repeat(flag.length + 1);\n    msgFirst = formatMsg(msgFirst, options, padding, 'FIRST');\n    msgsRest = msgsRest.map((msg, i) => {\n        const position = i === msgsRest.length - 1 ? 'LAST' : 'MIDDLE';\n        return formatMsg(msg, options, padding, position);\n    });\n    let logFirst;\n    let logsRest;\n    const noNewLine = msgsRest.length <= 1 &&\n        [msgFirst, ...msgsRest].every((m) => (typeof m === 'string' ? !m.includes('\\n') : !isObject(m)));\n    if (noNewLine) {\n        logFirst = [msgFirst, ...msgsRest].map((m) => (typeof m !== 'string' ? m : m.trim()));\n        logsRest = [];\n    }\n    else {\n        logFirst = [msgFirst];\n        logsRest = msgsRest;\n    }\n    console.log('\\x1b[1m%s\\x1b[0m', flag, ...logFirst);\n    logsRest.forEach((msg) => {\n        console.log(msg);\n    });\n}\nfunction isDebugActivated(flag) {\n    assert(flags.includes(flag));\n    const { flagsActivated, isAll } = getFlagsActivated();\n    const isActivated = flagsActivated.includes(flag) || (isAll && !flagsSkipWildcard.includes(flag));\n    return isActivated;\n}\nfunction formatMsg(info, options, padding, position) {\n    if (info === undefined) {\n        return undefined;\n    }\n    let str = position === 'FIRST' ? '' : padding;\n    if (typeof info === 'string') {\n        str += info;\n    }\n    else if (isArray(info)) {\n        if (info.length === 0) {\n            str += options.serialization?.emptyArray ?? '[]';\n        }\n        else {\n            str += info.map(strUnknown).join('\\n');\n        }\n    }\n    else {\n        str += strUnknown(info);\n    }\n    str = pad(str, padding);\n    if (position !== 'LAST' && position !== 'FIRST') {\n        str += '\\n';\n    }\n    return str;\n}\nfunction pad(str, padding) {\n    const terminalWidth = getTerminalWidth();\n    const lines = [];\n    str.split('\\n').forEach((line) => {\n        if (!terminalWidth) {\n            lines.push(line);\n        }\n        else {\n            chunk(line, terminalWidth - padding.length).forEach((chunk) => {\n                lines.push(chunk);\n            });\n        }\n    });\n    return lines.join('\\n' + padding);\n}\nfunction chunk(str, size) {\n    if (str.length <= size) {\n        return [str];\n    }\n    const chunks = str.match(new RegExp('.{1,' + size + '}', 'g'));\n    assert(chunks);\n    return chunks;\n}\nfunction strUnknown(thing) {\n    return typeof thing === 'string' ? thing : strObj(thing);\n}\nfunction strObj(obj, newLines = true) {\n    return JSON.stringify(obj, replaceFunctionSerializer, newLines ? 2 : undefined);\n}\nfunction replaceFunctionSerializer(_key, value) {\n    if (isCallable(value)) {\n        return value.toString().split(/\\s+/).join(' ');\n    }\n    return value;\n}\nfunction assertFlagsActivated() {\n    const { flagsActivated } = getFlagsActivated();\n    flagsActivated.forEach((flag) => {\n        assertUsage(flags.includes(flag), `Unknown DEBUG flag ${pc.cyan(flag)}. Valid flags:\\n${flags.map((f) => `  ${pc.cyan(f)}`).join('\\n')}`);\n    });\n}\nfunction getFlagsActivated() {\n    const flagsActivated = DEBUG.match(/\\bvike:[a-zA-Z-]+/g) ?? [];\n    const isAll = DEBUG.includes('vike:*');\n    const isGlobal = /\\bvike\\b([^:]|$)/.test(DEBUG);\n    return { flagsActivated, isAll, isGlobal };\n}\nfunction isDebug() {\n    const { flagsActivated, isAll, isGlobal } = getFlagsActivated();\n    return isAll || flagsActivated.length > 0 || isGlobal;\n}\nfunction getDEBUG() {\n    let DEBUG;\n    // ssr.noExternal\n    /* // Full implementation:\n       // - https://github.com/vikejs/vike/commit/7637564a98f43e23834bcae2f7ada8d941958a34\n       // - https://github.com/vikejs/vike/pull/2718\n       // - We don't implement this yet because it crashes @cloudflare/vite-plugin\n    if (import.meta.env) {\n      return import.meta.env.DEBUG\n    }\n    //*/\n    // ssr.external\n    // - `process` can be undefined in edge workers\n    // - We want bundlers to be able to statically replace `process.env.*`\n    try {\n        DEBUG = process.env.DEBUG;\n    }\n    catch { }\n    return DEBUG;\n}\n","export { humanizeTime };\nfunction humanizeTime(milliseconds) {\n    const seconds = milliseconds / 1000;\n    if (seconds < 120) {\n        const n = round(seconds);\n        return `${n} second${plural(n)}`;\n    }\n    {\n        const minutes = seconds / 60;\n        const n = round(minutes);\n        return `${n} minute${plural(n)}`;\n    }\n}\nfunction round(n) {\n    let rounded = n.toFixed(1);\n    if (rounded.endsWith('.0'))\n        rounded = rounded.slice(0, -2);\n    return rounded;\n}\nfunction plural(n) {\n    return n === '1' ? '' : 's';\n}\n","export { addIs404ToPageProps };\nimport { assertWarning, isObject } from './utils.js';\nfunction addIs404ToPageProps(pageContext) {\n    addIs404(pageContext);\n}\nfunction addIs404(pageContext) {\n    if (pageContext.is404 === undefined || pageContext.is404 === null)\n        return;\n    const pageProps = pageContext.pageProps || {};\n    if (!isObject(pageProps)) {\n        assertWarning(false, 'pageContext.pageProps should be an object', { showStackTrace: true, onlyOnce: true });\n        return;\n    }\n    pageProps.is404 = pageProps.is404 || pageContext.is404;\n    pageContext.pageProps = pageProps;\n}\n","// Utils needed by:\n//  - runtime of server\n//  - runtime of client (Client Routing)\n// Ensure we don't bloat runtime of Server Routing with the utils down below\nimport { assertClientRouting } from '../../utils/assertRoutingType.js';\nimport { isBrowser } from '../../utils/isBrowser.js';\nif (isBrowser()) {\n    assertClientRouting();\n}\nexport * from '../../utils/assert.js';\nexport * from '../../utils/hasProp.js';\nexport * from '../../utils/isObjectWithKeys.js';\nexport * from '../../utils/sorter.js';\nexport * from '../../utils/isPromise.js';\nexport * from '../../utils/isPlainObject.js';\nexport * from '../../utils/objectAssign.js';\nexport * from '../../utils/slice.js';\nexport * from '../../utils/unique.js';\nexport * from '../../utils/isBrowser.js';\nexport * from '../../utils/parseUrl.js';\nexport * from '../../utils/checkType.js';\nexport * from '../../utils/joinEnglish.js';\nexport * from '../../utils/truncateString.js';\nexport * from '../../utils/isCallable.js';\nexport * from '../../utils/debug.js';\n","export const NOT_SERIALIZABLE = '__VIKE__NOT_SERIALIZABLE__';\n","export { getProxyForPublicUsage };\n// We use a proxy instead of property getters.\n// - The issue with property getters is that they can't be `writable: true` but we do want the user to be able to modify the value of internal properties.\n//   ```console\n//   TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #<Object>\n//   ```\n// - Previous implementation using property getters: https://github.com/vikejs/vike/blob/4dbb354b0bcec04e862041fc9183fc4691bb8711/vike/utils/makePublicCopy.ts\n// Show warning when user is accessing internal `_` properties.\nimport { NOT_SERIALIZABLE } from './NOT_SERIALIZABLE.js';\nimport { assert, assertUsage, assertWarning, getPropAccessNotation, isBrowser } from './utils.js';\nfunction getProxyForPublicUsage(obj, objName, skipOnInternalProp, fallback) {\n    return new Proxy(obj, {\n        get: (_, prop) => getProp(prop, obj, objName, skipOnInternalProp, fallback),\n    });\n}\nfunction getProp(prop, obj, objName, skipOnInternalProp, fallback) {\n    const propStr = String(prop);\n    if (prop === '_isProxyObject')\n        return true;\n    if (prop === 'dangerouslyUseInternals')\n        return obj;\n    if (!skipOnInternalProp) {\n        if (!globalThis.__VIKE__IS_CLIENT)\n            onInternalProp(propStr, objName);\n    }\n    if (fallback && !(prop in obj)) {\n        // Rudimentary flat pageContext implementation https://github.com/vikejs/vike/issues/1268\n        // Failed full-fledged implementation: https://github.com/vikejs/vike/pull/2458\n        return fallback(prop);\n    }\n    const val = obj[prop];\n    onNotSerializable(propStr, val, objName);\n    return val;\n}\nfunction onNotSerializable(propStr, val, objName) {\n    if (val !== NOT_SERIALIZABLE)\n        return;\n    const propName = getPropAccessNotation(propStr);\n    assert(isBrowser());\n    assertUsage(false, `Can't access ${objName}${propName} on the client side. Because it can't be serialized, see server logs.`);\n}\nfunction onInternalProp(propStr, objName) {\n    // We must skip it on the client-side because of the reactivity mechanism of UI frameworks like Solid.\n    assert(!isBrowser());\n    // TO-DO/soon/proxy: remove this and only warn on built-in access instead\n    if (propStr === '_configFromHook')\n        return;\n    if (propStr.startsWith('_')) {\n        assertWarning(false, `Using internal ${objName}.${propStr}  https://vike.dev/warning/internals`, {\n            onlyOnce: true,\n            showStackTrace: true,\n        });\n    }\n}\n","export function getPropAccessNotation(key) {\n    return typeof key === 'string' && isKeyDotNotationCompatible(key) ? `.${key}` : `[${JSON.stringify(key)}]`;\n}\nfunction isKeyDotNotationCompatible(key) {\n    return /^[a-z0-9\\$_]+$/i.test(key);\n}\n","export { prepareGlobalContextForPublicUsage };\nimport { getProxyForPublicUsage } from './getProxyForPublicUsage.js';\nimport { assert } from './utils.js';\nfunction prepareGlobalContextForPublicUsage(globalContext) {\n    assert(globalContext._isOriginalObject); // ensure we preserve the original object reference\n    const globalContextPublic = getProxyForPublicUsage(globalContext, 'globalContext');\n    return globalContextPublic;\n}\n","export { preparePageContextForPublicUsage };\nexport { assertPropertyGetters };\nimport { assert, assertWarning, compareString, isPropertyGetter } from './utils.js';\nimport { addIs404ToPageProps } from './addIs404ToPageProps.js';\nimport { prepareGlobalContextForPublicUsage, } from './prepareGlobalContextForPublicUsage.js';\nimport { getProxyForPublicUsage } from './getProxyForPublicUsage.js';\nfunction preparePageContextForPublicUsage(pageContext) {\n    assert(!pageContext._isProxyObject);\n    assert(!pageContext.globalContext); // pageContext.globalContext should only be available to users  Vike itself should use pageContext._globalContext instead\n    assert(pageContext._isOriginalObject); // ensure we preserve the original object reference\n    addIs404ToPageProps(pageContext);\n    // TO-DO/next-major-release: remove\n    if (!('_pageId' in pageContext)) {\n        Object.defineProperty(pageContext, '_pageId', {\n            get() {\n                assertWarning(false, 'pageContext._pageId has been renamed to pageContext.pageId', {\n                    showStackTrace: true,\n                    onlyOnce: true,\n                });\n                return pageContext.pageId;\n            },\n            enumerable: false,\n        });\n    }\n    // For a more readable `console.log(pageContext)` output\n    sortPageContext(pageContext);\n    const globalContextPublic = prepareGlobalContextForPublicUsage(pageContext._globalContext);\n    const pageContextPublic = getProxyForPublicUsage(pageContext, 'pageContext', \n    // We must skip it in the client-side because of the reactivity mechanism of UI frameworks like Solid.\n    // - TO-DO/soon/proxy: double check whether that's true\n    true, (prop) => {\n        if (prop === 'globalContext') {\n            return globalContextPublic;\n        }\n        if (prop in globalContextPublic) {\n            return globalContextPublic[prop];\n        }\n    });\n    return pageContextPublic;\n}\n// Sort `pageContext` keys alphabetically, in order to make reading the `console.log(pageContext)` output easier\nfunction sortPageContext(pageContext) {\n    let descriptors = Object.getOwnPropertyDescriptors(pageContext);\n    for (const key of Object.keys(pageContext))\n        delete pageContext[key];\n    descriptors = Object.fromEntries(Object.entries(descriptors).sort(([key1], [key2]) => compareString(key1, key2)));\n    Object.defineProperties(pageContext, descriptors);\n}\nfunction assertPropertyGetters(pageContext) {\n    /*\n    If the isPropertyGetter() assertions fail then it's most likely because Object.assign() was used instead of `objectAssign()`:\n    ```js\n    const PageContextUrlComputed = getPageContextUrlComputed(pageContext)\n  \n    //  Breaks the property descriptors/getters of pageContext defined by getPageContextUrlComputed() such as pageContext.urlPathname\n    Object.assign(pageContext, pageContextUrlComputed)\n  \n    //  Also breaks property descriptors/getters\n    const pageContext = { ...pageContextUrlComputed }\n  \n    //  Preserves property descriptors/getters (see objectAssign() implementation)\n    objectAssign(pageContext, pageContextUrlComputed)\n    ```\n    */\n    ;\n    [\n        'urlPathname',\n        // TO-DO/next-major-release: remove\n        'urlParsed',\n        // TO-DO/next-major-release: remove\n        'url',\n        // TO-DO/next-major-release: remove\n        'pageExports',\n    ].forEach((prop) => {\n        if (pageContext.prop)\n            assert(isPropertyGetter(pageContext, prop));\n    });\n}\n","export { compareString };\nfunction compareString(str1, str2) {\n    if (str1.toLowerCase() < str2.toLowerCase())\n        return -1;\n    if (str1.toLowerCase() > str2.toLowerCase())\n        return 1;\n    return 0;\n}\n","export function isPropertyGetter(obj, prop) {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n    return !!descriptor && !('value' in descriptor) && !!descriptor.get;\n}\n","export { execHook };\nexport { execHookGlobal };\nexport { execHookDirect };\nexport { execHookDirectSingle };\nexport { execHookDirectSingleWithReturn };\nexport { execHookDirectWithoutPageContext };\nexport { execHookDirectSync };\nexport { getPageContext };\nexport { providePageContext };\nexport { isUserHookError };\nimport { getProjectError, assertWarning, assertUsage } from '../../utils/assert.js';\nimport { getGlobalObject } from '../../utils/getGlobalObject.js';\nimport { humanizeTime } from '../../utils/humanizeTime.js';\nimport { isObject } from '../../utils/isObject.js';\nimport { getHookFromPageConfigGlobalCumulative, getHookFromPageContextNew } from './getHook.js';\nimport { preparePageContextForPublicUsage, } from '../preparePageContextForPublicUsage.js';\nconst globalObject = getGlobalObject('utils/execHook.ts', {\n    userHookErrors: new WeakMap(),\n    pageContext: null,\n});\nasync function execHook(hookName, pageContext, preparePageContextForPublicUsage) {\n    const hooks = getHookFromPageContextNew(hookName, pageContext);\n    return await execHookDirect(hooks, pageContext, preparePageContextForPublicUsage);\n}\nasync function execHookGlobal(hookName, pageConfigGlobal, pageContext, hookArg, prepareForPublicUsage) {\n    const hooks = getHookFromPageConfigGlobalCumulative(pageConfigGlobal, hookName);\n    const hookArgForPublicUsage = prepareForPublicUsage(hookArg);\n    await Promise.all(hooks.map(async (hook) => {\n        await execHookDirectAsync(() => hook.hookFn(hookArgForPublicUsage), hook, pageContext);\n    }));\n}\nasync function execHookDirect(hooks, pageContext, preparePageContextForPublicUsage) {\n    if (!hooks.length)\n        return [];\n    const pageContextForPublicUsage = preparePageContextForPublicUsage(pageContext);\n    const hooksWithResult = await Promise.all(hooks.map(async (hook) => {\n        const hookReturn = await execHookDirectAsync(() => hook.hookFn(pageContextForPublicUsage), hook, pageContextForPublicUsage);\n        return { ...hook, hookReturn };\n    }));\n    return hooksWithResult;\n}\nasync function execHookDirectSingle(hook, pageContext, preparePageContextForPublicUsage) {\n    const hooksWithResult = await execHookDirect([hook], pageContext, preparePageContextForPublicUsage);\n    const { hookReturn } = hooksWithResult[0];\n    assertUsage(hookReturn === undefined, `The ${hook.hookName}() hook defined by ${hook.hookFilePath} isn't allowed to return a value`);\n}\nasync function execHookDirectSingleWithReturn(hook, pageContext, preparePageContextForPublicUsage) {\n    const hooksWithResult = await execHookDirect([hook], pageContext, preparePageContextForPublicUsage);\n    const { hookReturn } = hooksWithResult[0];\n    return { hookReturn };\n}\nfunction isUserHookError(err) {\n    if (!isObject(err))\n        return false;\n    return globalObject.userHookErrors.get(err) ?? false;\n}\nasync function execHookDirectWithoutPageContext(hookFnCaller, hook) {\n    const { hookName, hookFilePath, hookTimeout } = hook;\n    const hookReturn = await execHookDirectAsync(hookFnCaller, { hookName, hookFilePath, hookTimeout }, null);\n    return hookReturn;\n}\nfunction execHookDirectAsync(hookFnCaller, hook, pageContextForPublicUsage) {\n    const { hookName, hookFilePath, hookTimeout: { error: timeoutErr, warning: timeoutWarn }, } = hook;\n    let resolve;\n    let reject;\n    const promise = new Promise((resolve_, reject_) => {\n        resolve = (ret) => {\n            clearTimeouts();\n            resolve_(ret);\n        };\n        reject = (err) => {\n            clearTimeouts();\n            reject_(err);\n        };\n    });\n    const clearTimeouts = () => {\n        if (currentTimeoutWarn)\n            clearTimeout(currentTimeoutWarn);\n        if (currentTimeoutErr)\n            clearTimeout(currentTimeoutErr);\n    };\n    const currentTimeoutWarn = isNotDisabled(timeoutWarn) &&\n        setTimeout(() => {\n            assertWarning(false, `The ${hookName}() hook defined by ${hookFilePath} is slow: it's taking more than ${humanizeTime(timeoutWarn)} (https://vike.dev/hooksTimeout)`, { onlyOnce: false });\n        }, timeoutWarn);\n    const currentTimeoutErr = isNotDisabled(timeoutErr) &&\n        setTimeout(() => {\n            const err = getProjectError(`The ${hookName}() hook defined by ${hookFilePath} timed out: it didn't finish after ${humanizeTime(timeoutErr)} (https://vike.dev/hooksTimeout)`);\n            reject(err);\n        }, timeoutErr);\n    (async () => {\n        try {\n            providePageContextInternal(pageContextForPublicUsage);\n            const ret = await hookFnCaller();\n            resolve(ret);\n        }\n        catch (err) {\n            if (isObject(err)) {\n                globalObject.userHookErrors.set(err, { hookName, hookFilePath });\n            }\n            reject(err);\n        }\n    })();\n    return promise;\n}\nfunction execHookDirectSync(hook, pageContext, preparePageContextForPublicUsage) {\n    const pageContextForPublicUsage = preparePageContextForPublicUsage(pageContext);\n    providePageContextInternal(pageContextForPublicUsage);\n    const hookReturn = hook.hookFn(pageContextForPublicUsage);\n    return { hookReturn };\n}\nfunction isNotDisabled(timeout) {\n    return !!timeout && timeout !== Infinity;\n}\n/**\n * Access `pageContext` object inside Vike hooks, in order to create universal hooks.\n *\n * https://vike.dev/getPageContext\n */\nfunction getPageContext() {\n    const { pageContext } = globalObject;\n    if (!pageContext)\n        return null;\n    const pageContextForPublicUsage = pageContext._isProxyObject\n        ? // providePageContext() is called on the user-land (e.g. it's called by `vike-{react,vue,solid}`) thus it's already a proxy\n            pageContext\n        : preparePageContextForPublicUsage(pageContext);\n    return pageContextForPublicUsage;\n}\n/**\n * Provide `pageContext` for universal hooks.\n *\n * https://vike.dev/getPageContext\n */\nfunction providePageContext(pageContext) {\n    providePageContextInternal(pageContext);\n}\nfunction providePageContextInternal(pageContext) {\n    globalObject.pageContext = pageContext;\n    // Promise.resolve() is quicker than process.nextTick() and setImmediate()\n    // https://stackoverflow.com/questions/67949576/process-nexttick-before-promise-resolve-then\n    Promise.resolve().then(() => {\n        globalObject.pageContext = null;\n    });\n}\n","export { execHookGuard };\nimport { getHookFromPageContext, getHookTimeoutDefault } from '../hooks/getHook.js';\nimport { assert, assertUsage, isCallable } from './utils.js';\nimport { execHookDirectSingle } from '../hooks/execHook.js';\nconst errIntro = 'The guard() hook defined by';\nasync function execHookGuard(pageContext, prepareForPublicUsage) {\n    let hook;\n    if (pageContext._globalContext._pageFilesAll.length > 0) {\n        // TO-DO/next-major-release: remove\n        // V0.4 design\n        assert(pageContext._globalContext._pageConfigs.length === 0);\n        hook = findPageGuard(pageContext.pageId, pageContext._globalContext._pageFilesAll);\n    }\n    else {\n        // V1 design\n        hook = getHookFromPageContext(pageContext, 'guard');\n    }\n    if (!hook)\n        return;\n    await execHookDirectSingle(hook, pageContext, prepareForPublicUsage);\n}\nfunction findPageGuard(pageId, pageFilesAll) {\n    const pageRouteFile = pageFilesAll.find((p) => p.pageId === pageId && p.fileType === '.page.route');\n    if (!pageRouteFile)\n        return null;\n    const { filePath, fileExports } = pageRouteFile;\n    assert(fileExports); // loadPageRoutes() should already have been called\n    const hookFn = fileExports.guard;\n    if (!hookFn)\n        return null;\n    const hookFilePath = filePath;\n    const hookTimeout = getHookTimeoutDefault('guard');\n    assertUsage(isCallable(hookFn), `${errIntro} ${hookFilePath} should be a function`);\n    return { hookFn, hookName: 'guard', hookFilePath, hookTimeout };\n}\n","export { redirect };\nexport { render };\nexport { RenderErrorPage };\nexport { isAbortError };\nexport { isAbortPageContext };\nexport { logAbortErrorHandled };\nexport { getPageContextFromAllRewrites };\nexport { AbortRender };\nexport { assertNoInfiniteAbortLoop };\nimport { isUserHookError } from '../hooks/execHook.js';\nimport { assert, assertInfo, assertUsage, assertUsageUrlPathAbsolute, assertUsageUrlRedirectTarget, assertWarning, checkType, hasProp, isBrowser, joinEnglish, objectAssign, truncateString, } from './utils.js';\nimport pc from '@brillout/picocolors';\n/**\n * Abort the rendering of the current page, and redirect the user to another URL instead.\n *\n * https://vike.dev/redirect\n *\n * @param url The URL to redirect to.\n * @param statusCode By default a temporary redirection (`302`) is performed. For permanent redirections (`301`), use `config.redirects` https://vike.dev/redirects instead or, alternatively, set the `statusCode` argument to `301`.\n */\nfunction redirect(url, statusCode) {\n    const abortCaller = 'throw redirect()';\n    assertUsageUrlRedirectTarget(url, getErrPrefix(abortCaller));\n    const args = [JSON.stringify(url)];\n    if (!statusCode) {\n        statusCode = 302;\n    }\n    else {\n        if (\n        // Tree-shaking to save client-side KBs\n        !globalThis.__VIKE__IS_CLIENT ||\n            globalThis.__VIKE__IS_DEV ||\n            globalThis.__VIKE__IS_DEBUG) {\n            assertStatusCode(statusCode, [301, 302], 'redirect');\n        }\n        args.push(String(statusCode));\n    }\n    const pageContextAbort = {};\n    objectAssign(pageContextAbort, {\n        _abortCaller: abortCaller,\n        _abortCall: `redirect(${args.join(', ')})`,\n        _urlRedirect: {\n            url,\n            statusCode,\n        },\n    });\n    return AbortRender(pageContextAbort);\n}\nfunction render(urlOrStatusCode, abortReason) {\n    const args = [typeof urlOrStatusCode === 'number' ? String(urlOrStatusCode) : JSON.stringify(urlOrStatusCode)];\n    if (abortReason !== undefined)\n        args.push(truncateString(JSON.stringify(abortReason), 30));\n    const abortCaller = 'throw render()';\n    const abortCall = `render(${args.join(', ')})`;\n    return render_(urlOrStatusCode, abortReason, abortCall, abortCaller);\n}\nfunction render_(urlOrStatusCode, abortReason, abortCall, abortCaller, pageContextAddendum) {\n    const pageContextAbort = {\n        abortReason,\n        _abortCaller: abortCaller,\n        _abortCall: abortCall,\n    };\n    if (pageContextAddendum) {\n        assert(pageContextAddendum._isLegacyRenderErrorPage === true);\n        objectAssign(pageContextAbort, pageContextAddendum);\n    }\n    if (typeof urlOrStatusCode === 'string') {\n        const url = urlOrStatusCode;\n        assertUsageUrlPathAbsolute(url, getErrPrefix(abortCaller));\n        objectAssign(pageContextAbort, {\n            _urlRewrite: url,\n        });\n        return AbortRender(pageContextAbort);\n    }\n    else {\n        if (\n        // Tree-shaking to save client-side KBs\n        !globalThis.__VIKE__IS_CLIENT ||\n            globalThis.__VIKE__IS_DEV ||\n            globalThis.__VIKE__IS_DEBUG) {\n            assertStatusCode(urlOrStatusCode, [401, 403, 404, 410, 429, 500, 503], 'render');\n        }\n        const abortStatusCode = urlOrStatusCode;\n        objectAssign(pageContextAbort, {\n            abortStatusCode,\n            is404: abortStatusCode === 404,\n        });\n        return AbortRender(pageContextAbort);\n    }\n}\nfunction AbortRender(pageContextAbort) {\n    const err = new Error('AbortRender');\n    objectAssign(err, { _pageContextAbort: pageContextAbort, [stamp]: true });\n    checkType(err);\n    return err;\n}\n// TO-DO/next-major-release: remove\n/**\n * @deprecated Use `throw render()` or `throw redirect()` instead, see https://vike.dev/render'\n */\nfunction RenderErrorPage({ pageContext = {} } = {}) {\n    assertWarning(false, `${pc.cyan('throw RenderErrorPage()')} is deprecated and will be removed in the next major release. Use ${pc.cyan('throw render()')} or ${pc.cyan('throw redirect()')} instead, see https://vike.dev/render`, { onlyOnce: false });\n    let abortStatusCode = 404;\n    let abortReason = 'Page Not Found';\n    if (pageContext.is404 === false || pageContext.pageProps?.is404 === false) {\n        abortStatusCode = 500;\n        abortReason = 'Something went wrong';\n    }\n    objectAssign(pageContext, { _isLegacyRenderErrorPage: true });\n    return render_(abortStatusCode, abortReason, 'RenderErrorPage()', 'throw RenderErrorPage()', pageContext);\n}\nconst stamp = '_isAbortError';\nfunction isAbortError(thing) {\n    return typeof thing === 'object' && thing !== null && stamp in thing;\n}\nfunction isAbortPageContext(pageContext) {\n    if (!(pageContext._urlRewrite || pageContext._urlRedirect || pageContext.abortStatusCode)) {\n        return false;\n    }\n    assert(hasProp(pageContext, '_abortCall', 'string'));\n    /* Isn't needed and is missing on the client-side\n    assert(hasProp(pageContext, '_abortCaller', 'string'))\n    */\n    checkType(pageContext);\n    return true;\n}\nfunction logAbortErrorHandled(err, isProduction, pageContext) {\n    if (isProduction)\n        return;\n    const urlCurrent = pageContext._urlRewrite ?? pageContext.urlOriginal;\n    assert(urlCurrent);\n    const abortCall = err._pageContextAbort._abortCall;\n    assert(abortCall);\n    const hookLoc = isUserHookError(err);\n    let thrownBy = '';\n    if (hookLoc) {\n        thrownBy = ` by ${pc.cyan(`${hookLoc.hookName}()`)} hook defined at ${hookLoc.hookFilePath}`;\n    }\n    else {\n        // hookLoc is missing when serializing abort errors from server to client\n    }\n    assertInfo(false, `${pc.cyan(abortCall)} thrown${thrownBy} while rendering ${pc.cyan(urlCurrent)}`, {\n        onlyOnce: false,\n    });\n}\nfunction assertStatusCode(statusCode, expected, caller) {\n    assert(!globalThis.__VIKE__IS_CLIENT || globalThis.__VIKE__IS_DEV || globalThis.__VIKE__IS_DEBUG); // assert tree-shaking\n    // double check vike:pluginReplaceConstantsGlobalThis\n    if (globalThis.__VIKE__IS_CLIENT) {\n        assert(isBrowser());\n        assert(typeof globalThis.__VIKE__IS_DEV === 'boolean');\n        assert(typeof globalThis.__VIKE__IS_CLIENT === 'boolean');\n        assert(import.meta.env.SSR === false);\n        assert(import.meta.env.DEV === globalThis.__VIKE__IS_DEV);\n    }\n    else {\n        assert(!isBrowser());\n        if (import.meta.env) {\n            assert(typeof globalThis.__VIKE__IS_DEV === 'boolean');\n            assert(typeof globalThis.__VIKE__IS_CLIENT === 'boolean');\n            assert(import.meta.env.SSR === true);\n            assert(import.meta.env.DEV === globalThis.__VIKE__IS_DEV);\n        }\n        else {\n            // import.meta.env isn't defined when 'vike' is ssr.external\n        }\n    }\n    const expectedEnglish = joinEnglish(expected.map((s) => pc.bold(String(s))), 'or');\n    const statusCodeWithColor = pc.bold(String(statusCode));\n    if (statusCode === 400) {\n        assert(!expected.includes(statusCode));\n        assertWarning(false, `We recommend against using the status code ${statusCodeWithColor} passed to ${caller}()  we recommend using ${pc.bold('404')} instead, see https://github.com/vikejs/vike/issues/1008#issuecomment-3270894445`, { onlyOnce: true, showStackTrace: true });\n    }\n    else {\n        assertWarning(expected.includes(statusCode), `Unexpected status code ${statusCodeWithColor} passed to ${caller}()  we recommend using ${expectedEnglish} instead. (Or reach out at https://github.com/vikejs/vike/issues/1008 if you believe ${statusCodeWithColor} should be added.)`, { onlyOnce: true, showStackTrace: true });\n    }\n}\nfunction getPageContextFromAllRewrites(pageContextsFromRewrite) {\n    assertNoInfiniteLoop(pageContextsFromRewrite);\n    const pageContextFromAllRewrites = { _urlRewrite: null };\n    pageContextsFromRewrite.forEach((pageContextFromRewrite) => {\n        Object.assign(pageContextFromAllRewrites, pageContextFromRewrite);\n    });\n    return pageContextFromAllRewrites;\n}\nfunction assertNoInfiniteLoop(pageContextsFromRewrite) {\n    const urlRewrites = [];\n    pageContextsFromRewrite.forEach((pageContext) => {\n        const urlRewrite = pageContext._urlRewrite;\n        {\n            const idx = urlRewrites.indexOf(urlRewrite);\n            if (idx !== -1) {\n                const loop = [...urlRewrites.slice(idx), urlRewrite].map((url) => `render('${url}')`).join(' => ');\n                assertUsage(false, `Infinite loop of render() calls: ${loop}`);\n            }\n        }\n        urlRewrites.push(urlRewrite);\n    });\n}\nfunction assertNoInfiniteAbortLoop(rewriteCount, redirectCount) {\n    const abortCalls = [\n        // prettier-ignore\n        // biome-ignore format:\n        rewriteCount > 0 && pc.cyan(\"throw render('/some-url')\"),\n        redirectCount > 0 && pc.cyan(\"throw redirect('/some-url')\"),\n    ]\n        .filter(Boolean)\n        .join(' and ');\n    assertUsage(rewriteCount + redirectCount <= 7, `Maximum chain length of 7 ${abortCalls} exceeded. Did you define an infinite loop of ${abortCalls}?`);\n}\nfunction getErrPrefix(abortCaller) {\n    return `URL passed to ${pc.code(abortCaller)}`;\n}\n","export const pageContextInitIsPassedToClient = '_pageContextInitIsPassedToClient';\n","export const isServerSideError = '_isServerSideError';\n","export { preparePageContextForPublicUsageClientShared };\nexport { preparePageContextForPublicUsageClientMinimal };\nimport { objectAssign } from '../runtime-server-routing/utils.js';\nimport { assertPropertyGetters, preparePageContextForPublicUsage, } from '../../shared/preparePageContextForPublicUsage.js';\nfunction preparePageContextForPublicUsageClientShared(pageContext) {\n    // TO-DO/soon/proxy: use proxy\n    const Page = pageContext.config?.Page ||\n        // TO-DO/next-major-release: remove\n        pageContext.exports?.Page;\n    objectAssign(pageContext, { Page });\n    // TO-DO/next-major-release: after we remove supportVueReactiviy() we can call this later inside the agnostic preparePageContextForPublicUsage()\n    assertPropertyGetters(pageContext);\n    // TO-DO/next-major-release: remove\n    // - Requires https://github.com/vikejs/vike-vue/issues/198\n    // - Last time I tried to remove it (https://github.com/vikejs/vike/commit/705fd23598d9d69bf46a52c8550216cd7117ce71) the tests were failing as expected: only the Vue integrations that used shallowReactive() failed.\n    supportVueReactiviy(pageContext);\n    return preparePageContextForPublicUsageClientMinimal(pageContext);\n}\nfunction preparePageContextForPublicUsageClientMinimal(pageContext) {\n    const pageContextPublic = preparePageContextForPublicUsage(pageContext);\n    return pageContextPublic;\n}\n// With Vue + Client Routing, the `pageContext` is made reactive:\n// ```js\n// import { reactive } from 'vue'\n// // See /examples/vue-full/renderer/createVueApp.ts\n// const pageContextReactive = reactive(pageContext)\n// ```\nfunction supportVueReactiviy(pageContext) {\n    resolveGetters(pageContext);\n}\n// Remove property descriptor getters because they break Vue's reactivity.\n// E.g. resolve the `pageContext.urlPathname` getter.\nfunction resolveGetters(pageContext) {\n    Object.entries(pageContext).forEach(([key, val]) => {\n        delete pageContext[key];\n        pageContext[key] = val;\n    });\n}\n","export { preparePageContextForPublicUsageClient };\nimport { preparePageContextForPublicUsageClientShared } from '../shared/preparePageContextForPublicUsageClientShared.js';\nfunction preparePageContextForPublicUsageClient(pageContext) {\n    return preparePageContextForPublicUsageClientShared(pageContext);\n}\n","export { getPageContextFromHooks_isHydration };\nexport { getPageContextFromHooks_serialized };\nexport { getPageContextFromServerHooks };\nexport { getPageContextFromClientHooks };\nexport { setPageContextInitIsPassedToClient };\nexport { execHookClient };\nimport { assert, assertUsage, hasProp, objectAssign, getProjectError, redirectHard, isObject, getGlobalObject, } from './utils.js';\nimport { parse } from '@brillout/json-serializer/parse';\nimport { getPageContextSerializedInHtml } from '../shared/getJsonSerializedInHtml.js';\nimport { analyzePageServerSide } from '../../shared/getPageFiles/analyzePageServerSide.js';\nimport { removeBuiltInOverrides } from './getPageContext/removeBuiltInOverrides.js';\nimport { getPageContextRequestUrl } from '../../shared/getPageContextRequestUrl.js';\nimport { getPageConfig } from '../../shared/page-configs/helpers.js';\nimport { getConfigValueRuntime } from '../../shared/page-configs/getConfigValueRuntime.js';\nimport { assertOnBeforeRenderHookReturn } from '../../shared/assertOnBeforeRenderHookReturn.js';\nimport { execHookGuard } from '../../shared/route/execHookGuard.js';\nimport { AbortRender, isAbortPageContext } from '../../shared/route/abort.js';\nimport { pageContextInitIsPassedToClient } from '../../shared/misc/pageContextInitIsPassedToClient.js';\nimport { isServerSideError } from '../../shared/misc/isServerSideError.js';\nimport { execHook } from '../../shared/hooks/execHook.js';\nimport { preparePageContextForPublicUsageClient, } from './preparePageContextForPublicUsageClient.js';\nconst globalObject = getGlobalObject('runtime-client-routing/getPageContextFromHooks.ts', {});\n// TO-DO/eventually: rename\nfunction getPageContextFromHooks_serialized() {\n    const pageContextSerialized = getPageContextSerializedInHtml();\n    processPageContextFromServer(pageContextSerialized);\n    objectAssign(pageContextSerialized, {\n        _hasPageContextFromServer: true,\n    });\n    return pageContextSerialized;\n}\n// TO-DO/eventually: rename\nasync function getPageContextFromHooks_isHydration(pageContext) {\n    for (const hookName of ['data', 'onBeforeRender']) {\n        // TO-DO/soon/cumulative-hooks: filter & execute all client-only hooks\n        // - The client-side needs to know what hooks are client-only\n        //   - Possible implementation: new computed prop `clientOnlyHooks: string[]` (list of hook ids) and add `hookId` to serialized config values\n        if (hookClientOnlyExists(hookName, pageContext)) {\n            await execHookDataLike(hookName, pageContext);\n        }\n    }\n    return pageContext;\n}\nasync function getPageContextFromServerHooks(pageContext, isErrorPage) {\n    const pageContextFromServerHooks = {\n        _hasPageContextFromServer: false,\n    };\n    // If pageContextInit has some client data or if one of the hooks guard(), data() or onBeforeRender() is server-side\n    // only, then we need to fetch pageContext from the server.\n    // We do it before executing any client-side hook, because it contains pageContextInit which may be needed for guard() / data() / onBeforeRender(), for example pageContextInit.user is crucial for guard()\n    if (\n    // For the error page, we cannot fetch pageContext from the server because the pageContext JSON request is based on the URL\n    !isErrorPage &&\n        // true if pageContextInit has some client data or at least one of the data() and onBeforeRender() hooks is server-side only:\n        (await hasPageContextServer(pageContext))) {\n        const res = await fetchPageContextFromServer(pageContext);\n        if ('is404ServerSideRouted' in res)\n            return { is404ServerSideRouted: true };\n        const { pageContextFromServer } = res;\n        pageContextFromServerHooks._hasPageContextFromServer = true;\n        // Already handled\n        assert(!(isServerSideError in pageContextFromServer));\n        assert(!('serverSideError' in pageContextFromServer));\n        objectAssign(pageContextFromServerHooks, pageContextFromServer);\n    }\n    // We cannot return the whole pageContext because this function is used for prefetching `pageContext` (which requires a partial pageContext to be merged with the future pageContext created upon rendering the page in the future).\n    return { pageContextFromServerHooks };\n}\nasync function getPageContextFromClientHooks(pageContext, isErrorPage) {\n    let dataHookExecuted = false;\n    // At this point, we need to call the client-side guard(), data() and onBeforeRender() hooks, if they exist on client\n    // env. However if we have fetched pageContext from the server, some of them might have run already on the\n    // server-side, so we run only the client-only ones in this case.\n    // Note: for the error page, we also execute the client-side data() and onBeforeRender() hooks, but maybe we\n    // shouldn't? The server-side does it as well (but maybe it shouldn't).\n    for (const hookName of ['guard', 'data', 'onBeforeRender']) {\n        if (hookName === 'guard') {\n            if (!isErrorPage &&\n                // We don't need to call guard() on the client-side if we fetch pageContext from the server side. (Because the `${url}.pageContext.json` HTTP request will already trigger the routing and guard() hook on the server-side.)\n                !pageContext._hasPageContextFromServer) {\n                // Should we really call the guard() hook on the client-side? Shouldn't we make the guard() hook a server-side\n                // only hook? Or maybe make its env configurable like data() and onBeforeRender()?\n                await execHookGuard(pageContext, (pageContext) => preparePageContextForPublicUsageClient(pageContext));\n            }\n        }\n        else {\n            // TO-DO/soon/cumulative-hooks: filter & execute all client-only hooks (see other TO-DO/soon/cumulative-hooks entries)\n            if (hookClientOnlyExists(hookName, pageContext) || !pageContext._hasPageContextFromServer) {\n                if (hookName === 'data')\n                    dataHookExecuted = true;\n                // This won't do anything if no hook has been defined or if the hook's env.client is false.\n                await execHookDataLike(hookName, pageContext);\n            }\n        }\n    }\n    // Execute +onData\n    const dataHookEnv = getHookEnv('data', pageContext);\n    if ((dataHookExecuted && dataHookEnv.client) || (pageContext._hasPageContextFromServer && dataHookEnv.server)) {\n        await execHookClient('onData', pageContext);\n    }\n    const pageContextFromClientHooks = pageContext;\n    return pageContextFromClientHooks;\n}\nasync function execHookClient(hookName, pageContext) {\n    return await execHook(hookName, pageContext, (p) => preparePageContextForPublicUsageClient(p));\n}\nasync function execHookDataLike(hookName, pageContext) {\n    let pageContextFromHook;\n    if (hookName === 'data') {\n        pageContextFromHook = await execHookData(pageContext);\n    }\n    else {\n        pageContextFromHook = await execHookOnBeforeRender(pageContext);\n    }\n    Object.assign(pageContext, pageContextFromHook);\n}\nasync function execHookData(pageContext) {\n    const res = await execHookClient('data', pageContext);\n    const hook = res[0]; // TO-DO/soon/cumulative-hooks: support cumulative\n    if (!hook)\n        return;\n    const { hookReturn } = hook;\n    const pageContextAddendum = { data: hookReturn };\n    return pageContextAddendum;\n}\nasync function execHookOnBeforeRender(pageContext) {\n    const res = await execHookClient('onBeforeRender', pageContext);\n    const hook = res[0]; // TO-DO/soon/cumulative-hooks: support cumulative\n    if (!hook)\n        return;\n    const { hookReturn, hookFilePath } = hook;\n    const pageContextFromHook = {};\n    assertOnBeforeRenderHookReturn(hookReturn, hookFilePath);\n    // Note: hookReturn looks like { pageContext: { ... } }\n    const pageContextFromOnBeforeRender = hookReturn?.pageContext;\n    if (pageContextFromOnBeforeRender) {\n        objectAssign(pageContextFromHook, pageContextFromOnBeforeRender);\n    }\n    return pageContextFromHook;\n}\n// Workaround for the fact that the client-side cannot known whether a pageContext JSON request is needed in order to fetch pageContextInit data passed to the client.\n//  - The workaround is reliable as long as the user sets additional pageContextInit to undefined instead of not defining the property:\n//    ```diff\n//    - // Breaks the workaround:\n//    - const pageContextInit = { urlOriginal: req.url }\n//    - if (user) pageContextInit.user = user\n//    + // Makes the workaround reliable:\n//    + const pageContextInit = { urlOriginal: req.url, user }\n//    ```\n// - We can show a warning to users when the pageContextInit keys aren't always the same. (We didn't implement the waning yet because it would require a new doc page https://vike.dev/pageContextInit#avoid-conditional-properties\n// - Workaround cannot be made completely reliable because the workaround assumes that passToClient is always the same, but the user may set a different passToClient value for another page\n// - Alternatively, we could define a new config `alwaysFetchPageContextFromServer: boolean`\nfunction setPageContextInitIsPassedToClient(pageContext) {\n    if (pageContext[pageContextInitIsPassedToClient]) {\n        globalObject.pageContextInitIsPassedToClient = true;\n    }\n}\n// TO-DO/next-major-release: make it sync\nasync function hasPageContextServer(pageContext) {\n    if (isOldDesign(pageContext)) {\n        const { hasOnBeforeRenderServerSideOnlyHook } = await analyzePageServerSide(pageContext._pageFilesAll, pageContext.pageId);\n        // data() hooks didn't exist in the V0.4 design\n        return hasOnBeforeRenderServerSideOnlyHook;\n    }\n    return !!globalObject.pageContextInitIsPassedToClient || hasServerOnlyHook(pageContext);\n}\nfunction hasServerOnlyHook(pageContext) {\n    if (isOldDesign(pageContext))\n        return false;\n    const pageConfig = getPageConfig(pageContext.pageId, pageContext._globalContext._pageConfigs);\n    const val = getConfigValueRuntime(pageConfig, `hasServerOnlyHook`)?.value;\n    assert(val === true || val === false);\n    return val;\n}\nfunction hookClientOnlyExists(hookName, pageContext) {\n    const hookEnv = getHookEnv(hookName, pageContext);\n    return !!hookEnv.client && !hookEnv.server;\n}\nfunction getHookEnv(hookName, pageContext) {\n    if (isOldDesign(pageContext)) {\n        // Client-only onBeforeRender() or data() hooks were never supported for the V0.4 design\n        return { client: false, server: true };\n    }\n    const pageConfig = getPageConfig(pageContext.pageId, pageContext._globalContext._pageConfigs);\n    // No runtime validation to save client-side KBs\n    const hookEnv = (getConfigValueRuntime(pageConfig, `${hookName}Env`)?.value ?? {});\n    return hookEnv;\n}\nasync function fetchPageContextFromServer(pageContext) {\n    let pageContextUrl = getPageContextRequestUrl(pageContext._urlRewrite ?? pageContext.urlOriginal);\n    /* TO-DO/soon/once: pass & use previousUrl\n    pageContextUrl = modifyUrlSameOrigin(pageContextUrl, { search: { _vike: JSON.stringify({ previousUrl: pageContext.previousPageContext.urlOriginal }) } })\n    */\n    const response = await fetch(pageContextUrl);\n    {\n        const contentType = response.headers.get('content-type');\n        const contentTypeCorrect = 'application/json';\n        const isCorrect = contentType && contentType.includes(contentTypeCorrect);\n        // Static hosts + page doesn't exist\n        if (!isCorrect && response.status === 404) {\n            redirectHard(pageContext.urlOriginal);\n            return { is404ServerSideRouted: true };\n        }\n        assertUsage(isCorrect, `Wrong Content-Type for ${pageContextUrl}: it should be ${contentTypeCorrect} but it's ${contentType} instead. Make sure to properly use pageContext.httpResponse.headers, see https://vike.dev/renderPage`);\n    }\n    const responseText = await response.text();\n    const pageContextFromServer = parse(responseText);\n    assert(isObject(pageContextFromServer));\n    if (isAbortPageContext(pageContextFromServer)) {\n        throw AbortRender(pageContextFromServer);\n    }\n    // Is there a reason for having two different properties? Can't we use only one property? I guess/think the isServerSideError property was an attempt (a bad idea really) for rendering the error page even though an error occurred on the server-side (which is a bad idea because the added complexity is non-negligible while the added value is minuscule since the error page usually doesn't have any (meaningful / server-side) hooks).\n    if ('serverSideError' in pageContextFromServer || isServerSideError in pageContextFromServer) {\n        throw getProjectError(`pageContext couldn't be fetched because an error occurred on the server-side`);\n    }\n    processPageContextFromServer(pageContextFromServer);\n    return { pageContextFromServer };\n}\nfunction processPageContextFromServer(pageContext) {\n    assertUsage(!('urlOriginal' in pageContext), \"Adding 'urlOriginal' to passToClient is forbidden\");\n    assert(hasProp(pageContext, 'pageId', 'string'));\n    removeBuiltInOverrides(pageContext);\n}\n// TO-DO/next-major-release: remove\nfunction isOldDesign(pageContext) {\n    return pageContext._globalContext._pageConfigs.length === 0;\n}\n","export const htmlElementId_pageContext = 'vike_pageContext';\nexport const htmlElementId_globalContext = 'vike_globalContext';\n","export { analyzePageServerSide };\nimport { assert } from '../utils.js';\nimport { getPageFilesServerSide } from './getAllPageIdFiles.js';\nasync function analyzePageServerSide(pageFilesAll, pageId) {\n    const pageFilesServerSide = getPageFilesServerSide(pageFilesAll, pageId);\n    const pageFilesServerSideOnly = pageFilesServerSide.filter((p) => p.fileType === '.page.server');\n    await Promise.all(pageFilesServerSideOnly.map(async (p) => {\n        // In production, `exportNames` are preload\n        if (p.exportNames) {\n            return;\n        }\n        assert(p.loadExportNames, pageId);\n        await p.loadExportNames();\n    }));\n    const hasOnBeforeRenderServerSideOnlyHook = pageFilesServerSideOnly.some(({ exportNames }) => {\n        assert(exportNames);\n        return exportNames.includes('onBeforeRender');\n    });\n    return { hasOnBeforeRenderServerSideOnlyHook };\n}\n","export { getPageContextUrlComputed };\n// =====================\n// File determining the URL logic.\n// URLs need to be computed, because the user can modify the URL e.g. with onBeforeRoute() for i18n.\n// =====================\nimport { objectDefineProperty } from '../utils/objectDefineProperty.js';\nimport { assertPropertyGetters } from './preparePageContextForPublicUsage.js';\nimport { assert, parseUrl, assertWarning, isBrowser, changeEnumerable } from './utils.js';\nfunction getPageContextUrlComputed(pageContext) {\n    assert(typeof pageContext.urlOriginal === 'string');\n    assertPropertyGetters(pageContext);\n    const pageContextUrlComputed = {};\n    objectDefineProperty(pageContextUrlComputed, 'urlPathname', {\n        get: urlPathnameGetter,\n        enumerable: true,\n        configurable: true,\n    });\n    objectDefineProperty(pageContextUrlComputed, 'url', {\n        get: urlGetter,\n        enumerable: false,\n        configurable: true,\n    });\n    objectDefineProperty(pageContextUrlComputed, 'urlParsed', {\n        get: urlParsedGetter,\n        enumerable: true,\n        configurable: true,\n    });\n    return pageContextUrlComputed;\n}\nfunction getUrlParsed(pageContext) {\n    // Example of i18n app using `throw render()`:\n    //  1. User goes to '/fr-FR/admin'.\n    //  2. The first onBeforeRoute() call accesses pageContext.urlPathname (its value is '/fr-FR/admin': the pathname of pageContext.urlOriginal, since both pageContext.urlLogical and pageContext._urlRewrite are undefined) and sets pageContext.urlLogical to '/admin'.\n    //  3. A guard() hooks accesses pageContext.urlPathname (its value is '/admin': the pathname of pageContext.urlLogical) and calls `throw render('/fr-FR/login')`\n    //  4. Vike create a new pageContext object (pageContext.urlLogical is erased) and sets pageContext._urlRewrite to '/fr-FR/login'. (While pageContext.urlOriginal is still '/fr-FR/admin'.)\n    //  5. The second onBeforeRoute() call accesses pageContext.urlPathname (its value is '/fr-FR/login': the pathname of pageContext._urlRewrite, since pageContext.urlLogical is undefined) and sets pageContext.urlLogical to '/login'.\n    //  6. The value of pageContext.urlPathname is now '/login': the pathname of `pageContext.urlLogical`. (While pageContext.urlOriginal is still '/fr-FR/admin'.)\n    // Reproduction: https://github.com/vikejs/vike/discussions/1436#discussioncomment-8142023\n    // Determine logical URL\n    const assertUrlResolved = (src) => assert(typeof urlResolved === 'string', \n    // TO-DO/eventually: remove debug logs, see:\n    // - https://github.com/vikejs/vike/issues/2138#issuecomment-2631713411\n    // - https://github.com/vikejs/vike/commit/5c7810f3080ab62536950f26e019bb2a3a517082\n    { src, urlResolved });\n    let urlResolved;\n    let isBaseToBeRemoved;\n    if (pageContext.urlLogical) {\n        // Set by onBeforeRoute()\n        urlResolved = pageContext.urlLogical;\n        isBaseToBeRemoved = false;\n        assertUrlResolved(1);\n    }\n    else if (pageContext._urlRewrite) {\n        // Set by `throw render()`\n        urlResolved = pageContext._urlRewrite;\n        isBaseToBeRemoved = false;\n        assertUrlResolved(2);\n    }\n    else {\n        // Set by renderPage()\n        urlResolved = pageContext.urlOriginal;\n        isBaseToBeRemoved = true;\n        assertUrlResolved(3);\n    }\n    assertUrlResolved(4);\n    // Remove .pageContext.json\n    let urlHandler = pageContext._urlHandler;\n    if (!urlHandler)\n        urlHandler = (url) => url;\n    urlResolved = urlHandler(urlResolved);\n    // Remove Base URL.\n    // - We assume there isn't any Base URL to the URLs set by the user at `throw render()` and onBeforeRoute()\n    //   - This makes sense because the Base URL is merely a setting: ideally the user should write code that doesn't know anything about it (so that the user can remove/add/change Base URL without having to modify any code).\n    // - pageContext.urlOriginal is the URL of the HTTP request and thus contains the Base URL.\n    const baseServer = !isBaseToBeRemoved ? '/' : pageContext._baseServer;\n    // Parse URL\n    return parseUrl(urlResolved, baseServer);\n}\nfunction urlPathnameGetter() {\n    const { pathname } = getUrlParsed(this);\n    const urlPathname = pathname;\n    assert(urlPathname.startsWith('/'));\n    return urlPathname;\n}\nfunction urlGetter() {\n    // TO-DO/next-major-release: remove\n    assertWarning(false, '`pageContext.url` is outdated. Use `pageContext.urlPathname`, `pageContext.urlParsed`, or `pageContext.urlOriginal` instead. (See https://vike.dev/migration/0.4.23 for more information.)', { onlyOnce: true, showStackTrace: true });\n    return urlPathnameGetter.call(this);\n}\nfunction urlParsedGetter() {\n    const { \n    // remove isBaseMissing as it isn't part of UrlPublic\n    isBaseMissing: _, ...urlParsed } = getUrlParsed(this);\n    const hashIsAvailable = isBrowser();\n    const warnHashNotAvailable = (prop) => {\n        assertWarning(hashIsAvailable, `pageContext.urlParsed.${prop} isn't available on the server-side (HTTP requests don't include the URL hash)`, { onlyOnce: true, showStackTrace: true });\n    };\n    const urlParsedEnhanced = {\n        ...urlParsed,\n        get hash() {\n            warnHashNotAvailable('hash');\n            return urlParsed.hash;\n        },\n        get hashOriginal() {\n            warnHashNotAvailable('hashOriginal');\n            return urlParsed.hashOriginal;\n        },\n        // TO-DO/next-major-release: remove\n        get hashString() {\n            assertWarning(false, 'pageContext.urlParsed.hashString has been renamed to pageContext.urlParsed.hashOriginal', {\n                onlyOnce: true,\n                showStackTrace: true,\n            });\n            warnHashNotAvailable('hashString');\n            return urlParsed.hashOriginal;\n        },\n        // TO-DO/next-major-release: remove\n        get searchString() {\n            assertWarning(false, 'pageContext.urlParsed.searchString has been renamed to pageContext.urlParsed.searchOriginal', { onlyOnce: true, showStackTrace: true });\n            return urlParsed.searchOriginal;\n        },\n    };\n    changeEnumerable(urlParsedEnhanced, 'hashString', false);\n    changeEnumerable(urlParsedEnhanced, 'searchString', false);\n    if (!hashIsAvailable) {\n        changeEnumerable(urlParsedEnhanced, 'hash', false);\n        changeEnumerable(urlParsedEnhanced, 'hashOriginal', false);\n    }\n    return urlParsedEnhanced;\n}\n","// TO-DO/next-major-release: remove this\nexport { assertDefaultExports };\nexport { assertExportValues };\nexport { forbiddenDefaultExports };\nimport { assert, assertUsage } from '../utils.js';\nconst enforceTrue = ['clientRouting'];\nfunction assertExportValues(pageFile) {\n    enforceTrue.forEach((exportName) => {\n        assert(pageFile.fileExports);\n        if (!(exportName in pageFile.fileExports))\n            return;\n        const explainer = `The value of \\`${exportName}\\` is only allowed to be \\`true\\`.`;\n        assertUsage(pageFile.fileExports[exportName] !== false, `${pageFile.filePath} has \\`export { ${exportName} }\\` with the value \\`false\\` which is prohibited: remove \\`export { ${exportName} }\\` instead. (${explainer})`);\n        assertUsage(pageFile.fileExports[exportName] === true, `${pageFile.filePath} has \\`export { ${exportName} }\\` with a forbidden value. ${explainer}`);\n    });\n}\n// Forbid exports such as `export default { render }`, because only `export { render }` can be statically analyzed by `es-module-lexer`.\nconst forbiddenDefaultExports = ['render', 'clientRouting', 'prerender', 'doNotPrerender'];\nfunction assertDefaultExports(defaultExportName, filePath) {\n    assertUsage(!forbiddenDefaultExports.includes(defaultExportName), `${filePath} has \\`export default { ${defaultExportName} }\\` which is prohibited, use \\`export { ${defaultExportName} }\\` instead.`);\n}\n","export { determinePageIdOld };\nimport { slice, assert } from './utils.js';\n// TO-DO/next-major-release: remove\nfunction determinePageIdOld(filePath) {\n    const pageSuffix = '.page.';\n    const pageId = slice(filePath.split(pageSuffix), 0, -1).join(pageSuffix);\n    assert(!pageId.includes('\\\\'));\n    return pageId;\n}\n","export { getErrorPageId };\nexport { isErrorPageId };\nexport { isErrorPage };\n// TO-DO/next-major-release: consider loading this file only for Client Routing\nimport { assert, assertUsage, unique } from './utils.js';\nfunction getErrorPageId(pageFilesAll, pageConfigs) {\n    if (pageConfigs.length > 0) {\n        const errorPageConfigs = pageConfigs.filter((p) => p.isErrorPage);\n        if (errorPageConfigs.length === 0)\n            return null;\n        assertUsage(errorPageConfigs.length === 1, 'Only one error page can be defined');\n        return errorPageConfigs[0].pageId;\n    }\n    // TO-DO/next-major-release: remove\n    const errorPageIds = unique(pageFilesAll.map(({ pageId }) => pageId).filter((pageId) => isErrorPageId(pageId, false)));\n    assertUsage(errorPageIds.length <= 1, `Only one _error.page.js is allowed, but found several: ${errorPageIds.join(' ')}`);\n    if (errorPageIds.length > 0) {\n        const errorPageId = errorPageIds[0];\n        assert(errorPageId);\n        return errorPageId;\n    }\n    return null;\n}\n// TO-DO/next-major-release: remove\nfunction isErrorPageId(pageId, _isV1Design) {\n    assert(!pageId.includes('\\\\'));\n    return pageId.includes('/_error');\n}\nfunction isErrorPage(pageId, pageConfigs) {\n    if (pageConfigs.length > 0) {\n        const pageConfig = pageConfigs.find((p) => p.pageId === pageId);\n        assert(pageConfig);\n        return !!pageConfig.isErrorPage;\n    }\n    else {\n        return isErrorPageId(pageId, false);\n    }\n}\n","// TO-DO/next-major-release: remove\nexport { getPageFileObject };\nimport { determinePageIdOld } from '../determinePageIdOld.js';\nimport { isErrorPageId } from '../error-page.js';\nimport { assert, slice } from '../utils.js';\nimport { determineFileType } from './fileTypes.js';\nfunction getPageFileObject(filePath) {\n    const isRelevant = (pageId) => pageFile.pageId === pageId ||\n        (pageFile.isDefaultPageFile &&\n            (isRendererFilePath(pageFile.filePath) || isAncestorDefaultPage(pageId, pageFile.filePath)));\n    const fileType = determineFileType(filePath);\n    const isEnv = (env) => {\n        assert(fileType !== '.page.route'); // We can't determine `.page.route.js`\n        if (env === 'CLIENT_ONLY') {\n            return fileType === '.page.client' || fileType === '.css';\n        }\n        if (env === 'SERVER_ONLY') {\n            return fileType === '.page.server';\n        }\n        if (env === 'CLIENT_AND_SERVER') {\n            return fileType === '.page';\n        }\n        assert(false);\n    };\n    const pageFile = {\n        filePath,\n        fileType,\n        isEnv,\n        isRelevant,\n        isDefaultPageFile: isDefaultFilePath(filePath),\n        isRendererPageFile: fileType !== '.css' && isDefaultFilePath(filePath) && isRendererFilePath(filePath),\n        isErrorPageFile: isErrorPageId(filePath, false),\n        pageId: determinePageIdOld(filePath),\n    };\n    return pageFile;\n}\nfunction isDefaultFilePath(filePath) {\n    if (isErrorPageId(filePath, false)) {\n        return false;\n    }\n    return filePath.includes('/_default');\n}\nfunction isRendererFilePath(filePath) {\n    return filePath.includes('/renderer/');\n}\nfunction isAncestorDefaultPage(pageId, defaultPageFilePath) {\n    assert(!pageId.endsWith('/'));\n    assert(!defaultPageFilePath.endsWith('/'));\n    assert(isDefaultFilePath(defaultPageFilePath));\n    const defaultPageDir = slice(defaultPageFilePath.split('/'), 0, -1)\n        .filter((filePathSegment) => filePathSegment !== '_default')\n        .join('/');\n    return pageId.startsWith(defaultPageDir);\n}\n","// TO-DO/next-major-release: remove\nexport { fileTypes };\nexport { isValidFileType };\nexport { determineFileType };\nimport { assert } from '../utils.js';\nimport { isScriptFile } from '../../utils/isScriptFile.js';\nconst fileTypes = [\n    '.page',\n    '.page.server',\n    '.page.route',\n    '.page.client',\n    // New type `.page.css`/`.page.server.css`/`.page.client.css` for `extensions[number].pageFileDist`.\n    //  - Extensions using `pageFileDist` are expected to use a bundler that generates a `.css` colocated next to the original `.page.js` file (e.g. `/renderer/_default.page.server.css` for `/renderer/_default.page.server.js`.\n    //  - Since these `.page.css` files Bundlers We can therefore expect that there isn't any `.page.server.sass`/...\n    '.css',\n];\nfunction isValidFileType(filePath) {\n    return ['.js', '.mjs', '.cjs', '.css'].some((ext) => filePath.endsWith(ext));\n}\nfunction determineFileType(filePath) {\n    {\n        const isCSS = filePath.endsWith('.css');\n        if (isCSS) {\n            /* This assert() is skipped to reduce client-side bundle size\n            assert(isImportPathNpmPackage(filePath), filePath) // `.css` page files are only supported for npm packages\n            */\n            return '.css';\n        }\n    }\n    assert(isScriptFile(filePath), filePath);\n    const fileName = filePath.split('/').slice(-1)[0];\n    const parts = fileName.split('.');\n    const suffix1 = parts.slice(-3)[0];\n    const suffix2 = parts.slice(-2)[0];\n    if (suffix2 === 'page') {\n        return '.page';\n    }\n    assert(suffix1 === 'page', filePath);\n    if (suffix2 === 'server') {\n        return '.page.server';\n    }\n    if (suffix2 === 'client') {\n        return '.page.client';\n    }\n    if (suffix2 === 'route') {\n        return '.page.route';\n    }\n    assert(false, filePath);\n}\n","export { assertPlusFileExport };\nimport { assert, assertUsage, assertWarning } from '../utils.js';\nimport pc from '@brillout/picocolors';\nconst SIDE_EXPORTS_TOLERATE = [\n    // vite-plugin-solid adds `export { $$registrations }`\n    '$$registrations',\n    // @vitejs/plugin-vue adds `export { _rerender_only }`\n    '_rerender_only',\n];\n// Tolerate `export { frontmatter }` in .mdx files\nconst SIDE_EXPORTS_DO_NOT_CHECK = ['.md', '.mdx'];\nfunction assertPlusFileExport(fileExports, filePathToShowToUser, configName) {\n    const exportNames = Object.keys(fileExports);\n    const isValid = (exportName) => exportName === 'default' || exportName === configName;\n    // Error upon missing/ambiguous export\n    const exportNamesValid = exportNames.filter(isValid);\n    const exportDefault = pc.code('export default');\n    const exportNamed = pc.code(`export { ${configName} }`);\n    if (exportNamesValid.length === 0) {\n        assertUsage(false, `${filePathToShowToUser} should define ${exportNamed} or ${exportDefault}`);\n    }\n    if (exportNamesValid.length === 2) {\n        assertUsage(false, `${filePathToShowToUser} is ambiguous: remove ${exportDefault} or ${exportNamed}`);\n    }\n    assert(exportNamesValid.length === 1);\n    // Warn upon side exports\n    const exportNamesInvalid = exportNames\n        .filter((e) => !isValid(e))\n        .filter((exportName) => !SIDE_EXPORTS_TOLERATE.includes(exportName));\n    if (!SIDE_EXPORTS_DO_NOT_CHECK.some((ext) => filePathToShowToUser.endsWith(ext))) {\n        exportNamesInvalid.forEach((exportInvalid) => {\n            assertWarning(false, `${filePathToShowToUser} unexpected ${pc.cyan(`export { ${exportInvalid} }`)}, see https://vike.dev/no-side-exports`, {\n                onlyOnce: true,\n            });\n        });\n    }\n}\n","export { parsePageConfigsSerialized };\nexport { parseConfigValuesSerialized };\nimport { assert, assertUsage, isCallable } from '../../utils.js';\nimport { getConfigDefinedAt } from '../getConfigDefinedAt.js';\nimport { parseTransform } from '@brillout/json-serializer/parse';\nimport { assertPlusFileExport } from '../assertPlusFileExport.js';\nfunction parsePageConfigsSerialized(pageConfigsSerialized, pageConfigGlobalSerialized) {\n    // pageConfigs\n    const pageConfigs = pageConfigsSerialized.map((pageConfigSerialized) => {\n        const configValues = parseConfigValuesSerialized(pageConfigSerialized.configValuesSerialized);\n        assertRouteConfigValue(configValues);\n        const pageConfig = { ...pageConfigSerialized, configValues };\n        return pageConfig;\n    });\n    // pageConfigsGlobal\n    const pageConfigGlobal = { configValues: {} };\n    {\n        const configValues = parseConfigValuesSerialized(pageConfigGlobalSerialized.configValuesSerialized);\n        Object.assign(pageConfigGlobal.configValues, configValues);\n    }\n    return { pageConfigs, pageConfigGlobal };\n}\nfunction assertRouteConfigValue(configValues) {\n    const configName = 'route';\n    const configValue = configValues[configName];\n    if (!configValue)\n        return;\n    const { value, definedAtData } = configValue;\n    const configValueType = typeof value;\n    assert(definedAtData);\n    const configDefinedAt = getConfigDefinedAt('Config', configName, definedAtData);\n    assertUsage(configValueType === 'string' || isCallable(value), `${configDefinedAt} has an invalid type '${configValueType}': it should be a string or a function instead, see https://vike.dev/route`);\n    /* We don't use assertRouteString() in order to avoid unnecessarily bloating the client-side bundle when using Server Routing:\n    * - When using Server Routing, this file is loaded => loading assertRouteString() would bloat the client bundle.\n    * - assertRouteString() is already called on the server-side\n    * - When using Server Routing, client-side validation is superfluous as Route Strings only need to be validated on the server-side\n   if (typeof configValue === 'string') {\n     assertRouteString(configValue, `${configElement.configDefinedAt} defines an`)\n   }\n   */\n}\nfunction parseConfigValuesSerialized(configValuesSerialized) {\n    const configValues = {};\n    Object.entries(configValuesSerialized).forEach(([configName, configValueSeriliazed]) => {\n        let configValue;\n        if (configValueSeriliazed.type === 'cumulative') {\n            const { valueSerialized, ...common } = configValueSeriliazed;\n            const value = valueSerialized.map((valueSerializedElement, i) => {\n                const { value, sideExports } = parseValueSerialized(valueSerializedElement, configName, () => {\n                    const definedAtFile = configValueSeriliazed.definedAtData[i];\n                    assert(definedAtFile);\n                    return definedAtFile;\n                });\n                addSideExports(sideExports);\n                return value;\n            });\n            configValue = { value, ...common };\n        }\n        else {\n            const { valueSerialized, ...common } = configValueSeriliazed;\n            const { value, sideExports } = parseValueSerialized(valueSerialized, configName, () => {\n                assert(configValueSeriliazed.type !== 'computed');\n                const { definedAtData } = configValueSeriliazed;\n                const definedAtFile = Array.isArray(definedAtData) ? definedAtData[0] : definedAtData;\n                return definedAtFile;\n            });\n            addSideExports(sideExports);\n            configValue = { value, ...common };\n        }\n        configValues[configName] = configValue;\n    });\n    return configValues;\n    function addSideExports(sideExports) {\n        sideExports.forEach((sideExport) => {\n            const { configName, configValue } = sideExport;\n            if (!configValues[configName]) {\n                configValues[configName] = configValue;\n            }\n            else {\n                // Side-exports have lower precedence.\n                // We can't avoid side-export conflicts upstream. (We cannot know about side-exports at build-time.)\n            }\n        });\n    }\n}\nfunction parseValueSerialized(valueSerialized, configName, getDefinedAtFile) {\n    if (valueSerialized.type === 'js-serialized') {\n        let { value } = valueSerialized;\n        value = parseTransform(value);\n        return { value, sideExports: [] };\n    }\n    if (valueSerialized.type === 'pointer-import') {\n        const { value } = valueSerialized;\n        return { value, sideExports: [] };\n    }\n    if (valueSerialized.type === 'plus-file') {\n        const definedAtFile = getDefinedAtFile();\n        const { exportValues } = valueSerialized;\n        assert(!definedAtFile.definedBy);\n        assertPlusFileExport(exportValues, definedAtFile.filePathToShowToUser, configName);\n        let value;\n        let valueWasFound = false;\n        const sideExports = [];\n        Object.entries(exportValues).forEach(([exportName, exportValue]) => {\n            const isSideExport = exportName !== 'default' && exportName !== configName;\n            if (!isSideExport) {\n                value = exportValue;\n                // Already asserted by assertPlusFileExport() call above.\n                assert(!valueWasFound);\n                valueWasFound = true;\n            }\n            else {\n                sideExports.push({\n                    configName: exportName,\n                    configValue: {\n                        type: 'standard', // We don't support side exports for cumulative values. We could support it but it isn't trivial.\n                        value: exportValue,\n                        definedAtData: {\n                            filePathToShowToUser: definedAtFile.filePathToShowToUser,\n                            fileExportPathToShowToUser: [exportName],\n                        },\n                    },\n                });\n            }\n        });\n        // Already asserted by assertPlusFileExport() call above.\n        assert(valueWasFound);\n        return { value, sideExports };\n    }\n    assert(false);\n}\n/* [NULL_HANDLING] Do we really need this?\nfunction assertIsNotNull(configValue: unknown, configName: string, filePathToShowToUser: string) {\n  assert(!filePathToShowToUser.includes('+config.'))\n  // Re-use this for:\n  //  - upcoming config.requestPageContextOnNavigation\n  //  - for cumulative values in the future: we don't need this for now because, currently, cumulative values are never imported.\n  assertUsage(\n    configValue !== null,\n    `Set ${pc.cyan(configName)} to ${pc.cyan('null')} in a +config.js file instead of ${filePathToShowToUser}`\n  )\n}\n*/\n","export { parseVirtualFileExportsGlobalEntry };\n// TO-DO/next-major-release: remove old design code, and remove all assertions.\nimport { assert, hasProp, isCallable, isObject, cast, isArray } from '../utils.js';\nimport { assertExportValues } from './assert_exports_old_design.js';\nimport { getPageFileObject } from './getPageFileObject.js';\nimport { fileTypes } from './fileTypes.js';\nimport { parsePageConfigsSerialized } from '../page-configs/serialize/parsePageConfigsSerialized.js';\nfunction parseVirtualFileExportsGlobalEntry(virtualFileExportsGlobalEntry) {\n    assert(hasProp(virtualFileExportsGlobalEntry, 'pageFilesLazy', 'object'));\n    assert(hasProp(virtualFileExportsGlobalEntry, 'pageFilesEager', 'object'));\n    assert(hasProp(virtualFileExportsGlobalEntry, 'pageFilesExportNamesLazy', 'object'));\n    assert(hasProp(virtualFileExportsGlobalEntry, 'pageFilesExportNamesEager', 'object'));\n    assert(hasProp(virtualFileExportsGlobalEntry.pageFilesLazy, '.page'));\n    assert(hasProp(virtualFileExportsGlobalEntry.pageFilesLazy, '.page.client') ||\n        hasProp(virtualFileExportsGlobalEntry.pageFilesLazy, '.page.server'));\n    assert(hasProp(virtualFileExportsGlobalEntry, 'pageFilesList', 'string[]'));\n    assert(hasProp(virtualFileExportsGlobalEntry, 'pageConfigsSerialized'));\n    assert(hasProp(virtualFileExportsGlobalEntry, 'pageConfigGlobalSerialized'));\n    const { pageConfigsSerialized, pageConfigGlobalSerialized } = virtualFileExportsGlobalEntry;\n    assertPageConfigsSerialized(pageConfigsSerialized);\n    assertPageConfigGlobalSerialized(pageConfigGlobalSerialized);\n    const { pageConfigs, pageConfigGlobal } = parsePageConfigsSerialized(pageConfigsSerialized, pageConfigGlobalSerialized);\n    const pageFilesMap = {};\n    parseGlobResult(virtualFileExportsGlobalEntry.pageFilesLazy).forEach(({ filePath, pageFile, globValue }) => {\n        pageFile = pageFilesMap[filePath] = pageFilesMap[filePath] ?? pageFile;\n        const loadModule = globValue;\n        assertLoadModule(loadModule);\n        pageFile.loadFile = async () => {\n            if (!('fileExports' in pageFile)) {\n                pageFile.fileExports = await loadModule();\n                assertExportValues(pageFile);\n            }\n        };\n    });\n    parseGlobResult(virtualFileExportsGlobalEntry.pageFilesExportNamesLazy).forEach(({ filePath, pageFile, globValue }) => {\n        pageFile = pageFilesMap[filePath] = pageFilesMap[filePath] ?? pageFile;\n        const loadModule = globValue;\n        assertLoadModule(loadModule);\n        pageFile.loadExportNames = async () => {\n            if (!('exportNames' in pageFile)) {\n                const moduleExports = await loadModule();\n                assert(hasProp(moduleExports, 'exportNames', 'string[]'), pageFile.filePath);\n                pageFile.exportNames = moduleExports.exportNames;\n            }\n        };\n    });\n    // `pageFilesEager` contains `.page.route.js` files\n    parseGlobResult(virtualFileExportsGlobalEntry.pageFilesEager).forEach(({ filePath, pageFile, globValue }) => {\n        pageFile = pageFilesMap[filePath] = pageFilesMap[filePath] ?? pageFile;\n        const moduleExports = globValue;\n        assert(isObject(moduleExports));\n        pageFile.fileExports = moduleExports;\n    });\n    parseGlobResult(virtualFileExportsGlobalEntry.pageFilesExportNamesEager).forEach(({ filePath, pageFile, globValue }) => {\n        pageFile = pageFilesMap[filePath] = pageFilesMap[filePath] ?? pageFile;\n        const moduleExports = globValue;\n        assert(isObject(moduleExports));\n        assert(hasProp(moduleExports, 'exportNames', 'string[]'), pageFile.filePath);\n        pageFile.exportNames = moduleExports.exportNames;\n    });\n    virtualFileExportsGlobalEntry.pageFilesList.forEach((filePath) => {\n        pageFilesMap[filePath] = pageFilesMap[filePath] ?? getPageFileObject(filePath);\n    });\n    const pageFilesAll = Object.values(pageFilesMap);\n    pageFilesAll.forEach(({ filePath }) => {\n        assert(!filePath.includes('\\\\'));\n    });\n    return { pageFilesAll, pageConfigs, pageConfigGlobal };\n}\nfunction parseGlobResult(globObject) {\n    const ret = [];\n    Object.entries(globObject).forEach(([fileType, globFiles]) => {\n        cast(fileType);\n        assert(fileTypes.includes(fileType));\n        assert(isObject(globFiles));\n        Object.entries(globFiles).forEach(([filePath, globValue]) => {\n            const pageFile = getPageFileObject(filePath);\n            assert(pageFile.fileType === fileType);\n            ret.push({ filePath, pageFile, globValue });\n        });\n    });\n    return ret;\n}\nfunction assertLoadModule(globValue) {\n    assert(isCallable(globValue));\n}\nfunction assertPageConfigsSerialized(pageConfigsSerialized) {\n    assert(isArray(pageConfigsSerialized));\n    pageConfigsSerialized.forEach((pageConfigSerialized) => {\n        assert(isObject(pageConfigSerialized));\n        assert(hasProp(pageConfigSerialized, 'pageId', 'string'));\n        assert(hasProp(pageConfigSerialized, 'routeFilesystem'));\n        assert(hasProp(pageConfigSerialized, 'configValuesSerialized'));\n    });\n}\nfunction assertPageConfigGlobalSerialized(pageConfigGlobalSerialized) {\n    assert(hasProp(pageConfigGlobalSerialized, 'configValuesSerialized'));\n}\n","// TO-DO/soon/same-api: use public API internally?\n// TO-DO/soon/flat-pageContext: rename definedAt => definedBy\nexport { resolveGlobalConfigPublic };\nexport { resolvePageContextConfig };\nexport { resolveGlobalContextConfig };\nimport { assertDefaultExports, forbiddenDefaultExports } from '../getPageFiles/assert_exports_old_design.js';\nimport { getConfigDefinedAtOptional, getDefinedAtString } from './getConfigDefinedAt.js';\nimport { getConfigValueFilePathToShowToUser } from './helpers.js';\nimport { assert, isObject, assertWarning, assertUsage, makeLast, isBrowser, isScriptFile, isTemplateFile, objectDefineProperty, } from '../utils.js';\nimport pc from '@brillout/picocolors';\nfunction resolveGlobalConfigPublicPage(pageConfigGlobalValues, pageConfig, pageConfigValues) {\n    const pageConfigPublic_ = resolvePageConfigPublic({ pageConfigGlobalValues, pageConfigValues });\n    const pageConfigPublic = getPublicCopy(pageConfigPublic_);\n    const page = (() => {\n        if (!pageConfig.isErrorPage) {\n            const route = pageConfigPublic.config.route ?? pageConfig.routeFilesystem.routeString;\n            return {\n                ...pageConfigPublic,\n                route,\n            };\n        }\n        else {\n            return {\n                ...pageConfigPublic,\n                isErrorPage: true,\n            };\n        }\n    })();\n    return [pageConfig.pageId, page];\n}\nfunction getPublicCopy(configInternal) {\n    const configPublic = {\n        config: configInternal.config,\n        // TO-DO/soon/flat-pageContext: expose publicly?\n        _source: configInternal.source,\n        _sources: configInternal.sources,\n        _from: configInternal.from,\n    };\n    return configPublic;\n}\nfunction resolvePageConfigPublic({ pageConfigGlobalValues, pageConfigValues, }) {\n    const configValues = { ...pageConfigGlobalValues, ...pageConfigValues };\n    return resolveConfigPublic_V1Design({ configValues });\n}\nfunction resolvePageContextConfig(pageFiles, // V0.4 design\npageConfig, // V1 design\npageConfigGlobal) {\n    const config = {};\n    const configEntries = {}; // TO-DO/next-major-release: remove\n    const exportsAll = {}; // TO-DO/next-major-release: remove\n    // V0.4 design\n    // TO-DO/next-major-release: remove\n    pageFiles.forEach((pageFile) => {\n        const exportValues = getExportValues(pageFile);\n        exportValues.forEach(({ exportName, exportValue, isFromDefaultExport }) => {\n            assert(exportName !== 'default');\n            exportsAll[exportName] = exportsAll[exportName] ?? [];\n            exportsAll[exportName].push({\n                exportValue,\n                exportSource: `${pageFile.filePath} > ${isFromDefaultExport ? `\\`export default { ${exportName} }\\`` : `\\`export { ${exportName} }\\``}`,\n                filePath: pageFile.filePath,\n                _filePath: pageFile.filePath, // TO-DO/next-major-release: remove\n                _fileType: pageFile.fileType,\n                _isFromDefaultExport: isFromDefaultExport,\n            });\n        });\n    });\n    let source;\n    let sources;\n    let from;\n    if (pageConfig) {\n        const res = resolvePageConfigPublic({\n            pageConfigGlobalValues: pageConfigGlobal.configValues,\n            pageConfigValues: pageConfig.configValues,\n        });\n        source = res.source;\n        sources = res.sources;\n        from = res.from;\n        Object.assign(config, res.config);\n        Object.assign(configEntries, res.configEntries);\n        Object.assign(exportsAll, res.exportsAll);\n    }\n    else {\n        source = {};\n        sources = {};\n        from = {\n            configsStandard: {},\n            configsCumulative: {},\n            configsComputed: {},\n        };\n    }\n    const pageExports = {};\n    const exports = {};\n    Object.entries(exportsAll).forEach(([exportName, values]) => {\n        values.forEach(({ exportValue, _fileType, _isFromDefaultExport }) => {\n            exports[exportName] = exports[exportName] ?? exportValue;\n            // Legacy pageContext.pageExports\n            if (_fileType === '.page' && !_isFromDefaultExport) {\n                if (!(exportName in pageExports)) {\n                    pageExports[exportName] = exportValue;\n                }\n            }\n        });\n    });\n    assert(!('default' in exports));\n    assert(!('default' in exportsAll));\n    const pageContextAddendum = {\n        config: config,\n        from,\n        source,\n        sources,\n        // TO-DO/soon/flat-pageContext: deprecate every prop below\n        configEntries,\n        exports,\n        exportsAll,\n    };\n    // TO-DO/next-major-release: remove\n    objectDefineProperty(pageContextAddendum, 'pageExports', {\n        get: () => {\n            // We only show the warning in Node.js because when using Client Routing Vue integration uses `Object.assign(pageContextReactive, pageContext)` which will wrongully trigger the warning. There is no cross-browser way to catch whether the property accessor was initiated by an `Object.assign()` call.\n            if (!isBrowser()) {\n                assertWarning(false, 'pageContext.pageExports is outdated, use pageContext.exports instead', {\n                    onlyOnce: true,\n                    showStackTrace: true,\n                });\n            }\n            return pageExports;\n        },\n        enumerable: false,\n        configurable: true,\n    });\n    return pageContextAddendum;\n}\nfunction resolveGlobalContextConfig(pageConfigs, pageConfigGlobal) {\n    const globalContextAddendum = resolveGlobalConfigPublic(pageConfigs, pageConfigGlobal, (c) => c.configValues);\n    return globalContextAddendum;\n}\nfunction resolveGlobalConfigPublic(pageConfigs, pageConfigGlobal, getConfigValues) {\n    // global\n    const pageConfigGlobalValues = getConfigValues(pageConfigGlobal, true);\n    const globalConfigPublicBase_ = resolveConfigPublic_V1Design({ configValues: pageConfigGlobalValues });\n    const globalConfigPublicBase = getPublicCopy(globalConfigPublicBase_);\n    // pages\n    const pages = Object.fromEntries(pageConfigs.map((pageConfig) => {\n        const pageConfigValues = getConfigValues(pageConfig);\n        return resolveGlobalConfigPublicPage(pageConfigGlobalValues, pageConfig, pageConfigValues);\n    }));\n    const globalConfigPublic = {\n        ...globalConfigPublicBase,\n        pages,\n    };\n    return {\n        ...globalConfigPublic,\n        _globalConfigPublic: globalConfigPublic,\n    };\n}\n// V1 design\nfunction resolveConfigPublic_V1Design(pageConfig) {\n    const config = {};\n    const configEntries = {};\n    const exportsAll = {};\n    const source = {};\n    const sources = {};\n    const from = {\n        configsStandard: {},\n        configsCumulative: {},\n        configsComputed: {},\n    };\n    const addSrc = (src, configName) => {\n        source[configName] = src;\n        sources[configName] ?? (sources[configName] = []);\n        sources[configName].push(src);\n    };\n    const addLegacy = (configName, value, definedAtData) => {\n        const configValueFilePathToShowToUser = getConfigValueFilePathToShowToUser(definedAtData);\n        const configDefinedAt = getConfigDefinedAtOptional('Config', configName, definedAtData);\n        configEntries[configName] = configEntries[configName] ?? [];\n        configEntries[configName].push({\n            configValue: value,\n            configDefinedAt,\n            configDefinedByFile: configValueFilePathToShowToUser,\n        });\n        // TO-DO/next-major-release: remove\n        const exportName = configName;\n        exportsAll[exportName] = exportsAll[exportName] ?? [];\n        exportsAll[exportName].push({\n            exportValue: value,\n            exportSource: configDefinedAt,\n            filePath: configValueFilePathToShowToUser,\n            _filePath: configValueFilePathToShowToUser,\n            _fileType: null,\n            _isFromDefaultExport: null,\n        });\n    };\n    Object.entries(pageConfig.configValues).forEach(([configName, configValue]) => {\n        const { value } = configValue;\n        config[configName] = config[configName] ?? value;\n        if (configValue.type === 'standard') {\n            const src = {\n                type: 'configsStandard',\n                value: configValue.value,\n                definedAt: getDefinedAtString(configValue.definedAtData, configName),\n            };\n            addSrc(src, configName);\n            from.configsStandard[configName] = src;\n            addLegacy(configName, value, configValue.definedAtData);\n        }\n        if (configValue.type === 'cumulative') {\n            const src = {\n                type: 'configsCumulative',\n                definedAt: getDefinedAtString(configValue.definedAtData, configName),\n                values: configValue.value.map((value, i) => {\n                    const definedAtFile = configValue.definedAtData[i];\n                    assert(definedAtFile);\n                    const definedAt = getDefinedAtString(definedAtFile, configName);\n                    addLegacy(configName, value, definedAtFile);\n                    return {\n                        value,\n                        definedAt,\n                    };\n                }),\n            };\n            addSrc(src, configName);\n            from.configsCumulative[configName] = src;\n        }\n        if (configValue.type === 'computed') {\n            const src = {\n                type: 'configsComputed',\n                definedAt: 'Vike', // Vike currently doesn't support user-land computed configs => computed configs are always defined by Vike => there isn't any file path to show.\n                value: configValue.value,\n            };\n            addSrc(src, configName);\n            from.configsComputed[configName] = src;\n            addLegacy(configName, value, configValue.definedAtData);\n        }\n    });\n    return {\n        config: config,\n        configEntries,\n        exportsAll,\n        source,\n        sources,\n        from,\n    };\n}\n// V0.4 design\n// TO-DO/next-major-release: remove\nfunction getExportValues(pageFile) {\n    const { filePath, fileExports } = pageFile;\n    assert(fileExports); // assume pageFile.loadFile() was called\n    assert(isScriptFile(filePath));\n    const exportValues = [];\n    Object.entries(fileExports)\n        .sort(makeLast(([exportName]) => exportName === 'default')) // `export { bla }` should override `export default { bla }`\n        .forEach(([exportName, exportValue]) => {\n        let isFromDefaultExport = exportName === 'default';\n        if (isFromDefaultExport) {\n            if (isTemplateFile(filePath)) {\n                exportName = 'Page';\n            }\n            else {\n                assertUsage(isObject(exportValue), `The ${pc.cyan('export default')} of ${filePath} should be an object.`);\n                Object.entries(exportValue).forEach(([defaultExportName, defaultExportValue]) => {\n                    assertDefaultExports(defaultExportName, filePath);\n                    exportValues.push({\n                        exportName: defaultExportName,\n                        exportValue: defaultExportValue,\n                        isFromDefaultExport,\n                    });\n                });\n                return;\n            }\n        }\n        exportValues.push({\n            exportName,\n            exportValue,\n            isFromDefaultExport,\n        });\n    });\n    exportValues.forEach(({ exportName, isFromDefaultExport }) => {\n        assert(!(isFromDefaultExport && forbiddenDefaultExports.includes(exportName)));\n    });\n    return exportValues;\n}\n","export { createGlobalContextShared };\nexport { getGlobalContextSyncErrMsg };\nimport { assert, changeEnumerable, genPromise, objectAssign, objectReplace, unique } from './utils.js';\nimport { parseVirtualFileExportsGlobalEntry } from './getPageFiles/parseVirtualFileExportsGlobalEntry.js';\nimport { resolveGlobalContextConfig } from './page-configs/resolveVikeConfigPublic.js';\nimport { execHookGlobal } from './hooks/execHook.js';\nimport { prepareGlobalContextForPublicUsage, } from './prepareGlobalContextForPublicUsage.js';\nimport { getHookFromPageConfigGlobalCumulative } from './hooks/getHook.js';\nconst getGlobalContextSyncErrMsg = \"The global context isn't set yet, call getGlobalContextSync() later or use getGlobalContext() instead.\";\n// TO-DO/eventually use flat globalContext  like flat pageContext\nasync function createGlobalContextShared(virtualFileExportsGlobalEntry, globalObject, addGlobalContext, \n// TO-DO/next-major-release: we'll be able to remove addGlobalContextTmp after loadPageRoutes() is sync (it will be sync after we remove the old design)\naddGlobalContextTmp, addGlobalContextAsync) {\n    const { previousCreateGlobalContextPromise } = globalObject;\n    const { promise, resolve } = genPromise({\n        // Avoid this Cloudflare Worker error:\n        // ```console\n        // Error: Disallowed operation called within global scope. Asynchronous I/O (ex: fetch() or connect()), setting a timeout, and generating random values are not allowed within global scope. To fix this error, perform this operation within a handler.\n        // ```\n        timeout: null,\n    });\n    globalObject.previousCreateGlobalContextPromise = promise;\n    if (previousCreateGlobalContextPromise) {\n        assert(globalObject.globalContext);\n        await previousCreateGlobalContextPromise;\n    }\n    const globalContext = createGlobalContextBase(virtualFileExportsGlobalEntry);\n    let isNewGlobalContext;\n    if (!globalObject.globalContext) {\n        // We set globalObject.globalContext early and before any async operations, so that getGlobalContextSync() can be used early.\n        // - Required by vike-vercel\n        globalObject.globalContext = globalContext;\n        isNewGlobalContext = false;\n    }\n    else {\n        isNewGlobalContext = true;\n    }\n    if (addGlobalContext &&\n        // TO-DO/next-major-release: remove\n        globalContext._pageConfigs.length > 0) {\n        const globalContextAdded = addGlobalContext?.(globalContext);\n        objectAssign(globalContext, globalContextAdded);\n    }\n    else {\n        const globalContextAdded = await addGlobalContextTmp?.(globalContext);\n        objectAssign(globalContext, globalContextAdded);\n    }\n    {\n        const globalContextAddedAsync = await addGlobalContextAsync?.(globalContext);\n        objectAssign(globalContext, globalContextAddedAsync);\n    }\n    const onCreateGlobalContextHooks = getHookFromPageConfigGlobalCumulative(globalContext._pageConfigGlobal, 'onCreateGlobalContext');\n    let hooksCalled = false;\n    if (!hooksAreEqual(globalObject.onCreateGlobalContextHooks ?? [], onCreateGlobalContextHooks)) {\n        globalObject.onCreateGlobalContextHooks = onCreateGlobalContextHooks;\n        await execHookGlobal('onCreateGlobalContext', globalContext._pageConfigGlobal, null, globalContext, prepareGlobalContextForPublicUsage);\n        hooksCalled = true;\n    }\n    if (isNewGlobalContext) {\n        // Singleton: ensure all `globalContext` user-land references are preserved & updated.\n        if (hooksCalled) {\n            objectReplace(globalObject.globalContext, globalContext);\n        }\n        else {\n            // We don't use objectReplace() in order to keep user-land properties.\n            objectAssign(globalObject.globalContext, globalContext, true);\n        }\n    }\n    resolve();\n    return globalObject.globalContext;\n}\nfunction createGlobalContextBase(virtualFileExportsGlobalEntry) {\n    const { pageFilesAll, pageConfigs, pageConfigGlobal } = parseVirtualFileExportsGlobalEntry(virtualFileExportsGlobalEntry);\n    const allPageIds = getAllPageIds(pageFilesAll, pageConfigs);\n    const globalContextAddendum = resolveGlobalContextConfig(pageConfigs, pageConfigGlobal);\n    const globalContext = {\n        /**\n         * Useful for distinguishing `globalContext` from other objects and narrowing down TypeScript unions.\n         *\n         * https://vike.dev/globalContext#typescript\n         */\n        isGlobalContext: true,\n        _isOriginalObject: true,\n        _virtualFileExportsGlobalEntry: virtualFileExportsGlobalEntry,\n        _pageFilesAll: pageFilesAll,\n        _pageConfigs: pageConfigs,\n        _pageConfigGlobal: pageConfigGlobal,\n        _allPageIds: allPageIds,\n        ...globalContextAddendum,\n    };\n    changeEnumerable(globalContext, '_isOriginalObject', false);\n    return globalContext;\n}\nfunction getAllPageIds(pageFilesAll, pageConfigs) {\n    const fileIds = pageFilesAll.filter(({ isDefaultPageFile }) => !isDefaultPageFile).map(({ pageId }) => pageId);\n    const allPageIds = unique(fileIds);\n    const allPageIds2 = pageConfigs.map((p) => p.pageId);\n    return [...allPageIds, ...allPageIds2];\n}\nfunction hooksAreEqual(hooks1, hooks2) {\n    const hooksFn1 = hooks1.map((hook) => hook.hookFn);\n    const hooksFn2 = hooks2.map((hook) => hook.hookFn);\n    return (hooksFn1.every((hook) => hooksFn2.includes(hook)) &&\n        //\n        hooksFn2.every((hook) => hooksFn1.includes(hook)));\n}\n","export function objectReplace(objOld, objNew, except) {\n    Object.keys(objOld)\n        .filter((key) => !except?.includes(key))\n        .forEach((key) => delete objOld[key]);\n    Object.defineProperties(objOld, Object.getOwnPropertyDescriptors(objNew));\n}\n","// Public usage\nexport { getGlobalContext };\nexport { getGlobalContextSync };\nexport { setVirtualFileExportsGlobalEntry };\n// Internal usage\nexport { getGlobalContextClientInternalShared };\nimport { createGlobalContextShared, getGlobalContextSyncErrMsg } from '../../shared/createGlobalContextShared.js';\nimport { getGlobalContextSerializedInHtml } from './getJsonSerializedInHtml.js';\nimport { assert, assertUsage, genPromise, getGlobalObject, objectAssign, checkType } from './utils.js';\nconst globalObject = getGlobalObject('getGlobalContextClientInternalShared.ts', (() => {\n    const { promise: globalContextInitialPromise, resolve: globalContextInitialPromiseResolve } = genPromise();\n    return {\n        globalContextInitialPromise,\n        globalContextInitialPromiseResolve,\n    };\n})());\nasync function getGlobalContextClientInternalShared() {\n    // Get\n    if (globalObject.globalContextPromise) {\n        const globalContext = await globalObject.globalContextPromise;\n        return globalContext;\n    }\n    // Create\n    const globalContextPromise = createGlobalContextShared(globalObject.virtualFileExportsGlobalEntry, globalObject, () => {\n        const globalContextAddendum = {\n            /**\n             * Whether the environment is the client-side:\n             * - In the browser, the value is `true`.\n             * - Upon SSR and pre-rendering, the value is `false`.\n             *\n             * https://vike.dev/globalContext#isClientSide\n             */\n            isClientSide: true,\n        };\n        objectAssign(globalContextAddendum, getGlobalContextSerializedInHtml());\n        return globalContextAddendum;\n    });\n    globalObject.globalContextPromise = globalContextPromise;\n    const globalContext = await globalContextPromise;\n    assert(globalObject.globalContext === globalContext);\n    globalObject.globalContextInitialPromiseResolve();\n    // Return\n    return globalContext;\n}\nasync function getGlobalContext() {\n    await globalObject.globalContextInitialPromise;\n    const globalContext = await globalObject.globalContextPromise;\n    assert(globalContext);\n    checkType(globalContext);\n    return globalContext;\n}\nfunction getGlobalContextSync() {\n    const { globalContext } = globalObject;\n    assertUsage(globalContext, getGlobalContextSyncErrMsg);\n    checkType(globalContext);\n    return globalContext;\n}\nasync function setVirtualFileExportsGlobalEntry(virtualFileExportsGlobalEntry) {\n    // HMR => virtualFileExportsGlobalEntry differ\n    if (globalObject.virtualFileExportsGlobalEntry !== virtualFileExportsGlobalEntry) {\n        delete globalObject.globalContextPromise;\n        globalObject.virtualFileExportsGlobalEntry = virtualFileExportsGlobalEntry;\n        // Eagerly call +onCreateGlobalContext() hooks\n        await getGlobalContextClientInternalShared();\n    }\n}\n","export { resolveRouteFunction };\nexport { assertRouteParams };\nexport { assertSyncRouting };\nexport { warnDeprecatedAllowKey };\nimport { execHookDirectSync } from '../hooks/execHook.js';\nimport { preparePageContextForPublicUsage } from '../preparePageContextForPublicUsage.js';\nimport { assert, assertUsage, assertWarning, hasProp, isPlainObject, isPromise } from './utils.js';\nimport pc from '@brillout/picocolors';\nasync function resolveRouteFunction(routeFunction, pageContext, routeFunctionFilePath) {\n    let { hookReturn: result } = execHookDirectSync({\n        hookFn: routeFunction,\n        hookFilePath: routeFunctionFilePath,\n        hookName: 'route',\n    }, pageContext, preparePageContextForPublicUsage);\n    assertSyncRouting(result, `The Route Function ${routeFunctionFilePath}`);\n    // TO-DO/next-major-release: make resolveRouteFunction() and route() sync\n    //* We disallow asynchronous routing, because we need to check whether a link is a Vike link in a synchronous fashion before calling ev.preventDefault() in the 'click' event listener\n    result = await result;\n    //*/\n    if (result === false) {\n        return null;\n    }\n    if (result === true) {\n        result = {};\n    }\n    assertUsage(isPlainObject(result), `The Route Function ${routeFunctionFilePath} should return a boolean or a plain JavaScript object (but it's ${pc.cyan(`typeof result === ${JSON.stringify(typeof result)}`)} instead)`);\n    // AFAICT this return interface is superfluous. Should we soft-deprecate it and remove it?\n    if ('match' in result) {\n        const { match } = result;\n        assertUsage(typeof match === 'boolean', `The ${pc.cyan('match')} value returned by the Route Function ${routeFunctionFilePath} should be a boolean.`);\n        if (!match) {\n            return null;\n        }\n    }\n    let precedence = null;\n    if ('precedence' in result) {\n        precedence = result.precedence;\n        assertUsage(typeof precedence === 'number', `The ${pc.cyan('precedence')} value returned by the Route Function ${routeFunctionFilePath} should be a number.`);\n    }\n    assertRouteParams(result, `The ${pc.cyan('routeParams')} object returned by the Route Function ${routeFunctionFilePath} should`);\n    const routeParams = result.routeParams || {};\n    assertUsage(!('pageContext' in result), `Providing ${pc.cyan('pageContext')} in Route Functions is prohibited, see https://vike.dev/route-function#cannot-provide-pagecontext`);\n    assert(isPlainObject(routeParams));\n    Object.keys(result).forEach((key) => {\n        assertUsage(key === 'match' || key === 'routeParams' || key === 'precedence', `The Route Function ${routeFunctionFilePath} returned an object with an unknown property ${pc.cyan(key)} (the known properties are ${pc.cyan('match')}, ${pc.cyan('routeParams')}, and ${pc.cyan('precedence')})`);\n    });\n    return {\n        precedence,\n        routeParams,\n    };\n}\n// TO-DO/next-major-release: remove, and make routing synchronous (enabling Vike to synchronously check whether a link is a Vike link before even calling ev.preventDefault())\nfunction assertSyncRouting(res, errPrefix) {\n    assertWarning(!isPromise(res), `${errPrefix} returned a promise, but asynchronous routing is deprecated and will be removed in the next major release, see https://vike.dev/route-function#async`, { onlyOnce: true });\n}\n// TO-DO/next-major-release: remove\nfunction warnDeprecatedAllowKey() {\n    const allowKey = pc.cyan('iKnowThePerformanceRisksOfAsyncRouteFunctions');\n    assertWarning(false, `${allowKey} is deprecated and will be removed in the next major release`, { onlyOnce: true });\n}\nfunction assertRouteParams(result, errPrefix) {\n    assert(errPrefix.endsWith(' should'));\n    if (!hasProp(result, 'routeParams')) {\n        return;\n    }\n    assert(errPrefix.endsWith(' should'));\n    assertUsage(hasProp(result, 'routeParams', 'string{}'), `${errPrefix} be an object holding string values.`);\n}\n","import { isCallable } from './isCallable.js';\nexport function isPromise(val) {\n    return typeof val === 'object' && val !== null && 'then' in val && isCallable(val.then);\n}\n","export { loadPageRoutes };\nexport { loadPageRoutesSync };\nimport { isErrorPageId } from '../error-page.js';\nimport { assert, assertUsage, hasProp, slice } from './utils.js';\nimport { deduceRouteStringFromFilesystemPath } from './deduceRouteStringFromFilesystemPath.js';\nimport { isArray, isCallable } from '../utils.js';\nimport { getConfigValueRuntime } from '../page-configs/getConfigValueRuntime.js';\nimport { getDefinedAtString } from '../page-configs/getConfigDefinedAt.js';\nimport { warnDeprecatedAllowKey } from './resolveRouteFunction.js';\nimport { getHookFromPageConfigGlobal, getHookTimeoutDefault } from '../hooks/getHook.js';\nasync function loadPageRoutes(\n// Remove all arguments and use GlobalContextServerInternal instead?\npageFilesAll, pageConfigs, pageConfigGlobal, allPageIds) {\n    // TO-DO/next-major-release: remove this line, remove this function, rename loadPageRoutesSync() to loadPageRoutes()\n    await Promise.all(pageFilesAll.filter((p) => p.fileType === '.page.route').map((p) => p.loadFile?.()));\n    return loadPageRoutesSync(pageFilesAll, pageConfigs, pageConfigGlobal, allPageIds);\n}\nfunction loadPageRoutesSync(\n// Remove all arguments and use GlobalContextServerInternal instead?\npageFilesAll, pageConfigs, pageConfigGlobal, allPageIds) {\n    const { onBeforeRouteHook, filesystemRoots } = getGlobalHooks(pageFilesAll, pageConfigs, pageConfigGlobal);\n    const pageRoutes = getPageRoutes(filesystemRoots, pageFilesAll, pageConfigs, allPageIds);\n    return { pageRoutes, onBeforeRouteHook };\n}\nfunction getPageRoutes(filesystemRoots, pageFilesAll, pageConfigs, allPageIds) {\n    const pageRoutes = [];\n    // V1 Design\n    if (pageConfigs.length > 0) {\n        assert(filesystemRoots === null);\n        const comesFromV1PageConfig = true;\n        pageConfigs\n            .filter((p) => !p.isErrorPage)\n            .forEach((pageConfig) => {\n            const pageId = pageConfig.pageId;\n            let pageRoute = null;\n            {\n                const configName = 'route';\n                const configValue = getConfigValueRuntime(pageConfig, configName);\n                if (configValue) {\n                    const route = configValue.value;\n                    assert(configValue.definedAtData);\n                    const definedAtString = getDefinedAtString(configValue.definedAtData, configName);\n                    if (typeof route === 'string') {\n                        pageRoute = {\n                            pageId,\n                            comesFromV1PageConfig,\n                            routeString: route,\n                            routeDefinedAtString: definedAtString,\n                            routeType: 'STRING',\n                        };\n                    }\n                    else {\n                        const { definedAtData } = configValue;\n                        assert(!isArray(definedAtData) && !definedAtData.definedBy);\n                        const { filePathToShowToUser } = definedAtData;\n                        assert(filePathToShowToUser);\n                        assert(isCallable(route));\n                        // TO-DO/next-major-release: remove\n                        if (getConfigValueRuntime(pageConfig, 'iKnowThePerformanceRisksOfAsyncRouteFunctions', 'boolean'))\n                            warnDeprecatedAllowKey();\n                        pageRoute = {\n                            pageId,\n                            comesFromV1PageConfig,\n                            routeFunction: route,\n                            routeFunctionFilePath: filePathToShowToUser,\n                            routeDefinedAtString: definedAtString,\n                            routeType: 'FUNCTION',\n                        };\n                    }\n                }\n            }\n            if (!pageRoute) {\n                const { routeFilesystem } = pageConfig;\n                assert(routeFilesystem);\n                const { routeString, definedAtLocation } = routeFilesystem;\n                assert(routeFilesystem.routeString.startsWith('/'));\n                pageRoute = {\n                    pageId,\n                    routeFilesystemDefinedBy: definedAtLocation,\n                    comesFromV1PageConfig,\n                    routeString,\n                    routeDefinedAtString: null,\n                    routeType: 'FILESYSTEM',\n                };\n            }\n            assert(pageRoute);\n            pageRoutes.push(pageRoute);\n        });\n    }\n    // Old design\n    // TO-DO/next-major-release: remove\n    if (pageConfigs.length === 0) {\n        assert(filesystemRoots);\n        const comesFromV1PageConfig = false;\n        allPageIds\n            .filter((pageId) => !isErrorPageId(pageId, false))\n            .forEach((pageId) => {\n            const pageRouteFile = pageFilesAll.find((p) => p.pageId === pageId && p.fileType === '.page.route');\n            if (!pageRouteFile || !('default' in pageRouteFile.fileExports)) {\n                const routeString = deduceRouteStringFromFilesystemPath(pageId, filesystemRoots);\n                assert(routeString.startsWith('/'));\n                assert(!routeString.endsWith('/') || routeString === '/');\n                pageRoutes.push({\n                    pageId,\n                    comesFromV1PageConfig,\n                    routeString,\n                    routeDefinedAtString: null,\n                    routeFilesystemDefinedBy: `${pageId}.page.*`,\n                    routeType: 'FILESYSTEM',\n                });\n            }\n            else {\n                const { filePath, fileExports } = pageRouteFile;\n                assert(fileExports.default);\n                if (hasProp(fileExports, 'default', 'string')) {\n                    const routeString = fileExports.default;\n                    assertUsage(routeString.startsWith('/'), `A Route String should start with a leading slash '/' but ${filePath} has \\`export default '${routeString}'\\`. Make sure to \\`export default '/${routeString}'\\` instead.`);\n                    pageRoutes.push({\n                        pageId,\n                        comesFromV1PageConfig,\n                        routeString,\n                        routeDefinedAtString: filePath,\n                        routeType: 'STRING',\n                    });\n                    return;\n                }\n                if (hasProp(fileExports, 'default', 'function')) {\n                    const routeFunction = fileExports.default;\n                    {\n                        const allowKey = 'iKnowThePerformanceRisksOfAsyncRouteFunctions';\n                        if (allowKey in fileExports) {\n                            warnDeprecatedAllowKey();\n                        }\n                    }\n                    pageRoutes.push({\n                        pageId,\n                        comesFromV1PageConfig,\n                        routeFunction,\n                        routeFunctionFilePath: filePath,\n                        routeDefinedAtString: filePath,\n                        routeType: 'FUNCTION',\n                    });\n                    return;\n                }\n                assertUsage(false, `The default export of ${filePath} should be a string or a function.`);\n            }\n        });\n    }\n    return pageRoutes;\n}\nfunction getGlobalHooks(pageFilesAll, pageConfigs, pageConfigGlobal) {\n    // V1 Design\n    if (pageConfigs.length > 0) {\n        const hook = getHookFromPageConfigGlobal(pageConfigGlobal, 'onBeforeRoute');\n        return { onBeforeRouteHook: hook, filesystemRoots: null };\n    }\n    // Old design\n    // TO-DO/next-major-release: remove\n    let onBeforeRouteHook = null;\n    const filesystemRoots = [];\n    pageFilesAll\n        .filter((p) => p.fileType === '.page.route' && p.isDefaultPageFile)\n        .forEach(({ filePath, fileExports }) => {\n        assert(fileExports);\n        if ('onBeforeRoute' in fileExports) {\n            assertUsage(hasProp(fileExports, 'onBeforeRoute', 'function'), `\\`export { onBeforeRoute }\\` of ${filePath} should be a function.`);\n            const { onBeforeRoute } = fileExports;\n            const hookName = 'onBeforeRoute';\n            onBeforeRouteHook = {\n                hookFilePath: filePath,\n                hookFn: onBeforeRoute,\n                hookName,\n                hookTimeout: getHookTimeoutDefault(hookName),\n            };\n        }\n        if ('filesystemRoutingRoot' in fileExports) {\n            assertUsage(hasProp(fileExports, 'filesystemRoutingRoot', 'string'), `\\`export { filesystemRoutingRoot }\\` of ${filePath} should be a string.`);\n            assertUsage(hasProp(fileExports, 'filesystemRoutingRoot', 'string'), `\\`export { filesystemRoutingRoot }\\` of ${filePath} is \\`'${fileExports.filesystemRoutingRoot}'\\` but it should start with a leading slash \\`/\\`.`);\n            filesystemRoots.push({\n                filesystemRoot: dirname(filePath),\n                urlRoot: fileExports.filesystemRoutingRoot,\n            });\n        }\n    });\n    return { onBeforeRouteHook, filesystemRoots };\n}\nfunction dirname(filePath) {\n    assert(filePath.startsWith('/'));\n    assert(!filePath.endsWith('/'));\n    const paths = filePath.split('/');\n    const dirPath = slice(paths, 0, -1).join('/') || '/';\n    assert(dirPath.startsWith('/'));\n    assert(!dirPath.endsWith('/') || dirPath === '/');\n    return dirPath;\n}\n","// Unit tests at ./deduceRouteStringFromFilesystemPath.spec.ts\nimport { assert, higherFirst, slice } from './utils.js';\nexport { deduceRouteStringFromFilesystemPath };\n// TO-DO/next-major-release: remove this and whole filesystemRoot mechanism\nfunction deduceRouteStringFromFilesystemPath(pageId, filesystemRoots) {\n    // Handle Filesystem Routing Root\n    const filesystemRootsMatch = filesystemRoots\n        .filter(({ filesystemRoot }) => pageId.startsWith(filesystemRoot))\n        .sort(higherFirst(({ filesystemRoot }) => filesystemRoot.length));\n    const fsBase = filesystemRootsMatch[0];\n    let filesystemRoute;\n    if (fsBase) {\n        // Example values:\n        //  - `{\"pageId\":\"/pages/index\",\"filesystemRoot\":\"/\",\"urlRoot\":\"/client_portal\"}`\n        const { filesystemRoot, urlRoot } = fsBase;\n        const debugInfo = { pageId, filesystemRoot, urlRoot };\n        assert(urlRoot.startsWith('/') && pageId.startsWith('/') && filesystemRoot.startsWith('/'), debugInfo);\n        assert(pageId.startsWith(filesystemRoot), debugInfo);\n        if (filesystemRoot !== '/') {\n            assert(!filesystemRoot.endsWith('/'), debugInfo);\n            filesystemRoute = slice(pageId, filesystemRoot.length, 0);\n        }\n        else {\n            filesystemRoute = pageId;\n        }\n        assert(filesystemRoute.startsWith('/'), debugInfo);\n        filesystemRoute = urlRoot + (urlRoot.endsWith('/') ? '' : '/') + slice(filesystemRoute, 1, 0);\n    }\n    else {\n        filesystemRoute = pageId;\n    }\n    assert(filesystemRoute.startsWith('/'));\n    // Remove `pages/`, `index/, and `src/`, directories\n    filesystemRoute = filesystemRoute\n        .split('/')\n        .filter((dir) => dir !== 'pages' && dir !== 'src' && dir !== 'index')\n        .join('/');\n    // Handle `/index.page.*` suffix\n    assert(!filesystemRoute.includes('.page.'));\n    assert(!filesystemRoute.endsWith('.'));\n    if (filesystemRoute.endsWith('/index')) {\n        filesystemRoute = slice(filesystemRoute, 0, -'/index'.length);\n    }\n    if (filesystemRoute === '') {\n        filesystemRoute = '/';\n    }\n    assert(filesystemRoute.startsWith('/'));\n    assert(!filesystemRoute.endsWith('/') || filesystemRoute === '/');\n    return filesystemRoute;\n}\n","export { getGlobalContextClientInternal };\nimport { getGlobalContextClientInternalShared } from '../shared/getGlobalContextClientInternalShared.js';\nimport { loadPageRoutes } from '../../shared/route/loadPageRoutes.js';\nimport { objectAssign } from './utils.js';\nasync function getGlobalContextClientInternal() {\n    const globalContext = await getGlobalContextClientInternalShared();\n    objectAssign(globalContext, await addGlobalContext(globalContext));\n    return globalContext;\n}\n// TO-DO/next-major-release make this function sync\nasync function addGlobalContext(globalContext) {\n    const { pageRoutes, onBeforeRouteHook } = await loadPageRoutes(globalContext._pageFilesAll, globalContext._pageConfigs, globalContext._pageConfigGlobal, globalContext._allPageIds);\n    return {\n        _pageRoutes: pageRoutes,\n        _onBeforeRouteHook: onBeforeRouteHook,\n    };\n}\n","export { createPageContextClientSide };\nimport { createPageContextObject, createPageContextShared } from '../../shared/createPageContextShared.js';\nimport { getPageContextUrlComputed } from '../../shared/getPageContextUrlComputed.js';\nimport { getBaseServer } from './getBaseServer.js';\nimport { getGlobalContextClientInternal } from './getGlobalContextClientInternal.js';\nimport { assert, updateType, isBaseServer, objectAssign } from './utils.js';\nasync function createPageContextClientSide(urlOriginal) {\n    const globalContext = await getGlobalContextClientInternal();\n    const baseServer = getBaseServer();\n    assert(isBaseServer(baseServer));\n    const pageContextCreated = createPageContextObject();\n    objectAssign(pageContextCreated, {\n        isClientSide: true,\n        isPrerendering: false,\n        urlOriginal,\n        _globalContext: globalContext,\n        _pageFilesAll: globalContext._pageFilesAll, // TO-DO/next-major-release: remove\n        _urlHandler: null,\n        _urlRewrite: null,\n        _baseServer: baseServer,\n    });\n    const pageContextUrlComputed = getPageContextUrlComputed(pageContextCreated);\n    objectAssign(pageContextCreated, pageContextUrlComputed);\n    const pageContextAugmented = createPageContextShared(pageContextCreated, globalContext._globalConfigPublic);\n    updateType(pageContextCreated, pageContextAugmented);\n    return pageContextCreated;\n}\n","export { getBaseServer };\nimport { assert } from '../runtime-server-routing/utils.js';\nfunction getBaseServer() {\n    const baseServer = import.meta.env.BASE_SERVER;\n    assert(isBaseServer(baseServer));\n    return baseServer;\n}\n// We don't use isBaseServer() defined in utils/parseUrl.ts to avoid loading the whole file in the browser\nfunction isBaseServer(baseServer) {\n    return baseServer.startsWith('/');\n}\n","export { createPageContextShared };\nexport { createPageContextObject };\nimport { changeEnumerable, objectAssign } from './utils.js';\nfunction createPageContextShared(pageContextCreated, globalConfigPublic) {\n    objectAssign(pageContextCreated, globalConfigPublic);\n    return pageContextCreated;\n}\nfunction createPageContextObject() {\n    const pageContext = {\n        _isOriginalObject: true,\n        isPageContext: true,\n    };\n    changeEnumerable(pageContext, '_isOriginalObject', false);\n    return pageContext;\n}\n","export { findPageConfig };\nimport { assert } from '../utils.js';\nfunction findPageConfig(pageConfigs, pageId) {\n    const result = pageConfigs.filter((p) => p.pageId === pageId);\n    assert(result.length <= 1);\n    const pageConfig = result[0] ?? null;\n    return pageConfig;\n}\n","export { loadAndParseVirtualFilePageEntry };\nimport { assert, objectAssign } from '../utils.js';\nimport { parseConfigValuesSerialized } from './serialize/parsePageConfigsSerialized.js';\nasync function loadAndParseVirtualFilePageEntry(pageConfig, isDev) {\n    if ('isPageEntryLoaded' in pageConfig &&\n        // We don't need to cache in dev, since Vite already caches the virtual module\n        !isDev) {\n        return pageConfig;\n    }\n    const { moduleId, moduleExportsPromise } = pageConfig.loadVirtualFilePageEntry();\n    const virtualFileExportsPageEntry = await moduleExportsPromise;\n    // `configValuesLoaded` is sometimes `undefined` https://github.com/vikejs/vike/discussions/2092\n    if (!virtualFileExportsPageEntry)\n        assert(false, { moduleExportsPromise, virtualFileExportsPageEntry, moduleId });\n    const configValues = parseVirtualFileExportsPageEntry(virtualFileExportsPageEntry);\n    Object.assign(pageConfig.configValues, configValues);\n    objectAssign(pageConfig, { isPageEntryLoaded: true });\n    return pageConfig;\n}\nfunction parseVirtualFileExportsPageEntry(virtualFileExportsPageEntry) {\n    const configValues = parseConfigValuesSerialized(virtualFileExportsPageEntry.configValuesSerialized);\n    return configValues;\n}\n","export { loadPageConfigsLazyClientSide };\nexport { isErrorFetchingStaticAssets };\nimport { getPageFilesClientSide } from '../../shared/getPageFiles.js';\nimport { resolvePageContextConfig } from '../../shared/page-configs/resolveVikeConfigPublic.js';\nimport { findPageConfig } from '../../shared/page-configs/findPageConfig.js';\nimport { loadAndParseVirtualFilePageEntry } from '../../shared/page-configs/loadAndParseVirtualFilePageEntry.js';\nimport { objectAssign } from '../runtime-server-routing/utils.js';\nconst errStamp = '_isAssetsError';\nasync function loadPageConfigsLazyClientSide(pageId, pageFilesAll, pageConfigs, pageConfigGlobal) {\n    const pageFilesClientSide = getPageFilesClientSide(pageFilesAll, pageId);\n    const pageConfig = findPageConfig(pageConfigs, pageId);\n    let pageConfigLoaded;\n    try {\n        // prettier-ignore\n        // biome-ignore format:\n        const result = await Promise.all([\n            pageConfig && loadAndParseVirtualFilePageEntry(pageConfig, import.meta.env.DEV),\n            ...pageFilesClientSide.map((p) => p.loadFile?.()),\n        ]);\n        pageConfigLoaded = result[0];\n    }\n    catch (err) {\n        if (isFetchError(err)) {\n            Object.assign(err, { [errStamp]: true });\n        }\n        else {\n            // Syntax error in user file\n        }\n        throw err;\n    }\n    const pageContextAddendum = {};\n    objectAssign(pageContextAddendum, resolvePageContextConfig(pageFilesClientSide, pageConfigLoaded, pageConfigGlobal));\n    objectAssign(pageContextAddendum, { _pageFilesLoaded: pageFilesClientSide });\n    return pageContextAddendum;\n}\nfunction isErrorFetchingStaticAssets(err) {\n    if (!err) {\n        return false;\n    }\n    return err[errStamp] === true;\n}\n// https://stackoverflow.com/questions/75928310/how-to-detect-that-import-some-url-failed-because-some-url-isnt-a-javasc\nfunction isFetchError(err) {\n    if (!(err instanceof Error))\n        return false;\n    // https://github.com/stacks-network/clarity-js-sdk/blob/e757666b59af00b5db04dd1bf0df016e3a459ea2/packages/clarity/src/providers/registry.ts#L40-L45\n    // https://github.com/modernweb-dev/web/blob/0a59b56e4c1b50af81fbf4588f36a1ceb71f3976/integration/test-runner/tests/test-failure/runTestFailureTest.ts#L11-L18\n    const FAILED_TO_FETCH_MESSAGES = [\n        // chromium\n        'Failed to fetch dynamically imported module',\n        // firefox\n        'error loading dynamically imported module',\n        // safari\n        'Importing a module script failed',\n        // ??\n        'error resolving module specifier',\n        // ??\n        'failed to resolve module',\n    ];\n    return FAILED_TO_FETCH_MESSAGES.some((s) => err.message.toLowerCase().includes(s.toLowerCase()));\n}\n","export { normalizeClientSideUrl };\nimport { assert, parseUrl } from './utils.js';\n/** Resolves relative URLs */\nfunction normalizeClientSideUrl(url, options) {\n    // This function doesn't work for `url === '#some-hash'` because `searchOriginal` will be missing: if window.location.href has a search string then it's going to be missing in the returned `urlCurrent` value because `parseUrl(url)` returns `searchOriginal: null` since there isn't any search string in `url`.\n    // - Maybe `const { searchOriginal } = parseUrl(window.location.href)` can be a fix. (Let's check how `normalizeClientSideUrl()` is being used.)\n    assert(!url.startsWith('#'));\n    const { searchOriginal, hashOriginal, pathname } = parseUrl(url, '/');\n    let urlCurrent = `${pathname}${searchOriginal || ''}`;\n    if (!options?.withoutHash)\n        urlCurrent += hashOriginal || '';\n    assert(urlCurrent.startsWith('/'));\n    return urlCurrent;\n}\n","export { isLinkSkipped };\nexport { isLinkIgnored };\nexport { isHrefCurrentUrl };\nimport { normalizeClientSideUrl } from '../shared/normalizeClientSideUrl.js';\nimport { getBaseServer } from './getBaseServer.js';\nimport { assert, parseUrl, isBaseServer, isUrl, isUrlExternal } from './utils.js';\nfunction isLinkSkipped(linkTag) {\n    const href = linkTag.getAttribute('href');\n    return (href === null ||\n        !isUrl(href) ||\n        href === '' ||\n        isUrlExternal(href) ||\n        isHrefSamePageHash(href) ||\n        isLinkExternal(linkTag) ||\n        isLinkIgnored(linkTag) ||\n        !hasBaseServer(href) ||\n        // Purposely last because disableAutomaticLinkInterception will be removed in the next major release\n        !isVikeLink(linkTag));\n}\n// TO-DO/next-major-release: remove this in favor of synchronously checking whether URL matches the route of a page (possible since Async Route Functions will be deprecated)\nfunction isVikeLink(linkTag) {\n    const disableAutomaticLinkInterception = isDisableAutomaticLinkInterception();\n    if (!disableAutomaticLinkInterception) {\n        return true;\n    }\n    else {\n        const attrVal = linkTag.getAttribute('data-vike-link');\n        return attrVal !== null && attrVal !== 'false';\n    }\n}\nfunction isLinkExternal(linkTag) {\n    const target = linkTag.getAttribute('target');\n    const rel = linkTag.getAttribute('rel');\n    return target === '_blank' || target === '_external' || rel === 'external' || linkTag.hasAttribute('download');\n}\nfunction isLinkIgnored(linkTag) {\n    return linkTag.getAttribute('data-vike') === 'false';\n}\nfunction isHrefSamePageHash(href) {\n    if (href.startsWith('#'))\n        return true;\n    if (href.includes('#') &&\n        normalizeClientSideUrl(href, { withoutHash: true }) ===\n            normalizeClientSideUrl(window.location.href, { withoutHash: true })) {\n        return true;\n    }\n    return false;\n}\nfunction isHrefCurrentUrl(href) {\n    if (href.startsWith('#'))\n        return href === window.location.hash;\n    return normalizeClientSideUrl(href) === normalizeClientSideUrl(window.location.href);\n}\nfunction hasBaseServer(href) {\n    const baseServer = getBaseServer();\n    assert(isBaseServer(baseServer));\n    const { isBaseMissing } = parseUrl(href, baseServer);\n    return !isBaseMissing;\n}\nfunction isDisableAutomaticLinkInterception() {\n    // @ts-ignore\n    return !!window._disableAutomaticLinkInterception;\n    /* globalObject should be used if we want to make disableAutomaticLinkInterception a page-by-page setting\n    return globalObject.disableAutomaticLinkInterception ?? false\n    */\n}\n","export { getExportNames };\nimport { assert } from '../../utils.js';\nfunction getExportNames(p) {\n    if (p.fileType === '.css') {\n        return [];\n    }\n    if (p.exportNames) {\n        return p.exportNames;\n    }\n    assert(p.fileExports, p.filePath);\n    const exportNames = Object.keys(p.fileExports);\n    return exportNames;\n}\n","export { analyzeExports };\nimport { getExportNames } from './getExportNames.js';\nimport { assertUsage } from '../../utils.js';\n// TO-DO/next-major-release: remove\nfunction analyzeExports({ pageFilesClientSide, pageFilesServerSide, pageId, }) {\n    return { isHtmlOnly: isHtmlOnly(), isClientRouting: isClientRouting() };\n    function isHtmlOnly() {\n        {\n            const hasPageIdIsmrphFile = pageFilesServerSide.some((p) => p.pageId === pageId && p.fileType === '.page');\n            if (hasPageIdIsmrphFile) {\n                assertClientSideRenderHook();\n                return false;\n            }\n        }\n        {\n            const hasPageIdServerFile = pageFilesServerSide.some((p) => p.pageId === pageId && p.fileType === '.page.server');\n            if (!hasPageIdServerFile) {\n                return false;\n            }\n        }\n        {\n            const definesClientRenderer = pageFilesClientSide.some((p) => p.pageId === pageId && p.fileType === '.page.client' && getExportNames(p).includes('render'));\n            if (definesClientRenderer) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function assertClientSideRenderHook() {\n        const hasClientSideRenderHook = pageFilesClientSide.some((p) => {\n            return getExportNames(p).includes('render');\n        });\n        assertUsage(hasClientSideRenderHook, [\n            'No client-side `render()` hook found.',\n            'See https://vike.dev/render-modes for more information.',\n            [\n                'Loaded client-side page files (none of them `export { render }`):',\n                ...pageFilesClientSide.map((p, i) => ` (${i + 1}): ${p.filePath}`),\n            ].join('\\n'),\n        ].join(' '));\n    }\n    function isClientRouting() {\n        const hasClientRoutingExport = pageFilesClientSide.some((p) => {\n            return getExportNames(p).includes('clientRouting');\n        });\n        return hasClientRoutingExport;\n    }\n}\n","export { analyzePageClientSide };\nexport { analyzePageClientSideInit };\nimport { analyzeExports } from './analyzePageClientSide/analyzeExports.js';\nimport { determineClientEntry } from './analyzePageClientSide/determineClientEntry.js';\nimport { getPageFilesClientSide } from './getAllPageIdFiles.js';\nimport { getPageFilesServerSide } from './getAllPageIdFiles.js';\nimport { assert } from '../utils.js';\nimport { getExportNames } from './analyzePageClientSide/getExportNames.js';\n// TO-DO/next-major-release: remove analyzePageClientSide(), use analyzeClientSide() instead\nfunction analyzePageClientSide(pageFilesAll, pageId) {\n    let pageFilesClientSide = getPageFilesClientSide(pageFilesAll, pageId);\n    const pageFilesServerSide = getPageFilesServerSide(pageFilesAll, pageId);\n    const { isHtmlOnly, isClientRouting } = analyzeExports({ pageFilesClientSide, pageFilesServerSide, pageId });\n    if (isHtmlOnly) {\n        // HTML-only pages don't need any client-side `render()` hook. For apps that have both HTML-only and SSR/SPA pages, we skip the `.page.client.js` file that defines `render()` for HTML-only pages.\n        pageFilesClientSide = pageFilesClientSide.filter((p) => p.isEnv('CLIENT_ONLY') && !getExportNames(p).includes('render'));\n        pageFilesClientSide = removeOverriddenPageFiles(pageFilesClientSide);\n    }\n    const { clientEntries, clientDependencies } = determineClientEntry({\n        pageFilesClientSide,\n        pageFilesServerSide,\n        isHtmlOnly,\n        isClientRouting,\n    });\n    return { isHtmlOnly, isClientRouting, clientEntries, clientDependencies, pageFilesClientSide, pageFilesServerSide };\n}\n// TO-DO/next-major-release: remove\nasync function analyzePageClientSideInit(pageFilesAll, pageId, { sharedPageFilesAlreadyLoaded }) {\n    const pageFilesClientSide = getPageFilesClientSide(pageFilesAll, pageId);\n    await Promise.all(pageFilesClientSide.map(async (p) => {\n        assert(p.isEnv('CLIENT_ONLY') || p.isEnv('CLIENT_AND_SERVER'));\n        if (sharedPageFilesAlreadyLoaded && p.isEnv('CLIENT_AND_SERVER')) {\n            return;\n        }\n        await p.loadExportNames?.();\n        /*\n        if (pageFile.exportNames) {\n          return pageFile.exportNames.includes(clientRouting)\n        }\n        if (pageFile.fileExports) {\n          return Object.keys(pageFile.fileExports).includes(clientRouting)\n        }\n        */\n    }));\n}\n// [WIP] Just an experiment needed by https://vike.dev/banner\n//  - Not sure I want to make something like a public API: the CSS of `_default.page.server.js` are still loaded -> weird DX.\nfunction removeOverriddenPageFiles(pageFilesClientSide) {\n    const pageFilesClientSide_ = [];\n    for (const p of pageFilesClientSide) {\n        pageFilesClientSide_.push(p);\n        if (getExportNames(p).includes('overrideDefaultPages')) {\n            break;\n        }\n    }\n    return pageFilesClientSide_;\n}\n","// TO-DO/next-major-release: remove\nexport { determineClientEntry };\nexport { getVikeClientEntry };\nfunction determineClientEntry({ pageFilesClientSide, pageFilesServerSide, isHtmlOnly, isClientRouting, }) {\n    let clientEntries = [];\n    const pageFilesServerSideOnly = pageFilesServerSide.filter((p) => !pageFilesClientSide.includes(p));\n    const clientDependencies = [];\n    clientDependencies.push(...pageFilesClientSide.map((p) => ({ id: p.filePath, onlyAssets: false, eagerlyImported: false })));\n    // CSS & assets\n    clientDependencies.push(...pageFilesServerSideOnly.map((p) => ({ id: p.filePath, onlyAssets: true, eagerlyImported: false })));\n    // Handle SPA & SSR pages.\n    if (isHtmlOnly) {\n        clientEntries = pageFilesClientSide.map((p) => p.filePath);\n    }\n    else {\n        // Add the vike client entry\n        const clientEntry = getVikeClientEntry(isClientRouting);\n        clientDependencies.push({ id: clientEntry, onlyAssets: false, eagerlyImported: false });\n        clientEntries = [clientEntry];\n    }\n    // console.log(pageFilesClientSide, pageFilesServerSide, clientDependencies, clientEntry)\n    return { clientEntries, clientDependencies };\n}\nfunction getVikeClientEntry(isClientRouting) {\n    return isClientRouting\n        ? '@@vike/dist/esm/client/runtime-client-routing/entry.js'\n        : '@@vike/dist/esm/client/runtime-server-routing/entry.js';\n}\n","export { isClientSideRoutable };\nimport { analyzePageClientSideInit } from '../../shared/getPageFiles/analyzePageClientSide.js';\nimport { findPageConfig } from '../../shared/page-configs/findPageConfig.js';\nimport { analyzeClientSide } from '../../shared/getPageFiles/analyzeClientSide.js';\n// TO-DO/next-major-release: make it sync\nasync function isClientSideRoutable(pageId, pageContext) {\n    await analyzePageClientSideInit(pageContext._pageFilesAll, pageId, {\n        sharedPageFilesAlreadyLoaded: false,\n    });\n    const pageConfig = findPageConfig(pageContext._globalContext._pageConfigs, pageId);\n    const { isClientRuntimeLoaded, isClientRouting } = analyzeClientSide(pageConfig, pageContext._pageFilesAll, pageId);\n    return isClientRuntimeLoaded && isClientRouting;\n}\n","export { analyzeClientSide };\nimport { getConfigValueRuntime } from '../page-configs/getConfigValueRuntime.js';\nimport { analyzePageClientSide } from './analyzePageClientSide.js';\nfunction analyzeClientSide(pageConfig, pageFilesAll, pageId) {\n    // V1 design\n    if (pageConfig) {\n        const isClientRouting = getConfigValueRuntime(pageConfig, 'clientRouting', 'boolean')?.value ?? false;\n        const isClientRuntimeLoaded = getConfigValueRuntime(pageConfig, 'isClientRuntimeLoaded', 'boolean')?.value ?? false;\n        return { isClientRuntimeLoaded, isClientRouting };\n    }\n    else {\n        // TO-DO/next-major-release: remove\n        // V0.4 design\n        const { isHtmlOnly, isClientRouting } = analyzePageClientSide(pageFilesAll, pageId);\n        return { isClientRuntimeLoaded: !isHtmlOnly, isClientRouting };\n    }\n}\n","export { resolveRouteString };\nexport { getUrlFromRouteString };\nexport { isStaticRouteString };\nexport { analyzeRouteString };\nexport { assertRouteString };\nexport { getRouteStringParameterList };\nimport { assertWarning, isBrowser, escapeRegex } from '../utils.js';\nimport { assert, assertUsage } from './utils.js';\nimport pc from '@brillout/picocolors';\nconst PARAM_TOKEN_NEW = '@';\n// TO-DO/next-major-release: remove\nconst PARAM_TOKEN_OLD = ':';\nfunction assertRouteString(routeString, errPrefix = 'Invalid') {\n    let errPrefix2 = `${errPrefix} Route String ${highlight(routeString)}`;\n    assertUsage(routeString !== '', `${errPrefix2} (empty string): set it to ${highlight('/')} instead`);\n    assertUsage(['/', '*'].includes(routeString[0]), `${errPrefix2}: it should start with ${highlight('/')} or ${highlight('*')}`);\n    assertUsage(!routeString.includes('**'), `${errPrefix2}: set it to ${highlight(routeString.split('**').join('*'))} instead`);\n}\nfunction resolveRouteString(routeString, urlPathname) {\n    assertRouteString(routeString);\n    const segments = parseRouteString(routeString);\n    const routeRegexStrInner = segments\n        .map((segment) => {\n        if (segment.param) {\n            return '[^/]+';\n        }\n        if (segment.glob) {\n            return '.*';\n        }\n        // segment.static\n        return escapeRegex(segment.static);\n    })\n        .map((s) => `(${s})`)\n        .join('');\n    const routeRegex = new RegExp(`^${routeRegexStrInner}/?$`);\n    const routeRegexMatch = urlPathname.match(routeRegex);\n    /* DEBUG\n    console.log()\n    console.log('routeString', routeString)\n    console.log('urlPathname', urlPathname)\n    console.log('routeSegments', segments)\n    console.log('routeRegex', routeRegex)\n    console.log('routeRegexMatch', routeRegexMatch)\n    //*/\n    if (!routeRegexMatch)\n        return null;\n    const routeParams = {};\n    const [_, ...segmentsValue] = routeRegexMatch;\n    let globIdx = 0;\n    const hasMultipleGlobs = segments.filter((segment) => segment.glob).length > 1;\n    segments.forEach((segment, i) => {\n        let val = segmentsValue[i];\n        if (segment.param) {\n            routeParams[segment.param] = val;\n        }\n        if (segment.glob) {\n            const param = `*${hasMultipleGlobs ? ++globIdx : ''}`;\n            routeParams[param] = val;\n        }\n    });\n    return { routeParams };\n}\nfunction parseRouteString(routeString) {\n    const segments = [];\n    const pushStatic = (s) => {\n        const segmentLast = segments[segments.length - 1];\n        if (segmentLast?.static) {\n            segmentLast.static += s;\n        }\n        else {\n            segments.push({ static: s });\n        }\n    };\n    const parts = routeString.split('/');\n    parts.forEach((s, i) => {\n        if (i !== 0)\n            pushStatic('/');\n        if (isParam(s)) {\n            assertWarning(!s.startsWith(PARAM_TOKEN_OLD), `Outdated Route String ${highlight(routeString)}, use ${highlight(routeString.split(PARAM_TOKEN_OLD).join(PARAM_TOKEN_NEW))} instead`, { onlyOnce: true });\n            segments.push({ param: s.slice(1) });\n        }\n        else {\n            if (s === '*' && i === parts.length - 1 && routeString !== '*' && routeString !== '/*') {\n                segments.push({ glob: true });\n            }\n            else {\n                s.split('*').forEach((s, i) => {\n                    if (i !== 0)\n                        segments.push({ glob: true });\n                    if (s !== '') {\n                        pushStatic(s);\n                    }\n                });\n            }\n        }\n    });\n    return segments;\n}\nfunction getRouteStringParameterList(routeString) {\n    const routeParameterList = [];\n    const segments = parseRouteString(routeString);\n    segments.forEach((segment) => {\n        if (segment.param)\n            routeParameterList.push(segment.param);\n    });\n    return routeParameterList;\n}\nfunction getUrlFromRouteString(routeString) {\n    if (isStaticRouteString(routeString)) {\n        const url = routeString;\n        return url;\n    }\n    return null;\n}\nfunction analyzeRouteString(routeString) {\n    const segments = parseRouteString(routeString);\n    const countStaticParts = (s) => s?.split('/').filter(Boolean).length || 0;\n    let numberOfStaticPartsBeginning = 0;\n    for (const segment of segments) {\n        if (!segment.static)\n            break;\n        numberOfStaticPartsBeginning += countStaticParts(segment.static);\n    }\n    const numberOfStaticParts = segments.map((s) => countStaticParts(s.static)).reduce((sum, a) => sum + a, 0);\n    const numberOfParams = segments.filter((s) => s.param).length;\n    const numberOfGlobs = segments.filter((s) => s.glob).length;\n    return { numberOfStaticPartsBeginning, numberOfStaticParts, numberOfParams, numberOfGlobs };\n}\nfunction isParam(routeSegment) {\n    return routeSegment.startsWith(PARAM_TOKEN_NEW) || routeSegment.startsWith(PARAM_TOKEN_OLD);\n}\nfunction isStaticRouteString(routeString) {\n    const url = routeString;\n    const match = resolveRouteString(routeString, url);\n    assert(match);\n    return Object.keys(match.routeParams).length === 0;\n}\nfunction highlight(routeString) {\n    if (isBrowser()) {\n        return `'${routeString}'`;\n    }\n    else {\n        if (routeString === '') {\n            routeString = \"''\";\n        }\n        return pc.cyan(routeString);\n    }\n}\n","export function escapeRegex(str) {\n    // https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript/3561711#3561711\n    return str.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n","export { resolvePrecedence };\n// export type { RouteMatch }\nimport { analyzeRouteString } from './resolveRouteString.js';\nimport { higherFirst, lowerFirst } from './utils.js';\nimport { makeFirst } from './utils.js';\nimport { isStaticRouteString } from './resolveRouteString.js';\n// See https://vike.dev/route-function#precedence\nfunction resolvePrecedence(routeMatches) {\n    // prettier-ignore\n    // biome-ignore format:\n    routeMatches\n        .sort(sortMatches)\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !!routeMatch.precedence && routeMatch.precedence < 0))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'STRING' && isStaticRouteString(routeMatch.routeString) === false))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !routeMatch.precedence))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'STRING' && isStaticRouteString(routeMatch.routeString) === true))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FILESYSTEM'))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !!routeMatch.precedence && routeMatch.precedence > 0));\n}\n// -1 => routeMatch1 higher precedence\n// +1 => routeMatch2 higher precedence\nfunction sortMatches(routeMatch1, routeMatch2) {\n    {\n        const precedence1 = routeMatch1.precedence ?? 0;\n        const precedence2 = routeMatch2.precedence ?? 0;\n        if (precedence1 !== precedence2) {\n            return precedence1 > precedence2 ? -1 : 1;\n        }\n    }\n    if (!routeMatch2.routeString) {\n        return 0;\n    }\n    if (!routeMatch1.routeString) {\n        return 0;\n    }\n    /* DEBUG\n    console.log('routeMatch1.routeString', routeMatch1.routeString)\n    console.log('routeMatch2.routeString', routeMatch2.routeString)\n    console.log('parseRouteString(routeMatch1.routeString)', parseRouteString(routeMatch1.routeString))\n    console.log('parseRouteString(routeMatch2.routeString)', parseRouteString(routeMatch2.routeString))\n    //*/\n    // Return route with highest number of static path segments at beginning first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfStaticPartsBeginning;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            /* DEBUG\n            console.log('analyzeRouteString(routeMatch1.routeString).numberOfStaticPartsBeginning', getValue(routeMatch1.routeString))\n            console.log('analyzeRouteString(routeMatch2.routeString).numberOfStaticPartsBeginning', getValue(routeMatch2.routeString))\n            //*/\n            return result;\n        }\n    }\n    // Return route with highest number of static path segments in total first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfStaticParts;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            /* DEBUG\n            console.log('analyzeRouteString(routeMatch1.routeString).numberOfStaticParts', getValue(routeMatch1.routeString))\n            console.log('analyzeRouteString(routeMatch2.routeString).numberOfStaticParts', getValue(routeMatch2.routeString))\n            //*/\n            return result;\n        }\n    }\n    // Return route with least amount of globs first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfGlobs;\n        const result = lowerFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            /* DEBUG\n            console.log('analyzeRouteString(routeMatch1.routeString).numberOfGlobs', getValue(routeMatch1.routeString))\n            console.log('analyzeRouteString(routeMatch2.routeString).numberOfGlobs', getValue(routeMatch2.routeString))\n            //*/\n            return result;\n        }\n    }\n    // Return route with highest number of parameters first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfParams;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            /* DEBUG\n            console.log('analyzeRouteString(routeMatch1.routeString).numberOfParams', getValue(routeMatch1.routeString))\n            console.log('analyzeRouteString(routeMatch2.routeString).numberOfParams', getValue(routeMatch2.routeString))\n            //*/\n            return result;\n        }\n    }\n    return 0;\n}\n","export { execHookOnBeforeRoute };\nimport { assertPageContextProvidedByUser } from '../assertPageContextProvidedByUser.js';\nimport { assertUsage, hasProp, isObjectWithKeys, objectAssign, assertWarning, assertUsageUrlAbsolute, joinEnglish, assert, } from './utils.js';\nimport { assertRouteParams, assertSyncRouting } from './resolveRouteFunction.js';\nimport pc from '@brillout/picocolors';\nimport { execHookDirectSync } from '../hooks/execHook.js';\nimport { preparePageContextForPublicUsage, } from '../preparePageContextForPublicUsage.js';\nasync function execHookOnBeforeRoute(pageContext) {\n    const pageContextFromOnBeforeRouteHook = {};\n    if (!pageContext._globalContext._onBeforeRouteHook)\n        return null;\n    const pageContextFromHook = await getPageContextFromHook(pageContext._globalContext._onBeforeRouteHook, pageContext);\n    if (pageContextFromHook) {\n        objectAssign(pageContextFromOnBeforeRouteHook, pageContextFromHook);\n        if (hasProp(pageContextFromOnBeforeRouteHook, 'pageId', 'string') ||\n            hasProp(pageContextFromOnBeforeRouteHook, 'pageId', 'null')) {\n            // We bypass Vike's routing\n            if (!hasProp(pageContextFromOnBeforeRouteHook, 'routeParams')) {\n                objectAssign(pageContextFromOnBeforeRouteHook, { routeParams: {} });\n            }\n            else {\n                assert(hasProp(pageContextFromOnBeforeRouteHook, 'routeParams', 'object'));\n            }\n            objectAssign(pageContextFromOnBeforeRouteHook, {\n                _routingProvidedByOnBeforeRouteHook: true,\n            });\n            return pageContextFromOnBeforeRouteHook;\n        }\n    }\n    objectAssign(pageContextFromOnBeforeRouteHook, {\n        _routingProvidedByOnBeforeRouteHook: false,\n    });\n    return pageContextFromOnBeforeRouteHook;\n}\nasync function getPageContextFromHook(onBeforeRouteHook, pageContext) {\n    let { hookReturn } = execHookDirectSync(onBeforeRouteHook, pageContext, preparePageContextForPublicUsage);\n    assertSyncRouting(hookReturn, `The onBeforeRoute() hook ${onBeforeRouteHook.hookFilePath}`);\n    // TO-DO/next-major-release: make execHookOnBeforeRoute() and route() sync\n    hookReturn = await hookReturn;\n    const errPrefix = `The onBeforeRoute() hook defined by ${onBeforeRouteHook.hookFilePath}`;\n    assertUsage(hookReturn === null ||\n        hookReturn === undefined ||\n        (isObjectWithKeys(hookReturn, ['pageContext']) && hasProp(hookReturn, 'pageContext')), `${errPrefix} should return ${pc.cyan('null')}, ${pc.cyan('undefined')}, or a plain JavaScript object ${pc.cyan('{ pageContext: { /* ... */ } }')}`);\n    if (hookReturn === null || hookReturn === undefined) {\n        return null;\n    }\n    assertUsage(hasProp(hookReturn, 'pageContext', 'object'), `${errPrefix} returned ${pc.cyan('{ pageContext }')} but pageContext should be a plain JavaScript object.`);\n    if (hasProp(hookReturn.pageContext, 'pageId') && !hasProp(hookReturn.pageContext, 'pageId', 'null')) {\n        const errPrefix2 = `${errPrefix} returned ${pc.cyan('{ pageContext: { pageId } }')} but ${pc.cyan('pageId')} should be`;\n        assertUsage(hasProp(hookReturn.pageContext, 'pageId', 'string'), `${errPrefix2} a string or null`);\n        assertUsage(pageContext._globalContext._allPageIds.includes(hookReturn.pageContext.pageId), `${errPrefix2} ${joinEnglish(pageContext._globalContext._allPageIds.map((s) => pc.cyan(s)), 'or')}`);\n    }\n    if (hasProp(hookReturn.pageContext, 'routeParams')) {\n        assertRouteParams(hookReturn.pageContext, `${errPrefix} returned ${pc.cyan('{ pageContext: { routeParams } }')} but routeParams should`);\n    }\n    const deprecatedReturn = (prop) => `${errPrefix} returned ${pc.cyan(`{ pageContext: { ${prop} } }`)} which is deprecated. Return ${pc.cyan('{ pageContext: { urlLogical } }')} instead.`;\n    if (hasProp(hookReturn.pageContext, 'url')) {\n        assertWarning(false, deprecatedReturn('url'), { onlyOnce: true });\n        hookReturn.pageContext.urlLogical = hookReturn.pageContext.url;\n        delete hookReturn.pageContext.url;\n    }\n    if (hasProp(hookReturn.pageContext, 'urlOriginal')) {\n        assertWarning(false, deprecatedReturn('urlOriginal'), { onlyOnce: true });\n        hookReturn.pageContext.urlLogical = hookReturn.pageContext.urlOriginal;\n        delete hookReturn.pageContext.urlOriginal;\n    }\n    if (hasProp(hookReturn.pageContext, 'urlLogical')) {\n        assertUsageUrlAbsolute(\n        // We type-cast instead of assertUsage() validation in order to save client-side KBs\n        hookReturn.pageContext.urlLogical, `${errPrefix} returned ${pc.cyan('{ pageContext: { urlLogical } }')} and ${pc.cyan('urlLogical')}`);\n    }\n    assertPageContextProvidedByUser(hookReturn.pageContext, {\n        hookFilePath: onBeforeRouteHook.hookFilePath,\n        hookName: 'onBeforeRoute',\n    });\n    const pageContextAddendumHook = {};\n    objectAssign(pageContextAddendumHook, hookReturn.pageContext);\n    return pageContextAddendumHook;\n}\n","import { isPlainObject } from './isPlainObject.js';\nexport { isObjectWithKeys };\nfunction isObjectWithKeys(obj, keys) {\n    if (!isPlainObject(obj)) {\n        return false;\n    }\n    for (const key of Object.keys(obj)) {\n        if (!keys.includes(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n","export { joinEnglish };\nimport { assert } from './assert.js';\n// https://stackoverflow.com/questions/53879088/join-an-array-by-commas-and-and/53879103#53879103\nfunction joinEnglish(arr, conjunction, colorizer = (s) => s) {\n    assert(arr.length > 0);\n    if (arr.length === 1)\n        return colorizer(arr[0]);\n    const firsts = arr.slice(0, arr.length - 1);\n    const last = arr[arr.length - 1];\n    const lastComma = arr.length > 2 ? ',' : '';\n    return firsts.map(colorizer).join(', ') + `${lastComma} ${conjunction} ` + colorizer(last);\n}\n","export { route };\n// Ensure we don't bloat runtime of Server Routing\nimport { assertClientRouting } from '../../utils/assertRoutingType.js';\nimport { isBrowser } from '../../utils/isBrowser.js';\nif (isBrowser()) {\n    assertClientRouting();\n}\nimport { assert, assertUsage, isPlainObject, objectAssign, debug } from './utils.js';\nimport { resolvePrecedence } from './resolvePrecedence.js';\nimport { resolveRouteString } from './resolveRouteString.js';\nimport { resolveRouteFunction } from './resolveRouteFunction.js';\nimport { execHookOnBeforeRoute } from './execHookOnBeforeRoute.js';\nimport pc from '@brillout/picocolors';\n// TO-DO/next-major-release: make it sync\nasync function route(pageContext, skipOnBeforeRouteHook) {\n    const pageContextFromRoute = {};\n    if (\n    // Tree-shaking to save client-side KBs\n    !globalThis.__VIKE__IS_CLIENT ||\n        globalThis.__VIKE__IS_DEBUG) {\n        debug('vike:routing', 'Pages routes:', pageContext._globalContext._pageRoutes);\n    }\n    // onBeforeRoute()\n    if (!skipOnBeforeRouteHook) {\n        const pageContextFromOnBeforeRouteHook = await execHookOnBeforeRoute(pageContext);\n        if (pageContextFromOnBeforeRouteHook) {\n            if (pageContextFromOnBeforeRouteHook._routingProvidedByOnBeforeRouteHook) {\n                assert(pageContextFromOnBeforeRouteHook.pageId);\n                return pageContextFromOnBeforeRouteHook;\n            }\n            else {\n                objectAssign(pageContextFromRoute, pageContextFromOnBeforeRouteHook);\n            }\n        }\n        // We take into account pageContext.urlLogical set by onBeforeRoute()\n        objectAssign(pageContext, pageContextFromOnBeforeRouteHook);\n    }\n    // Vike's routing\n    const allPageIds = pageContext._globalContext._allPageIds;\n    assertUsage(allPageIds.length > 0, 'No page found. You must create at least one page.');\n    assert(pageContext._globalContext._pageFilesAll.length > 0 || pageContext._globalContext._pageConfigs.length > 0);\n    const { urlPathname } = pageContext;\n    assert(urlPathname.startsWith('/'));\n    const routeMatches = [];\n    await Promise.all(pageContext._globalContext._pageRoutes.map(async (pageRoute) => {\n        const { pageId, routeType } = pageRoute;\n        // Filesystem Routing\n        if (pageRoute.routeType === 'FILESYSTEM') {\n            const { routeString } = pageRoute;\n            const match = resolveRouteString(routeString, urlPathname);\n            if (match) {\n                const { routeParams } = match;\n                routeMatches.push({ pageId, routeParams, routeString, routeType });\n            }\n            return;\n        }\n        // Route String defined in `.page.route.js`\n        if (pageRoute.routeType === 'STRING') {\n            const { routeString } = pageRoute;\n            const match = resolveRouteString(routeString, urlPathname);\n            if (match) {\n                const { routeParams } = match;\n                assert(routeType === 'STRING');\n                routeMatches.push({\n                    pageId,\n                    routeString,\n                    routeParams,\n                    routeType,\n                });\n            }\n            return;\n        }\n        // Route Function defined in `.page.route.js`\n        if (pageRoute.routeType === 'FUNCTION') {\n            const { routeFunction, routeFunctionFilePath } = pageRoute;\n            const match = await resolveRouteFunction(routeFunction, pageContext, routeFunctionFilePath);\n            if (match) {\n                const { routeParams, precedence } = match;\n                routeMatches.push({ pageId, precedence, routeParams, routeType });\n            }\n            return;\n        }\n        assert(false);\n    }));\n    resolvePrecedence(routeMatches);\n    const winner = routeMatches[0] ?? null;\n    if (\n    // Tree-shaking to save client-side KBs\n    !globalThis.__VIKE__IS_CLIENT ||\n        globalThis.__VIKE__IS_DEBUG) {\n        debug('vike:routing', `Route matches for URL ${pc.cyan(urlPathname)} (in precedence order):`, routeMatches);\n    }\n    // For vite-plugin-vercel https://github.com/magne4000/vite-plugin-vercel/blob/main/packages/vike-integration/vike.ts#L173\n    objectAssign(pageContextFromRoute, { _routeMatch: winner });\n    if (!winner) {\n        objectAssign(pageContextFromRoute, {\n            pageId: null,\n            routeParams: {},\n        });\n        return pageContextFromRoute;\n    }\n    {\n        const { routeParams } = winner;\n        assert(isPlainObject(routeParams));\n        objectAssign(pageContextFromRoute, {\n            pageId: winner.pageId,\n            routeParams: winner.routeParams,\n        });\n    }\n    return pageContextFromRoute;\n}\n","export { setPageContextCurrent };\nexport { getPageContextCurrent };\nimport { getGlobalObject } from './utils.js';\nconst globalObject = getGlobalObject('runtime-client-routing/getPageContextCurrent.ts', {\n    pageContextCurrent: null,\n});\nfunction getPageContextCurrent() {\n    const { pageContextCurrent } = globalObject;\n    return pageContextCurrent;\n}\nfunction setPageContextCurrent(pageContextCurrent) {\n    globalObject.pageContextCurrent = pageContextCurrent;\n}\n","// TO-DO/pageContext-prefetch: rename this file to getPrefetchSettingResolved.ts\nexport { getPrefetchSettings };\nexport { PAGE_CONTEXT_MAX_AGE_DEFAULT };\nimport { assertUsage, assertInfo } from '../utils.js';\n// TO-DO/pageContext-prefetch: Make it `Infinity` for pre-rendered pages.\nconst PAGE_CONTEXT_MAX_AGE_DEFAULT = 5000;\nconst prefetchSettingTrue = {\n    staticAssets: 'hover',\n    pageContext: PAGE_CONTEXT_MAX_AGE_DEFAULT,\n};\nconst prefetchSettingFalse = {\n    staticAssets: 'hover',\n    pageContext: false,\n};\n// TO-DO/eventually: change to `prefetchSettingTrue`\nconst prefetchSettingDefault = prefetchSettingFalse;\nfunction getPrefetchSettings(pageContext, linkTag) {\n    let prefetchSetting = prefetchSettingDefault;\n    // TO-DO/next-major-release: remove\n    if ('prefetchLinks' in pageContext.exports) {\n        assertUsage(false, '`export { prefetchLinks }` is deprecated, use `export { prefetchStaticAssets }` instead.');\n    }\n    // TO-DO/next-major-release: remove\n    if ('prefetchStaticAssets' in pageContext.exports) {\n        const prefetchStaticAssets = pageContext.exports.prefetchStaticAssets;\n        /* TO-DO/pageContext-prefetch: uncomment\n        const msg = `The 'prefetchStaticAssets' setting is deprecated in favor of the 'prefetch' setting, see https://vike.dev/prefetch`\n        assertWarning(false, msg, { onlyOnce: true })\n        assertUsage(\n          prefetchStaticAssets === false || prefetchStaticAssets === 'hover' || prefetchStaticAssets === 'viewport',\n          msg\n        )\n        //*/\n        prefetchSetting.staticAssets = prefetchStaticAssets;\n    }\n    if ('prefetch' in pageContext.exports) {\n        const { prefetch } = pageContext.exports;\n        if (prefetch === true)\n            prefetchSetting = prefetchSettingTrue;\n        if (prefetch === false)\n            prefetchSetting = prefetchSettingFalse;\n        // No validation in order to save client-side KBs\n        Object.assign(prefetchSetting, prefetch);\n        if (prefetchSetting.pageContext === true) {\n            prefetchSetting.pageContext = PAGE_CONTEXT_MAX_AGE_DEFAULT;\n        }\n    }\n    if (prefetchSetting.staticAssets === 'viewport' && import.meta.env.DEV) {\n        assertInfo(false, 'Viewport prefetching is disabled in development', { onlyOnce: true });\n        prefetchSetting.staticAssets = 'hover';\n    }\n    if (linkTag) {\n        {\n            let attr = linkTag.getAttribute('data-prefetch');\n            if (attr !== null) {\n                if (attr === '')\n                    attr = 'true';\n                if (attr === 'true')\n                    prefetchSetting = prefetchSettingTrue;\n                if (attr === 'false')\n                    prefetchSetting = prefetchSettingFalse;\n            }\n        }\n        {\n            let attr = linkTag.getAttribute('data-prefetch-static-assets');\n            if (attr !== null) {\n                if (attr === 'false')\n                    prefetchSetting.staticAssets = false;\n                // No validation in order to save client-side KBs\n                prefetchSetting.staticAssets = attr;\n            }\n        }\n        {\n            let attr = linkTag.getAttribute('data-prefetch-page-context');\n            if (attr !== null) {\n                if (attr === '')\n                    attr = 'true';\n                if (attr === 'true')\n                    prefetchSetting.pageContext = PAGE_CONTEXT_MAX_AGE_DEFAULT;\n                if (attr === 'false')\n                    prefetchSetting.pageContext = false;\n                const n = parseInt(attr, 10);\n                if (!Number.isNaN(n))\n                    prefetchSetting.pageContext = n;\n                // No validation in order to save client-side KBs\n            }\n        }\n    }\n    return prefetchSetting;\n}\n","export { prefetch };\nexport { getPageContextPrefetched };\nexport { initLinkPrefetchHandlers };\nexport { populatePageContextPrefetchCache };\nexport { addLinkPrefetchHandlers };\nexport { addLinkPrefetchHandlers_watch };\nexport { addLinkPrefetchHandlers_unwatch };\nimport { assert, assertClientRouting, assertUsage, assertWarning, checkIfClientRouting, getGlobalObject, hasProp, objectAssign, } from './utils.js';\nimport { isErrorFetchingStaticAssets, loadPageConfigsLazyClientSide } from '../shared/loadPageConfigsLazyClientSide.js';\nimport { isLinkSkipped } from './isLinkSkipped.js';\nimport { disableClientRouting } from './renderPageClientSide.js';\nimport { isClientSideRoutable } from './isClientSideRoutable.js';\nimport { createPageContextClientSide } from './createPageContextClientSide.js';\nimport { route } from '../../shared/route/index.js';\nimport { noRouteMatch } from '../../shared/route/noRouteMatch.js';\nimport { getPageContextFromServerHooks } from './getPageContextFromHooks.js';\nimport { getPageContextCurrent } from './getPageContextCurrent.js';\nimport { PAGE_CONTEXT_MAX_AGE_DEFAULT, getPrefetchSettings, } from './prefetch/getPrefetchSettings.js';\nimport pc from '@brillout/picocolors';\nimport { normalizeUrlArgument } from './normalizeUrlArgument.js';\nassertClientRouting();\nconst globalObject = getGlobalObject('runtime-client-routing/prefetch.ts', {\n    linkPrefetchHandlerAdded: new WeakSet(),\n    addLinkPrefetchHandlers_debounce: null,\n    mutationObserver: new MutationObserver(addLinkPrefetchHandlers),\n    // `linkTags` [is automatically updated](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection#:~:text=An%20HTMLCollection%20in%20the%20HTML%20DOM%20is%20live%3B%20it%20is%20automatically%20updated%20when%20the%20underlying%20document%20is%20changed.)\n    linkTags: document.getElementsByTagName('A'),\n    prefetchedPageContexts: {},\n});\nfunction getPageContextPrefetched(pageContext) {\n    const prefetchSettings = getPrefetchSettings(pageContext, null);\n    // TO-DO/pageContext-prefetch: I guess we need linkTag to make this condition work\n    if (!prefetchSettings.pageContext)\n        return null;\n    const key = getCacheKey(pageContext.urlPathname);\n    const found = globalObject.prefetchedPageContexts[key];\n    if (!found || found.result.is404ServerSideRouted || isExpired(found))\n        return null;\n    const pageContextPrefetched = found.result.pageContextFromServerHooks;\n    /* TO-DO/pageContext-prefetch: make it work for when resultMaxAge is Infinity.\n    // We discard the prefetched pageContext whenever we use it, so that the user always sees fresh data upon naivgating.\n    delete globalObject.prefetchedPageContexts[key]\n    */\n    return pageContextPrefetched;\n}\nasync function prefetchAssets(pageContextLink) {\n    try {\n        await loadPageConfigsLazyClientSide(pageContextLink.pageId, pageContextLink._pageFilesAll, pageContextLink._globalContext._pageConfigs, pageContextLink._globalContext._pageConfigGlobal);\n    }\n    catch (err) {\n        if (isErrorFetchingStaticAssets(err)) {\n            disableClientRouting(err, true);\n        }\n        else {\n            throw err;\n        }\n    }\n}\nasync function prefetchPageContextFromServerHooks(pageContextLink, resultMaxAge) {\n    const result = await getPageContextFromServerHooks(pageContextLink, false);\n    setPageContextPrefetchCache(pageContextLink, result, resultMaxAge);\n}\nfunction populatePageContextPrefetchCache(pageContext /*& PageContextConfig*/, result) {\n    // TO-DO/pageContext-prefetch: replace with using pageContext.config.prerender instead. (For being able to do that: eager configs need to be accessible without have to use PageContextConfig as it isn't available here.)\n    if (!isBrilloutDocpress())\n        return;\n    setPageContextPrefetchCache(pageContext, result, null);\n}\nfunction setPageContextPrefetchCache(pageContext, result, resultMaxAge) {\n    if (resultMaxAge === null)\n        resultMaxAge = getResultMaxAge();\n    const key = getCacheKey(pageContext.urlPathname);\n    assert(isBrilloutDocpress()); // Ensure this API isn't used by anyone else\n    globalObject.prefetchedPageContexts[key] = {\n        resultFetchedAt: Date.now(),\n        resultMaxAge,\n        result,\n    };\n}\nfunction getResultMaxAge() {\n    const pageContextCurrent = getPageContextCurrent();\n    // TO-DO/pageContext-prefetch: remove this dirty hack used by @brillout/docpress and, instead, use Vike's default if pageContextCurrent isn't defined yet.\n    if (!pageContextCurrent)\n        return Infinity;\n    const prefetchSettings = getPrefetchSettings(pageContextCurrent, null);\n    const resultMaxAge = typeof prefetchSettings.pageContext === 'number' ? prefetchSettings.pageContext : PAGE_CONTEXT_MAX_AGE_DEFAULT;\n    return resultMaxAge;\n}\n/**\n * Programmatically prefetch client assets.\n *\n * https://vike.dev/prefetch\n *\n * @param url - The URL of the page you want to prefetch.\n */\nasync function prefetch(url, \n/* TO-DO/pageContext-prefetch:\noptions?: {\n  pageContext?: boolean\n  staticAssets?: boolean\n}\n*/\noptions_) {\n    const options = {\n        staticAssets: true,\n        pageContext: options_?.pageContext ?? false,\n    };\n    assertUsage(checkIfClientRouting(), 'prefetch() only works with Client Routing, see https://vike.dev/prefetch', {\n        showStackTrace: true,\n    });\n    url = normalizeUrlArgument(url, 'prefetch');\n    const pageContextLink = await getPageContextLink(url);\n    if (!pageContextLink?.pageId) {\n        assertWarning(false, `[prefetch(url)] ${pc.string(url)} ${noRouteMatch}`, {\n            showStackTrace: true,\n            onlyOnce: false,\n        });\n        return;\n    }\n    assert(hasProp(pageContextLink, 'pageId', 'string')); // help TypeScript\n    await Promise.all([\n        (async () => {\n            if (options?.staticAssets !== false) {\n                await prefetchAssets(pageContextLink);\n            }\n        })(),\n        (async () => {\n            if (options?.pageContext !== false) {\n                assertUsage(isBrilloutDocpress(), \"prefetching pageContext isn't supported yet\");\n                const resultMaxAge = typeof options?.pageContext === 'number' ? options.pageContext : null;\n                await prefetchPageContextFromServerHooks(pageContextLink, resultMaxAge);\n            }\n        })(),\n    ]);\n}\n// Lazy execution logic copied from: https://github.com/withastro/astro/blob/2594eb088d53a98181ac820243bcb1a765856ecf/packages/astro/src/runtime/client/dev-toolbar/apps/audit/index.ts#L53-L72\nfunction addLinkPrefetchHandlers() {\n    if (globalObject.addLinkPrefetchHandlers_debounce)\n        clearTimeout(globalObject.addLinkPrefetchHandlers_debounce);\n    globalObject.addLinkPrefetchHandlers_debounce = setTimeout(() => {\n        // Wait for the next idle period, as it is less likely to interfere with any other work the browser is doing post-mutation.\n        if ('requestIdleCallback' in window) {\n            requestIdleCallback(addLinkPrefetchHandlers_apply, { timeout: 300 });\n        }\n        else {\n            // Fallback for old versions of Safari, we'll assume that things are less likely to be busy after 150ms.\n            setTimeout(addLinkPrefetchHandlers_apply, 150);\n        }\n    }, 250);\n}\nfunction initLinkPrefetchHandlers() {\n    addLinkPrefetchHandlers();\n}\nfunction addLinkPrefetchHandlers_watch() {\n    // Notes about performance:\n    // - https://stackoverflow.com/questions/31659567/performance-of-mutationobserver-to-detect-nodes-in-entire-dom/39332340#39332340\n    // - https://news.ycombinator.com/item?id=15274211\n    //   - https://github.com/kubetail-org/sentineljs\n    // - https://stackoverflow.com/questions/55046093/listening-for-changes-in-htmlcollection-or-achieving-a-similar-effect\n    globalObject.mutationObserver.observe(document.body, {\n        childList: true,\n        subtree: true,\n    });\n}\nfunction addLinkPrefetchHandlers_unwatch() {\n    globalObject.mutationObserver.disconnect();\n}\nfunction addLinkPrefetchHandlers_apply() {\n    for (let linkTag of globalObject.linkTags) {\n        if (globalObject.linkPrefetchHandlerAdded.has(linkTag))\n            continue;\n        globalObject.linkPrefetchHandlerAdded.add(linkTag);\n        if (isLinkSkipped(linkTag))\n            continue;\n        linkTag.addEventListener('mouseover', () => {\n            prefetchOnEvent(linkTag, 'hover');\n        }, { passive: true });\n        linkTag.addEventListener('touchstart', () => {\n            prefetchOnEvent(linkTag, 'hover');\n        }, { passive: true });\n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    prefetchOnEvent(linkTag, 'viewport');\n                }\n            });\n        });\n        observer.observe(linkTag);\n    }\n}\nasync function prefetchOnEvent(linkTag, event) {\n    let prefetchSettings;\n    const pageContextCurrent = getPageContextCurrent();\n    if (pageContextCurrent) {\n        prefetchSettings = getPrefetchSettings(pageContextCurrent, linkTag);\n    }\n    else {\n        if (isBrilloutDocpress()) {\n            // TO-DO/pageContext-prefetch: remove this dirty hack used by @brillout/docpress and, instead, use Vike's default if pageContextCurrent isn't defined yet.\n            prefetchSettings = { staticAssets: 'hover', pageContext: Infinity };\n        }\n        else {\n            // TO-DO/pageContext-prefetch: consider pageContextLink\n            return;\n        }\n    }\n    // Check again in case DOM was manipulated since last check\n    if (isLinkSkipped(linkTag))\n        return;\n    const urlOfLink = linkTag.getAttribute('href');\n    const pageContextLink = await getPageContextLink(urlOfLink);\n    if (!pageContextLink?.pageId)\n        return;\n    assert(hasProp(pageContextLink, 'pageId', 'string')); // help TypeScript\n    if (!(await isClientSideRoutable(pageContextLink.pageId, pageContextLink)))\n        return;\n    await Promise.all([\n        (async () => {\n            if (prefetchSettings.staticAssets === event) {\n                await prefetchAssets(pageContextLink);\n            }\n        })(),\n        (async () => {\n            if (event !== 'viewport' && prefetchSettings.pageContext) {\n                const key = getCacheKey(urlOfLink);\n                const found = globalObject.prefetchedPageContexts[key];\n                if (!found || isExpired(found)) {\n                    // TO-DO/pageContext-prefetch: move this logic in getPrefetchSettings()\n                    const resultMaxAge = prefetchSettings.pageContext;\n                    await prefetchPageContextFromServerHooks(pageContextLink, resultMaxAge);\n                }\n            }\n        })(),\n    ]);\n}\nfunction isExpired(found) {\n    return Date.now() - found.resultFetchedAt > found.resultMaxAge;\n}\n// TO-DO/next-major-release: make it sync\nasync function getPageContextLink(urlOfLink) {\n    const pageContextLink = await createPageContextClientSide(urlOfLink);\n    let pageContextFromRoute;\n    try {\n        pageContextFromRoute = await route(pageContextLink);\n    }\n    catch {\n        // If a route() hook has a bug or `throw render()` / `throw redirect()`\n        return null;\n    }\n    objectAssign(pageContextLink, pageContextFromRoute);\n    return pageContextLink;\n}\nfunction getCacheKey(url) {\n    if (url.startsWith('#'))\n        url = '/';\n    assert(url.startsWith('/'), { urlPathname: url });\n    const key = url.split('#')[0];\n    return key;\n}\n// TO-DO/pageContext-prefetch: remove\nfunction isBrilloutDocpress() {\n    return '_isBrilloutDocpress' in window;\n}\n","export { execHookOnRenderClient };\nimport { assert, assertUsage } from '../runtime-server-routing/utils.js';\nimport { getHookFromPageContext } from '../../shared/hooks/getHook.js';\nimport { execHookDirectSingle } from '../../shared/hooks/execHook.js';\nasync function execHookOnRenderClient(pageContext, prepareForPublicUsage) {\n    let hook = null;\n    {\n        const renderHook = getHookFromPageContext(pageContext, 'render');\n        hook = renderHook;\n    }\n    {\n        const renderHook = getHookFromPageContext(pageContext, 'onRenderClient');\n        if (renderHook) {\n            hook = renderHook;\n        }\n    }\n    if (!hook) {\n        const urlToShowToUser = getUrlToShowToUser(pageContext);\n        assert(urlToShowToUser);\n        if (pageContext._globalContext._pageConfigs.length > 0) {\n            // V1 design\n            assertUsage(false, `No onRenderClient() hook defined for URL '${urlToShowToUser}', but it's needed, see https://vike.dev/onRenderClient`);\n        }\n        else {\n            // TO-DO/next-major-release: remove\n            // V0.4 design\n            const pageClientsFilesLoaded = pageContext._pageFilesLoaded.filter((p) => p.fileType === '.page.client');\n            let errMsg;\n            if (pageClientsFilesLoaded.length === 0) {\n                errMsg = 'No file `*.page.client.*` found for URL ' + urlToShowToUser;\n            }\n            else {\n                errMsg =\n                    'One of the following files should export a render() hook: ' +\n                        pageClientsFilesLoaded.map((p) => p.filePath).join(' ');\n            }\n            assertUsage(false, errMsg);\n        }\n    }\n    // We don't use a try-catch wrapper because rendering errors are usually handled by the UI framework. (E.g. React's Error Boundaries.)\n    await execHookDirectSingle(hook, pageContext, prepareForPublicUsage);\n}\nfunction getUrlToShowToUser(pageContext) {\n    let url;\n    // try/catch to avoid passToClient assertUsage() (although: this may not be needed anymore, since we're now accessing pageContext and not pageContextForPublicUsage)\n    try {\n        url =\n            // Client Routing\n            pageContext.urlPathname ??\n                // Server Routing\n                pageContext.urlOriginal;\n    }\n    catch { }\n    url = url ?? window.location.href;\n    return url;\n}\n","export { getCurrentUrl };\nimport { normalizeClientSideUrl } from './normalizeClientSideUrl.js';\nfunction getCurrentUrl(options) {\n    return normalizeClientSideUrl(window.location.href, options);\n}\n","export { pushHistoryState };\nexport { replaceHistoryStateOriginal };\nexport { onPopStateBegin };\nexport { saveScrollPosition };\nexport { initHistory };\nimport { getCurrentUrl } from '../shared/getCurrentUrl.js';\nimport { assert, assertUsage, getGlobalObject, isObject, deepEqual, cast } from './utils.js';\nconst globalObject = getGlobalObject('history.ts', {\n    monkeyPatched: false,\n    previous: undefined,\n});\ninitHistory(); // we redundantly call initHistory() to ensure it's called early\nglobalObject.previous = getHistoryInfo();\n// `window.history.state === null` when:\n// - The very first render\n// - Click on `<a href=\"#some-hash\" />`\n// - `location.hash = 'some-hash'`\nfunction enhanceHistoryState() {\n    if (isVikeEnhanced(window.history.state))\n        return;\n    const stateVikeEnhanced = enhance(window.history.state);\n    replaceHistoryState(stateVikeEnhanced);\n}\nfunction enhance(stateNotEnhanced) {\n    const timestamp = getTimestamp();\n    const scrollPosition = getScrollPosition();\n    const triggeredBy = 'browser';\n    let stateVikeEnhanced;\n    if (!stateNotEnhanced) {\n        stateVikeEnhanced = {\n            timestamp,\n            scrollPosition,\n            triggeredBy,\n            _isVikeEnhanced: true,\n        };\n    }\n    else {\n        // State information may be incomplete if `window.history.state` is set by an old Vike version. (E.g. `state.timestamp` was introduced for `pageContext.isBackwardNavigation` in `0.4.19`.)\n        cast(stateNotEnhanced);\n        stateVikeEnhanced = {\n            timestamp: stateNotEnhanced.timestamp ?? timestamp,\n            scrollPosition: stateNotEnhanced.scrollPosition ?? scrollPosition,\n            triggeredBy: stateNotEnhanced.triggeredBy ?? triggeredBy,\n            _isVikeEnhanced: true,\n        };\n    }\n    assertIsVikeEnhanced(stateVikeEnhanced);\n    return stateVikeEnhanced;\n}\nfunction getState() {\n    const state = window.history.state;\n    // *Every* state added to the history needs to go through Vike.\n    // - Otherwise Vike's `popstate` listener won't work. (Because, for example, if globalObject.previous is outdated => isHashNavigation faulty => client-side navigation is wrongfully skipped.)\n    // - Therefore, we have to monkey patch history.pushState() and history.replaceState()\n    // - Therefore, we need the assert() below to ensure history.state has been enhanced by Vike\n    //   - If users stumble upon this assert() then let's make it a assertUsage()\n    assertIsVikeEnhanced(state);\n    return state;\n}\nfunction getScrollPosition() {\n    const scrollPosition = { x: window.scrollX, y: window.scrollY };\n    return scrollPosition;\n}\nfunction getTimestamp() {\n    return new Date().getTime();\n}\nfunction saveScrollPosition() {\n    const scrollPosition = getScrollPosition();\n    const state = getState();\n    replaceHistoryState({ ...state, scrollPosition });\n}\nfunction pushHistoryState(url, overwriteLastHistoryEntry) {\n    if (!overwriteLastHistoryEntry) {\n        const state = {\n            timestamp: getTimestamp(),\n            // I don't remember why I set it to `null`, maybe because setting it now would be too early? (Maybe there is a delay between renderPageClientSide() is finished and the browser updating the scroll position.) Anyways, it seems like autoSaveScrollPosition() is enough.\n            scrollPosition: null,\n            triggeredBy: 'vike',\n            _isVikeEnhanced: true,\n        };\n        // Calling the monkey patched history.pushState() (and not the original) so that other tools (e.g. user tracking) can listen to Vike's pushState() calls.\n        // - https://github.com/vikejs/vike/issues/1582\n        window.history.pushState(state, '', url);\n    }\n    else {\n        replaceHistoryState(getState(), url);\n    }\n}\nfunction replaceHistoryState(state, url) {\n    const url_ = url ?? null; // Passing `undefined` chokes older Edge versions.\n    window.history.replaceState(state, '', url_);\n    assertIsVikeEnhanced(window.history.state);\n}\nfunction replaceHistoryStateOriginal(state, url) {\n    // Bypass all monkey patches.\n    // - Useful, for example, to avoid other tools listening to history.replaceState() calls\n    History.prototype.replaceState.bind(window.history)(state, '', url);\n}\n// Monkey patch:\n// - history.pushState()\n// - history.replaceState()\nfunction monkeyPatchHistoryAPI() {\n    if (globalObject.monkeyPatched)\n        return;\n    globalObject.monkeyPatched = true;\n    ['pushState', 'replaceState'].forEach((funcName) => {\n        const funcOriginal = window.history[funcName].bind(window.history);\n        window.history[funcName] = (stateOriginal = {}, ...rest) => {\n            assertUsage(stateOriginal === undefined || stateOriginal === null || isObject(stateOriginal), `history.${funcName}(state) argument state must be an object`);\n            const stateEnhanced = isVikeEnhanced(stateOriginal)\n                ? stateOriginal\n                : {\n                    _isVikeEnhanced: true,\n                    scrollPosition: getScrollPosition(),\n                    timestamp: getTimestamp(),\n                    triggeredBy: 'user',\n                    ...stateOriginal,\n                };\n            assertIsVikeEnhanced(stateEnhanced);\n            funcOriginal(stateEnhanced, ...rest);\n            assert(deepEqual(stateEnhanced, window.history.state));\n            globalObject.previous = getHistoryInfo();\n            // Workaround https://github.com/vikejs/vike/issues/2504#issuecomment-3149764736\n            queueMicrotask(() => {\n                if (deepEqual(stateEnhanced, window.history.state))\n                    return;\n                Object.assign(stateEnhanced, window.history.state);\n                assertIsVikeEnhanced(stateEnhanced);\n                replaceHistoryStateOriginal(stateEnhanced, rest[1]);\n                assert(deepEqual(stateEnhanced, window.history.state));\n            });\n        };\n    });\n}\nfunction isVikeEnhanced(state) {\n    if (isObject(state) && '_isVikeEnhanced' in state) {\n        /* We don't use the assert() below to save client-side KBs.\n        assert(hasProp(state, '_isVikeEnhanced', 'true'))\n        assert(hasProp(state, 'timestamp', 'number'))\n        assert(hasProp(state, 'scrollPosition'))\n        if (state.scrollPosition !== null) {\n          assert(hasProp(state, 'scrollPosition', 'object'))\n          assert(hasProp(state.scrollPosition, 'x', 'number') && hasProp(state.scrollPosition, 'y', 'number'))\n        }\n        //*/\n        return true;\n    }\n    return false;\n}\nfunction assertIsVikeEnhanced(state) {\n    if (isVikeEnhanced(state))\n        return;\n    assert(false, { state });\n}\nfunction getHistoryInfo() {\n    return {\n        url: getCurrentUrl(),\n        state: getState(),\n    };\n}\nfunction onPopStateBegin() {\n    const { previous } = globalObject;\n    const isHistoryStateEnhanced = window.history.state !== null;\n    if (!isHistoryStateEnhanced)\n        enhanceHistoryState();\n    assertIsVikeEnhanced(window.history.state);\n    const current = getHistoryInfo();\n    globalObject.previous = current;\n    return { isHistoryStateEnhanced, previous, current };\n}\nfunction initHistory() {\n    monkeyPatchHistoryAPI(); // the earlier we call it the better (Vike can workaround erroneous library monkey patches if Vike is the last one in the monkey patch chain)\n    enhanceHistoryState(); // enhance very first window.history.state which is `null`\n}\n","export { setScrollPosition };\nexport { autoSaveScrollPosition };\nexport { scrollToHashOrTop };\nimport { assert, onPageHide, sleep, throttle } from './utils.js';\nimport { replaceHistoryStateOriginal, saveScrollPosition } from './history.js';\nfunction setScrollPosition(scrollTarget, url) {\n    if (!scrollTarget && url && hasTextFragment(url)) {\n        scrollToTextFragment(url);\n        return;\n    }\n    if (scrollTarget && 'x' in scrollTarget) {\n        setScroll(scrollTarget);\n        return;\n    }\n    if (scrollTarget?.preserveScroll) {\n        return;\n    }\n    const hash = getUrlHash();\n    scrollToHashOrTop(hash);\n}\n// https://github.com/vikejs/vike/issues/2114\n// https://github.com/WICG/scroll-to-text-fragment/issues/261\nfunction scrollToTextFragment(url) {\n    const stateOriginal = window.history.state;\n    replaceHistoryStateOriginal(null, url);\n    // We need `history.state===null` before location.replace() so that our 'popstate' handling is correct\n    assert(window.history.state === null);\n    // - Chrome's location.replace() keeps the current state (`history.state===stateOriginal`)\n    // - Firefox's location.replace() replaces the current state with `null` (`history.state===null`)\n    window.location.replace(url);\n    replaceHistoryStateOriginal(stateOriginal, url);\n}\nfunction hasTextFragment(url) {\n    return url.includes('#') && url.includes(':~:text');\n}\n// Replicates the browser's native behavior\nfunction scrollToHashOrTop(hash) {\n    if (!hash) {\n        scrollToTop();\n    }\n    else {\n        const id = decodeURIComponent(hash);\n        const hashTarget = document.getElementById(id) || document.getElementsByName(id)[0];\n        if (hashTarget) {\n            hashTarget.scrollIntoView();\n            // Is this standard? We just copied SvelteKit: https://github.com/sveltejs/kit/blob/94c45b9372a9ed2b80e21cdca3f235c45edaa5b0/packages/kit/src/runtime/client/client.js#L2132\n            hashTarget.focus();\n        }\n        else if (hash === 'top') {\n            scrollToTop();\n        }\n    }\n}\nfunction scrollToTop() {\n    setScroll({ x: 0, y: 0 });\n}\n/**\n * Change the browser's scroll position, in a way that works during a repaint.\n *\n * I don't remember exactly why I implemented this and what I meant with \"repaint\"\n * - https://github.com/vikejs/vike/commit/fd70fadb0bcea8d922f961f1c88713994e0aaf34\n * - I guess scrolling doesn't work during a page rendering? So we have to re-scroll until the scroll position is correct?\n * - Do other frameworks implement this? SvelteKit doesn't seem to.\n * - Let's remove it and see if users complain?\n */\nfunction setScroll(scrollPosition) {\n    const scroll = () => {\n        // `window.scrollTo()` respects the CSS `scroll-behavior: smooth` property\n        window.scrollTo(scrollPosition.x, scrollPosition.y);\n    };\n    const done = () => {\n        return window.scrollX === scrollPosition.x && window.scrollY === scrollPosition.y;\n    };\n    // In principle, this `done()` call should force the repaint to be finished, but that doesn't seem to be the case with `Firefox 97.0.1`.\n    if (done())\n        return;\n    scroll();\n    // Because `done()` doesn't seem to always force the repaint to be finished, we potentially need to retry again.\n    if (done())\n        return;\n    requestAnimationFrame(() => {\n        scroll();\n        if (done())\n            return;\n        setTimeout(async () => {\n            scroll();\n            if (done())\n                return;\n            // In principle, `requestAnimationFrame() -> setTimeout(, 0)` should be enough.\n            //  - https://stackoverflow.com/questions/61281139/waiting-for-repaint-in-javascript\n            //  - But it's not enough for `Firefox 97.0.1`.\n            //  - The following strategy is very aggressive. It doesn't need to be that aggressive for Firefox. But we do it to be safe.\n            const start = new Date().getTime();\n            while (true) {\n                await sleep(10);\n                scroll();\n                if (done())\n                    return;\n                const millisecondsElapsed = new Date().getTime() - start;\n                if (millisecondsElapsed > 100)\n                    return;\n            }\n        }, 0);\n    });\n}\nfunction getUrlHash() {\n    let { hash } = window.location;\n    if (hash === '')\n        return null;\n    assert(hash.startsWith('#'));\n    hash = hash.slice(1);\n    return hash;\n}\n// Save scroll position (needed for back-/forward navigation)\nfunction autoSaveScrollPosition() {\n    // Safari cannot handle more than 100 `history.replaceState()` calls within 30 seconds (https://github.com/vikejs/vike/issues/46)\n    window.addEventListener('scroll', throttle(saveScrollPosition, Math.ceil(1000 / 3)), { passive: true });\n    onPageHide(saveScrollPosition);\n}\n","export { throttle };\nfunction throttle(func, waitTime) {\n    let isQueued = false;\n    return () => {\n        if (!isQueued) {\n            isQueued = true;\n            setTimeout(() => {\n                isQueued = false;\n                func();\n            }, waitTime);\n        }\n    };\n}\n","export { scrollRestoration_init };\nexport { scrollRestoration_initialRenderIsDone };\n// Using `window.history.scrollRestoration` to recover scroll position when user reloads the page or Cmd-Shift-T back to it.\n// We let the browser do it because it's fast.\n// - Alternatively we could inject an inline script `<script>scrollTo(history.state.scrollPosition)</script>` early, which seems to be equally fast. (See for example https://vike.dev/usePageContext which sets the main scroll position and the navigation scroll position equally fast.)\n// - Firefox doesn't restore the scroll position upon page reload but does upon Cmd-Shift-T\n// See also: https://github.com/cyco130/knave/blob/e9e1bc7687848504293197f1b314b7d12ad0d228/design.md#scroll-restoration\nimport { getGlobalObject, onPageHide, onPageShow } from './utils.js';\nconst globalObject = getGlobalObject('runtime-client-routing/scrollRestoration.ts', {});\nfunction scrollRestoration_init() {\n    // Use the native scroll restoration mechanism only for the first render\n    scrollRestoration_enable();\n    onPageHide(scrollRestoration_enable);\n    onPageShow(() => globalObject.initialRenderIsDone && scrollRestoration_disable());\n}\nfunction scrollRestoration_initialRenderIsDone() {\n    globalObject.initialRenderIsDone = true;\n    scrollRestoration_disable();\n}\nfunction scrollRestoration_disable() {\n    if ('scrollRestoration' in window.history) {\n        window.history.scrollRestoration = 'manual';\n    }\n}\nfunction scrollRestoration_enable() {\n    if ('scrollRestoration' in window.history) {\n        // Use the browser's native scroll restoration mechanism\n        window.history.scrollRestoration = 'auto';\n    }\n}\n","export { logErrorClient };\nimport { isObject } from './utils.js';\nfunction logErrorClient(err) {\n    if (isObject(err) &&\n        // Set by vike-react\n        // https://github.com/vikejs/vike-react/blob/195a208c6b77e7f34496e1f637278a36c60fbe07/packages/vike-react/src/integration/onRenderClient.tsx#L109\n        err.isAlreadyLogged) {\n        return;\n    }\n    console.error(err);\n}\n","export { renderPageClientSide };\nexport { getRenderCount };\nexport { disableClientRouting };\nexport { firstRenderStartPromise };\nexport { getPageContextClient };\nimport { assert, objectAssign, redirectHard, getGlobalObject, hasProp, updateType, genPromise, isCallable, catchInfiniteLoop, } from './utils.js';\nimport { getPageContextFromClientHooks, getPageContextFromServerHooks, getPageContextFromHooks_isHydration, getPageContextFromHooks_serialized, setPageContextInitIsPassedToClient, } from './getPageContextFromHooks.js';\nimport { createPageContextClientSide } from './createPageContextClientSide.js';\nimport { addLinkPrefetchHandlers, addLinkPrefetchHandlers_unwatch, addLinkPrefetchHandlers_watch, getPageContextPrefetched, populatePageContextPrefetchCache, } from './prefetch.js';\nimport { assertInfo, assertWarning, isReact } from './utils.js';\nimport { execHookOnRenderClient } from '../shared/execHookOnRenderClient.js';\nimport { isErrorFetchingStaticAssets, loadPageConfigsLazyClientSide, } from '../shared/loadPageConfigsLazyClientSide.js';\nimport { pushHistoryState } from './history.js';\nimport { assertNoInfiniteAbortLoop, getPageContextFromAllRewrites, isAbortError, logAbortErrorHandled, } from '../../shared/route/abort.js';\nimport { route } from '../../shared/route/index.js';\nimport { isClientSideRoutable } from './isClientSideRoutable.js';\nimport { setScrollPosition } from './setScrollPosition.js';\nimport { scrollRestoration_initialRenderIsDone } from './scrollRestoration.js';\nimport { getErrorPageId, isErrorPage } from '../../shared/error-page.js';\nimport { setPageContextCurrent } from './getPageContextCurrent.js';\nimport { getRouteStringParameterList } from '../../shared/route/resolveRouteString.js';\nimport { getCurrentUrl } from '../shared/getCurrentUrl.js';\nimport { execHookDirect, execHook } from '../../shared/hooks/execHook.js';\nimport { preparePageContextForPublicUsageClient, } from './preparePageContextForPublicUsageClient.js';\nimport { getHookFromPageContextNew } from '../../shared/hooks/getHook.js';\nimport { preparePageContextForPublicUsageClientMinimal } from '../shared/preparePageContextForPublicUsageClientShared.js';\nimport { logErrorClient } from './logErrorClient.js';\nconst globalObject = getGlobalObject('runtime-client-routing/renderPageClientSide.ts', (() => {\n    const { promise: firstRenderStartPromise, resolve: firstRenderStartPromiseResolve } = genPromise();\n    return {\n        renderCounter: 0,\n        firstRenderStartPromise,\n        firstRenderStartPromiseResolve,\n    };\n})());\nconst { firstRenderStartPromise } = globalObject;\nasync function renderPageClientSide(renderArgs) {\n    catchInfiniteLoop('renderPageClientSide()');\n    const { urlOriginal = getCurrentUrl(), overwriteLastHistoryEntry = false, isBackwardNavigation, pageContextsFromRewrite = [], redirectCount = 0, doNotRenderIfSamePage, isClientSideNavigation = true, pageContextInitClient, } = renderArgs;\n    let { scrollTarget } = renderArgs;\n    const { previousPageContext } = globalObject;\n    addLinkPrefetchHandlers_unwatch();\n    const { isRenderOutdated, setHydrationCanBeAborted, isFirstRender } = getIsRenderOutdated();\n    assertNoInfiniteAbortLoop(pageContextsFromRewrite.length, redirectCount);\n    const pageContextBeginArgs = {\n        urlOriginal,\n        isBackwardNavigation,\n        pageContextsFromRewrite,\n        isClientSideNavigation,\n        pageContextInitClient,\n        isFirstRender,\n    };\n    if (globalObject.clientRoutingIsDisabled) {\n        redirectHard(urlOriginal);\n        return;\n    }\n    globalObject.firstRenderStartPromiseResolve();\n    if (isRenderOutdated())\n        return;\n    return await renderPageNominal();\n    async function renderPageNominal() {\n        const onError = async (err) => {\n            await handleError({ err });\n        };\n        const pageContext = await getPageContextBegin(false, pageContextBeginArgs);\n        if (isRenderOutdated())\n            return;\n        // onPageTransitionStart()\n        if (globalObject.isFirstRenderDone) {\n            assert(previousPageContext);\n            // We use the hook of the previous page in order to be able to call onPageTransitionStart() before fetching the files of the next page.\n            // https://github.com/vikejs/vike/issues/1560\n            if (!globalObject.isTransitioning) {\n                globalObject.isTransitioning = true;\n                const hooks = getHookFromPageContextNew('onPageTransitionStart', previousPageContext);\n                try {\n                    await execHookDirect(hooks, pageContext, preparePageContextForPublicUsageClientMinimal);\n                }\n                catch (err) {\n                    await onError(err);\n                    return;\n                }\n                if (isRenderOutdated())\n                    return;\n            }\n        }\n        // Get pageContext serialized in <script id=\"vike_pageContext\" type=\"application/json\">\n        if (isFirstRender) {\n            const pageContextSerialized = getPageContextFromHooks_serialized();\n            // TO-DO/eventually: create helper assertPageContextFromHook()\n            assert(!('urlOriginal' in pageContextSerialized));\n            objectAssign(pageContext, pageContextSerialized);\n            // TO-DO/pageContext-prefetch: remove or change, because this only makes sense for a pre-rendered page\n            populatePageContextPrefetchCache(pageContext, { pageContextFromServerHooks: pageContextSerialized });\n        }\n        // Route\n        // - We must also run it upon hydration to call the onBeforeRoute() hook, which is needed for i18n URL locale extraction.\n        {\n            let pageContextFromRoute;\n            try {\n                pageContextFromRoute = await route(pageContext);\n            }\n            catch (err) {\n                await onError(err);\n                return;\n            }\n            if (isRenderOutdated())\n                return;\n            // TO-DO/eventually: create helper assertPageContextFromHook()\n            assert(!('urlOriginal' in pageContextFromRoute));\n            if (isFirstRender) {\n                // Set pageContext properties set by onBeforeRoute()\n                // - But we skip pageId and routeParams because routing may have been aborted by a server-side `throw render()`\n                const { pageId, routeParams, ...rest } = pageContextFromRoute;\n                objectAssign(pageContext, rest);\n                assert(hasProp(pageContext, 'routeParams', 'string{}')); // Help TS\n            }\n            else {\n                objectAssign(pageContext, pageContextFromRoute);\n            }\n            if (!isFirstRender) {\n                if (!pageContextFromRoute.pageId) {\n                    /*\n                    // We don't use the client router to render the 404 page:\n                    //  - So that the +redirects setting (https://vike.dev/redirects) can be applied.\n                    //    - This is the main argument.\n                    //    - See also failed CI: https://github.com/vikejs/vike/pull/1871\n                    //  - So that server-side error tracking can track 404 links?\n                    //    - We do use the client router for rendering the error page, so I don't think this is much of an argument.\n                    await renderErrorPage({ is404: true })\n                    */\n                    redirectHard(urlOriginal);\n                    return;\n                }\n                const isClientRoutable = await isClientSideRoutable(pageContextFromRoute.pageId, pageContext);\n                if (isRenderOutdated())\n                    return;\n                if (!isClientRoutable) {\n                    redirectHard(urlOriginal);\n                    return;\n                }\n                const isSamePage = pageContextFromRoute.pageId &&\n                    previousPageContext?.pageId &&\n                    pageContextFromRoute.pageId === previousPageContext.pageId;\n                if (doNotRenderIfSamePage && isSamePage) {\n                    // Skip's Vike's rendering; let the user handle the navigation\n                    return;\n                }\n            }\n        }\n        assert(hasProp(pageContext, 'pageId', 'string')); // Help TS\n        const res = await loadPageConfigsLazyClientSideAndExecHook(pageContext, isFirstRender, isRenderOutdated);\n        /* Already called inside loadPageConfigsLazyClientSideAndExecHook()\n        if (isRenderOutdated()) return\n        */\n        if (res.skip)\n            return;\n        if ('err' in res) {\n            await onError(res.err);\n            return;\n        }\n        updateType(pageContext, res.pageContext);\n        setPageContextCurrent(pageContext);\n        // Set global hydrationCanBeAborted\n        if (pageContext.exports.hydrationCanBeAborted) {\n            setHydrationCanBeAborted();\n        }\n        else {\n            assertWarning(!isReact(), 'You seem to be using React; we recommend setting hydrationCanBeAborted to true, see https://vike.dev/hydrationCanBeAborted', { onlyOnce: true });\n        }\n        // There wasn't any `await` but the isRenderOutdated() return value may have changed because we called setHydrationCanBeAborted()\n        if (isRenderOutdated())\n            return;\n        // Get pageContext from hooks (fetched from server, and/or directly called on the client-side)\n        if (isFirstRender) {\n            assert(hasProp(pageContext, '_hasPageContextFromServer', 'true'));\n            let pageContextAugmented;\n            try {\n                pageContextAugmented = await getPageContextFromHooks_isHydration(pageContext);\n            }\n            catch (err) {\n                await onError(err);\n                return;\n            }\n            if (isRenderOutdated())\n                return;\n            updateType(pageContext, pageContextAugmented);\n            // Render page view\n            return await renderPageView(pageContext);\n        }\n        else {\n            // Fetch pageContext from server-side hooks\n            let pageContextFromServerHooks;\n            const pageContextPrefetched = getPageContextPrefetched(pageContext);\n            if (pageContextPrefetched) {\n                pageContextFromServerHooks = pageContextPrefetched;\n            }\n            else {\n                try {\n                    const result = await getPageContextFromServerHooks(pageContext, false);\n                    if (result.is404ServerSideRouted)\n                        return;\n                    pageContextFromServerHooks = result.pageContextFromServerHooks;\n                    // TO-DO/pageContext-prefetch: remove or change, because this only makes sense for a pre-rendered page\n                    populatePageContextPrefetchCache(pageContext, result);\n                }\n                catch (err) {\n                    await onError(err);\n                    return;\n                }\n            }\n            if (isRenderOutdated())\n                return;\n            // TO-DO/eventually: create helper assertPageContextFromHook()\n            assert(!('urlOriginal' in pageContextFromServerHooks));\n            objectAssign(pageContext, pageContextFromServerHooks);\n            // Get pageContext from client-side hooks\n            let pageContextFromClientHooks;\n            try {\n                pageContextFromClientHooks = await getPageContextFromClientHooks(pageContext, false);\n            }\n            catch (err) {\n                await onError(err);\n                return;\n            }\n            if (isRenderOutdated())\n                return;\n            updateType(pageContext, pageContextFromClientHooks);\n            return await renderPageView(pageContext);\n        }\n    }\n    // When the normal page threw an error:\n    // - Can be a URL rewrite upon `throw render('/some-url')`\n    // - Can be rendering the error page\n    // - Can be rendering Vike's generic error page (if no error page is defined, or if the error page throws an error)\n    async function handleError(args) {\n        const { err } = args;\n        assert(err);\n        // Logging\n        if (!isAbortError(err)) {\n            // We don't swallow 404 errors:\n            //  - On the server-side, Vike swallows / doesn't show any 404 error log because it's expected that a user may go to some random non-existent URL. (We don't want to flood the app's error tracking with 404 logs.)\n            //  - On the client-side, if the user navigates to a 404 then it means that the UI has a broken link. (It isn't expected that users can go to some random URL using the client-side router, as it would require, for example, the user to manually change the URL of a link by manually manipulating the DOM which highly unlikely.)\n            logErrorClient(err);\n        }\n        else {\n            // We swallow throw redirect()/render() called by client-side hooks onBeforeRender()/data()/guard()\n            // We handle the abort error down below.\n        }\n        // pageContext\n        const pageContext = await getPageContextBegin(true, pageContextBeginArgs);\n        if (isRenderOutdated())\n            return;\n        objectAssign(pageContext, {\n            errorWhileRendering: err,\n        });\n        // throw redirect()/render()\n        let pageContextAbort;\n        if (isAbortError(err)) {\n            const res = await handleAbortError(err, pageContext);\n            if (res.skip)\n                return;\n            pageContextAbort = res.pageContextAbort;\n        }\n        // Render error page\n        await renderErrorPage(pageContext, args, pageContextAbort);\n    }\n    async function renderErrorPage(pageContext, args, pageContextAbort) {\n        const onError = (err) => {\n            /* When we can't render the error page, we prefer showing a blank page over letting the server-side try because otherwise:\n               - We risk running into an infinite loop of reloads which would overload the server.\n               - An infinite reloading page is a even worse UX than a blank page.\n            redirectHard(urlOriginal)\n            */\n            logErrorClient(err);\n        };\n        const errorPageId = getErrorPageId(pageContext._pageFilesAll, pageContext._globalContext._pageConfigs);\n        if (!errorPageId)\n            throw new Error('No error page defined.');\n        objectAssign(pageContext, {\n            pageId: errorPageId,\n            routeParams: {},\n        });\n        // throw render(statusCode)\n        if (pageContextAbort) {\n            assert(pageContextAbort.abortStatusCode);\n            assert(!('urlOriginal' in pageContextAbort));\n            objectAssign(pageContext, pageContextAbort);\n            objectAssign(pageContext, { is404: pageContextAbort.abortStatusCode === 404 });\n        }\n        else {\n            objectAssign(pageContext, { is404: false });\n        }\n        const isClientRoutable = await isClientSideRoutable(pageContext.pageId, pageContext);\n        if (isRenderOutdated())\n            return;\n        if (!isClientRoutable) {\n            redirectHard(urlOriginal);\n            return;\n        }\n        if (import.meta.env.DEV || globalThis.__VIKE__IS_DEBUG) {\n            assertInfo(false, `Rendering error page ${errorPageId}`, { onlyOnce: false });\n        }\n        const res = await loadPageConfigsLazyClientSideAndExecHook(pageContext, isFirstRender, isRenderOutdated);\n        /* Already called inside loadPageConfigsLazyClientSideAndExecHook()\n        if (isRenderOutdated()) return\n        */\n        if (res.skip)\n            return;\n        if ('err' in res) {\n            onError(res.err);\n            return;\n        }\n        updateType(pageContext, res.pageContext);\n        setPageContextCurrent(pageContext);\n        let pageContextFromServerHooks;\n        try {\n            const result = await getPageContextFromServerHooks(pageContext, true);\n            if (result.is404ServerSideRouted)\n                return;\n            pageContextFromServerHooks = result.pageContextFromServerHooks;\n        }\n        catch (err) {\n            onError(err);\n            return;\n        }\n        if (isRenderOutdated())\n            return;\n        // TO-DO/eventually: create helper assertPageContextFromHook()\n        assert(!('urlOriginal' in pageContextFromServerHooks));\n        objectAssign(pageContext, pageContextFromServerHooks);\n        let pageContextFromClientHooks;\n        try {\n            pageContextFromClientHooks = await getPageContextFromClientHooks(pageContext, true);\n        }\n        catch (err) {\n            onError(err);\n            return;\n        }\n        if (isRenderOutdated())\n            return;\n        updateType(pageContext, pageContextFromClientHooks);\n        await renderPageView(pageContext, args);\n    }\n    async function handleAbortError(err, pageContext) {\n        const errAbort = err;\n        logAbortErrorHandled(err, !import.meta.env.DEV, pageContext);\n        const pageContextAbort = errAbort._pageContextAbort;\n        // throw render('/some-url')\n        if (pageContextAbort._urlRewrite) {\n            await renderPageClientSide({\n                ...renderArgs,\n                scrollTarget: undefined,\n                pageContextsFromRewrite: [...pageContextsFromRewrite, pageContextAbort],\n            });\n            return { skip: true };\n        }\n        // throw redirect('/some-url')\n        if (pageContextAbort._urlRedirect) {\n            const urlRedirect = pageContextAbort._urlRedirect.url;\n            if (!urlRedirect.startsWith('/')) {\n                // External redirection\n                redirectHard(urlRedirect);\n                return { skip: true };\n            }\n            else {\n                await renderPageClientSide({\n                    ...renderArgs,\n                    scrollTarget: undefined,\n                    urlOriginal: urlRedirect,\n                    overwriteLastHistoryEntry: false,\n                    isBackwardNavigation: false,\n                    redirectCount: redirectCount + 1,\n                });\n            }\n            return { skip: true };\n        }\n        // throw render(statusCode)\n        return { pageContextAbort };\n    }\n    async function renderPageView(pageContext, isErrorPage) {\n        const onError = async (err) => {\n            if (!isErrorPage) {\n                await handleError({ err });\n            }\n            else {\n                logErrorClient(err);\n            }\n        };\n        // We use globalObject.onRenderClientPreviousPromise in order to ensure that there is never two concurrent onRenderClient() calls\n        if (globalObject.onRenderClientPreviousPromise) {\n            // Make sure that the previous render has finished\n            await globalObject.onRenderClientPreviousPromise;\n            assert(globalObject.onRenderClientPreviousPromise === undefined);\n            if (isRenderOutdated())\n                return;\n        }\n        changeUrl(urlOriginal, overwriteLastHistoryEntry);\n        globalObject.previousPageContext = pageContext;\n        assert(globalObject.onRenderClientPreviousPromise === undefined);\n        const onRenderClientPromise = (async () => {\n            let onRenderClientError;\n            try {\n                await execHookOnRenderClient(pageContext, preparePageContextForPublicUsageClient);\n            }\n            catch (err) {\n                assert(err);\n                onRenderClientError = err;\n            }\n            globalObject.onRenderClientPreviousPromise = undefined;\n            globalObject.isFirstRenderDone = true;\n            return onRenderClientError;\n        })();\n        globalObject.onRenderClientPreviousPromise = onRenderClientPromise;\n        const onRenderClientError = await onRenderClientPromise;\n        assert(globalObject.onRenderClientPreviousPromise === undefined);\n        if (onRenderClientError) {\n            await onError(onRenderClientError);\n            if (!isErrorPage)\n                return;\n        }\n        /* We don't abort in order to ensure that onHydrationEnd() is called: we abort only after onHydrationEnd() is called.\n        if (isRenderOutdated(true)) return\n        */\n        // onHydrationEnd()\n        if (isFirstRender && !onRenderClientError) {\n            try {\n                await execHook('onHydrationEnd', pageContext, preparePageContextForPublicUsageClient);\n            }\n            catch (err) {\n                await onError(err);\n                if (!isErrorPage)\n                    return;\n            }\n            if (isRenderOutdated(true))\n                return;\n        }\n        // We purposely abort *after* onHydrationEnd() is called (see comment above).\n        if (isRenderOutdated(true))\n            return;\n        // onPageTransitionEnd()\n        if (globalObject.isTransitioning) {\n            globalObject.isTransitioning = undefined;\n            assert(previousPageContext);\n            const hooks = getHookFromPageContextNew('onPageTransitionEnd', previousPageContext);\n            try {\n                await execHookDirect(hooks, pageContext, preparePageContextForPublicUsageClient);\n            }\n            catch (err) {\n                await onError(err);\n                if (!isErrorPage)\n                    return;\n            }\n            if (isRenderOutdated(true))\n                return;\n        }\n        if (!scrollTarget && previousPageContext) {\n            const keepScrollPositionPrev = getKeepScrollPositionSetting(previousPageContext);\n            const keepScrollPositionNext = getKeepScrollPositionSetting(pageContext);\n            if (keepScrollPositionNext !== false &&\n                keepScrollPositionPrev !== false &&\n                areKeysEqual(keepScrollPositionNext, keepScrollPositionPrev)) {\n                scrollTarget = { preserveScroll: true };\n            }\n        }\n        // Page scrolling\n        setScrollPosition(scrollTarget, urlOriginal);\n        scrollRestoration_initialRenderIsDone();\n        if (pageContext._hasPageContextFromServer)\n            setPageContextInitIsPassedToClient(pageContext);\n        // Add link prefetch handlers\n        addLinkPrefetchHandlers_watch();\n        addLinkPrefetchHandlers();\n        globalObject.renderedPageContext = pageContext;\n        stampFinished(urlOriginal);\n        return pageContext;\n    }\n}\nasync function getPageContextBegin(isForErrorPage, { urlOriginal, isBackwardNavigation, pageContextsFromRewrite, isClientSideNavigation, pageContextInitClient, isFirstRender, }) {\n    const previousPageContext = globalObject.previousPageContext ?? null;\n    const pageContext = await createPageContextClientSide(urlOriginal);\n    objectAssign(pageContext, {\n        isBackwardNavigation,\n        isClientSideNavigation,\n        isHydration: isFirstRender && !isForErrorPage,\n        previousPageContext,\n        ...pageContextInitClient,\n    });\n    // TO-DO/next-major-release: remove\n    Object.defineProperty(pageContext, '_previousPageContext', {\n        get() {\n            assertWarning(false, 'pageContext._previousPageContext has been renamed pageContext.previousPageContext', {\n                showStackTrace: true,\n                onlyOnce: true,\n            });\n            return previousPageContext;\n        },\n        enumerable: false,\n    });\n    {\n        const pageContextFromAllRewrites = getPageContextFromAllRewrites(pageContextsFromRewrite);\n        assert(!('urlOriginal' in pageContextFromAllRewrites));\n        objectAssign(pageContext, pageContextFromAllRewrites);\n    }\n    return pageContext;\n}\n// For Vike tests (but also potentially for Vike users)\n// https://github.com/vikejs/vike/blob/ffbc5cf16407bcc075f414447e50d997c87c0c94/test/playground/pages/nested-layout/e2e-test.ts#L59\nfunction stampFinished(urlOriginal) {\n    window._vike ?? (window._vike = {});\n    window._vike.fullyRenderedUrl = urlOriginal;\n}\nfunction changeUrl(url, overwriteLastHistoryEntry) {\n    if (getCurrentUrl() === url)\n        return;\n    pushHistoryState(url, overwriteLastHistoryEntry);\n}\nfunction disableClientRouting(err, log) {\n    globalObject.clientRoutingIsDisabled = true;\n    assert(isErrorFetchingStaticAssets(err));\n    if (log) {\n        // We purposely don't use console.error() to avoid flooding error trackers such as Sentry\n        console.log(err);\n    }\n    assertInfo(false, [\n        'Failed to fetch static asset.',\n        import.meta.env.PROD ? 'This usually happens when a new frontend is deployed.' : null,\n        'Falling back to Server Routing.',\n        '(The next page navigation will use Server Routing instead of Client Routing.)',\n    ]\n        .filter(Boolean)\n        .join(' '), { onlyOnce: true });\n}\nfunction getIsRenderOutdated() {\n    const renderNumber = ++globalObject.renderCounter;\n    assert(renderNumber >= 1);\n    let hydrationCanBeAborted = false;\n    const setHydrationCanBeAborted = () => {\n        hydrationCanBeAborted = true;\n    };\n    /** Whether the rendering should be aborted because a new rendering has started. We should call this after each `await`. */\n    const isRenderOutdated = (isRenderCleanup) => {\n        // Never abort first render if `hydrationCanBeAborted` isn't `true`\n        {\n            const isFirstRender = renderNumber === 1;\n            if (isFirstRender && !hydrationCanBeAborted && !isRenderCleanup) {\n                return false;\n            }\n        }\n        // If there is a newer rendering, we should abort all previous renderings\n        return renderNumber !== globalObject.renderCounter;\n    };\n    return {\n        isRenderOutdated,\n        setHydrationCanBeAborted,\n        isFirstRender: renderNumber === 1,\n    };\n}\nfunction getRenderCount() {\n    return globalObject.renderCounter;\n}\nfunction getKeepScrollPositionSetting(pageContext) {\n    const c = pageContext.from.configsStandard.keepScrollPosition;\n    if (!c)\n        return false;\n    let val = c.value;\n    const configDefinedAt = c.definedAt;\n    assert(configDefinedAt);\n    const routeParameterList = getRouteStringParameterList(configDefinedAt);\n    if (isCallable(val))\n        val = val(pageContext, {\n            configDefinedAt: c.definedAt,\n            /* We don't pass routeParameterList because it's useless: the user knows the parameter list.\n            routeParameterList\n            */\n        });\n    if (val === true) {\n        return [\n            configDefinedAt,\n            ...routeParameterList.map((param) => {\n                const val = pageContext.routeParams[param];\n                assert(val);\n                return val;\n            }),\n        ];\n    }\n    // We skip validation and type-cast instead of assertUsage() in order to save client-side KBs\n    return val;\n}\nfunction areKeysEqual(key1, key2) {\n    if (key1 === key2)\n        return true;\n    if (!Array.isArray(key1) || !Array.isArray(key2))\n        return false;\n    return key1.length === key2.length && key1.every((_, i) => key1[i] === key2[i]);\n}\n/**\n * Get the `pageContext` object on the client-side.\n *\n * https://vike.dev/getPageContextClient\n */\nfunction getPageContextClient() {\n    return globalObject.renderedPageContext ?? null;\n}\nasync function loadPageConfigsLazyClientSideAndExecHook(pageContext, isFirstRender, isRenderOutdated) {\n    let hasErr = false;\n    let err;\n    let pageContextAddendum;\n    try {\n        pageContextAddendum = await loadPageConfigsLazyClientSide(pageContext.pageId, pageContext._pageFilesAll, pageContext._globalContext._pageConfigs, pageContext._globalContext._pageConfigGlobal);\n    }\n    catch (err_) {\n        err = err_;\n        hasErr = true;\n        if (handleErrorFetchingStaticAssets(err, pageContext, isFirstRender)) {\n            return { skip: true };\n        }\n        else {\n            // Syntax error in user file\n        }\n    }\n    if (isRenderOutdated())\n        return { skip: true };\n    if (hasErr)\n        return { err };\n    objectAssign(pageContext, pageContextAddendum);\n    try {\n        await execHook('onCreatePageContext', pageContext, preparePageContextForPublicUsageClient);\n    }\n    catch (err_) {\n        err = err;\n        hasErr = true;\n    }\n    if (isRenderOutdated())\n        return { skip: true };\n    if (hasErr)\n        return { err };\n    return { pageContext };\n}\nfunction handleErrorFetchingStaticAssets(err, pageContext, isFirstRender) {\n    if (!isErrorFetchingStaticAssets(err)) {\n        return false;\n    }\n    if (isFirstRender) {\n        disableClientRouting(err, false);\n        // This may happen if the frontend was newly deployed during hydration.\n        // Ideally: re-try a couple of times by reloading the page (not entirely trivial to implement since `localStorage` is needed.)\n        throw err;\n    }\n    else {\n        disableClientRouting(err, true);\n    }\n    redirectHard(pageContext.urlOriginal);\n    return true;\n}\n// [HMR] If error page is shown => re-render whole page\nif (import.meta.env.DEV && import.meta.hot)\n    import.meta.hot.on('vite:afterUpdate', () => {\n        const pageContext = globalObject.renderedPageContext;\n        if (pageContext?.pageId && isErrorPage(pageContext.pageId, pageContext._globalContext._pageConfigs)) {\n            renderPageClientSide({\n                scrollTarget: { preserveScroll: false },\n                urlOriginal: getCurrentUrl(),\n                overwriteLastHistoryEntry: true,\n                isBackwardNavigation: false,\n            });\n        }\n    });\n","// There doesn't seem to be a reliable way to detect React:\n//  - https://stackoverflow.com/questions/73156433/detect-with-javascript-whether-the-website-is-using-react\nexport function isReact() {\n    // Heuristic using values set by React (Dev Tools)\n    // - `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` is an internal API for React Dev Tools\n    //   - https://stackoverflow.com/questions/46807826/how-does-react-developer-tools-determine-that-the-webpage-is-using-react/46808361#46808361\n    //   - In principle, `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` should exist only if React Dev Tools is installed. (Although it seems that it's sometimes defined even when React Dev Tools isn't installed; I don't know why.)\n    // - We use `isReact1`/`isReact2` merely to validate `isReact3` and `isReact4`. Because `isReact1`/`isReact2` can be false negatives:\n    //   - React populates `__REACT_DEVTOOLS_GLOBAL_HOOK__.renderers` fairly late => false negative early in the rendering phase\n    //   - `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` is `undefined` if React Dev Tools isn't installed => false negative\n    const isReact1 = !!window.__REACT_DEVTOOLS_GLOBAL_HOOK__?.renderers?.size;\n    const isReact2 = !!window.__REACT_DEVTOOLS_GLOBAL_HOOK__?.rendererInterfaces?.size;\n    // Heuristic using values set by `@vitejs/plugin-react`\n    const isReact3 = !!window.__vite_plugin_react_preamble_installed__;\n    /* Also set by Preact Vite plugin `@preact/preset-vite`\n    const isReact4 = !!(window as any).$RefreshReg$\n    */\n    // console.log({ isReact1, isReact2, isReact3 })\n    return isReact1 || isReact2 || isReact3;\n}\n","export { initOnPopState };\nimport { onPopStateBegin } from './history.js';\nimport { renderPageClientSide } from './renderPageClientSide.js';\nimport { setScrollPosition } from './setScrollPosition.js';\nimport { catchInfiniteLoop } from './utils.js';\n// The 'popstate' event is triggered when the browser doesn't fully load the new URL, for example:\n// - `location.hash='#foo'` triggers the popstate event while `location.href='/foo'` doesn't.\n// - Clicking on the browser's back-/forward button triggers a popstate event only if the history entry was generated with history.pushState()  no popstate event is fired upon Server Routing.\n// Concretely, 'popstate' is fired when:\n// 1. Back-/forward navigation:\n//    - By the user using the browser's back-/forward navigation\n//    - By the app using `history.back()` / `history.forward()` / `history.go()`\n//    > Except of history entries triggered by Server Routing, see comment above.\n// 2. URL hash changes:\n//    - By the user clicking on `<a href=\"#some-hash\">`\n//      - The popstate event is *only* triggered if `href` starts with '#' (even if `href==='/foo#bar'` and the current URL has the same pathname '/foo' then popstate isn't triggered)\n//      - Vike doesn't intercept hash links (see `isLinkSkipped()`) and let's the browser handle them.\n//    - By the app using a `location` API such as `location.hash = 'some-hash'`\n//      - Only upon hash navigation: setting `location.href='/foo'` triggers a full page reload and no popstate event is fired.\n//      - Also upon `location.href='/foo#bar'` while the current URL is '/foo' (unlike <a> clicks).\n// Notes:\n// - The 'hashchange' event is fired after popstate, so we cannot use it to distinguish between hash and non-hash navigations.\n// - It isn't possible to monkey patch the `location` APIs. (Chrome throws `TypeError: Cannot redefine property` when attempt to overwrite any `location` property.)\n// - Text links aren't supported: https://github.com/vikejs/vike/issues/2114\n// - docs/ is a good playground to test all this.\nfunction initOnPopState() {\n    window.addEventListener('popstate', onPopState);\n}\nasync function onPopState() {\n    catchInfiniteLoop('onPopState()');\n    const { isHistoryStateEnhanced, previous, current } = onPopStateBegin();\n    // - `isHistoryStateEnhanced===false` <=> new hash navigation:\n    //   - Click on `<a href=\"#some-hash\">`\n    //   - Using the `location` API (only hash navigation, see comments above).\n    // - `isHistoryStateEnhanced===true` <=> back-/forward navigation (including back-/forward hash navigation).\n    //   > Only back-/forward client-side navigation: no 'popstate' event is fired upon Server Routing (when the user clicks on a link before the page's JavaScript loaded), see comments above.\n    if (!isHistoryStateEnhanced) {\n        // Let the browser handle it\n        return;\n    }\n    else {\n        await handleBackForwardNavigation(previous, current);\n    }\n}\nasync function handleBackForwardNavigation(previous, current) {\n    const scrollTarget = current.state.scrollPosition || undefined;\n    const isHashNavigation = removeHash(current.url) === removeHash(previous.url) && current.url !== previous.url;\n    if (isHashNavigation) {\n        // We have to scroll ourselves because we have set `window.history.scrollRestoration = 'manual'`\n        setScrollPosition(scrollTarget);\n        return;\n    }\n    const isUserPushStateNavigation = current.state.triggeredBy === 'user' || previous.state.triggeredBy === 'user';\n    const doNotRenderIfSamePage = isUserPushStateNavigation;\n    const isBackwardNavigation = !current.state.timestamp || !previous.state.timestamp ? null : current.state.timestamp < previous.state.timestamp;\n    await renderPageClientSide({ scrollTarget, isBackwardNavigation, doNotRenderIfSamePage });\n}\nfunction removeHash(url) {\n    return url.split('#')[0];\n}\n","export { initOnLinkClick };\nimport { isLinkIgnored, isHrefCurrentUrl, isLinkSkipped } from './isLinkSkipped.js';\nimport { renderPageClientSide } from './renderPageClientSide.js';\nimport { scrollToHashOrTop } from './setScrollPosition.js';\nfunction initOnLinkClick() {\n    document.addEventListener('click', onLinkClick);\n}\nasync function onLinkClick(ev) {\n    if (!isNormalLeftClick(ev))\n        return;\n    const linkTag = findLinkTag(ev.target);\n    if (!linkTag)\n        return;\n    const href = linkTag.getAttribute('href');\n    if (href === null)\n        return;\n    if (isLinkIgnored(linkTag))\n        return;\n    // Workaround for Firefox bug: clicking on a hash link that doesn't change the current URL causes Firefox to erroneously set `window.history.state = null` without firing any signal that we can detect.\n    // - https://github.com/vikejs/vike/issues/1962\n    // - https://github.com/sveltejs/kit/issues/8725\n    if (href.includes('#') && isHrefCurrentUrl(href)) {\n        // Prevent Firefox from setting `window.history.state` to `null`\n        ev.preventDefault();\n        // Replicate the browser's native behavior\n        scrollToHashOrTop(href.split('#')[1]);\n        return;\n    }\n    if (isLinkSkipped(linkTag))\n        return;\n    ev.preventDefault();\n    let scrollTarget;\n    {\n        const v = linkTag.getAttribute('keep-scroll-position');\n        if (v !== null)\n            scrollTarget = { preserveScroll: v === 'false' ? false : true };\n    }\n    await renderPageClientSide({\n        scrollTarget,\n        urlOriginal: href,\n        isBackwardNavigation: false,\n    });\n}\nfunction isNormalLeftClick(ev) {\n    return ev.button === 0 && !ev.ctrlKey && !ev.shiftKey && !ev.altKey && !ev.metaKey;\n}\nfunction findLinkTag(target) {\n    while (target.tagName !== 'A') {\n        const { parentNode } = target;\n        if (!parentNode) {\n            return null;\n        }\n        target = parentNode;\n    }\n    return target;\n}\n","import { assertClientRouting } from '../../utils/assertRoutingType.js';\nassertClientRouting();\nimport { initClientRouter } from './initClientRouter.js';\nimport { assertSingleInstance_onClientEntryClientRouting } from './utils.js';\nimport { removeFoucBuster } from '../shared/removeFoucBuster.js';\nimport { setVirtualFileExportsGlobalEntry } from '../shared/getGlobalContextClientInternalShared.js';\n// @ts-expect-error\nimport * as virtualFileExportsGlobalEntry from 'virtual:vike:global-entry:client:client-routing';\nassertSingleInstance_onClientEntryClientRouting(import.meta.env.PROD);\nsetVirtualFileExportsGlobalEntry(virtualFileExportsGlobalEntry);\ninitClientRouter();\nif (import.meta.env.DEV)\n    removeFoucBuster();\n","export { initClientRouter };\nimport { assert } from './utils.js';\nimport { getRenderCount, renderPageClientSide } from './renderPageClientSide.js';\nimport { initOnPopState } from './initOnPopState.js';\nimport { initOnLinkClick } from './initOnLinkClick.js';\nimport { scrollRestoration_init } from './scrollRestoration.js';\nimport { autoSaveScrollPosition } from './setScrollPosition.js';\nimport { initLinkPrefetchHandlers } from './prefetch.js';\nimport { initHistory } from './history.js';\nasync function initClientRouter() {\n    // Init navigation history and scroll restoration\n    initHistoryAndScroll();\n    // Render/hydrate\n    const renderFirstPagePromise = renderFirstPage();\n    // Intercept <a> clicks\n    initOnLinkClick();\n    // Add <a> prefetch handlers\n    initLinkPrefetchHandlers();\n    // Preserve stack track\n    await renderFirstPagePromise;\n}\nasync function renderFirstPage() {\n    assert(getRenderCount() === 0);\n    await renderPageClientSide({\n        scrollTarget: { preserveScroll: true },\n        isBackwardNavigation: null,\n        isClientSideNavigation: false,\n    });\n}\nfunction initHistoryAndScroll() {\n    scrollRestoration_init();\n    initHistory(); // we redundantly call initHistory() to ensure it's called early\n    autoSaveScrollPosition();\n    // Handle back-/forward navigation\n    initOnPopState();\n}\n"],"file":"assets/entries/entry-client-routing.BPoEy78y.js"}